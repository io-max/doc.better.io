<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Volatile 解析</title>
    <link href="/2022/11/18/thread/volatile-resolve/"/>
    <url>/2022/11/18/thread/volatile-resolve/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本章讲解如下：</p><ul><li>Volatile 关键字的作用？</li><li>Volatile 是如何保证有序性？如何保证可见性？</li></ul></blockquote><span id="more"></span><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a><em>Volatile</em></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>知道了 Synchronized 关键字可以保证在高并发下的<code>可见性，有序性，原子性</code>，今天来看看 Volatile 这个关键字的作用。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>保证在多线程的情况下程序的<code>可见性</code>和<code>有序性</code>。</p><p>对 Volatile 修饰变量的单次读写是可以保证原子性的，复合操作则不行例如：++i 或 i+&#x3D;1</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>从两个方面讲解 Volatile 的实现原理，分别是：<code>可见性的实现</code>和<code>有序性的实现</code></p><h4 id="可见性实现原理"><a href="#可见性实现原理" class="headerlink" title="可见性实现原理"></a>可见性实现原理</h4><blockquote><p>可见性的实现是基于<code>内存屏障</code></p></blockquote><h5 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a><strong>什么是内存屏障？</strong></h5><p>所谓内存屏障就是内存栅栏，即一道 CPU 指令。</p><h5 id="lock-指令"><a href="#lock-指令" class="headerlink" title="lock 指令"></a>lock 指令</h5><p>而 Volatile 就是使用 lock 前缀指令来实现的，在多核 CPU 下遇到 lock 前缀会引发触发下拉事件：</p><ul><li>将当前处理器缓存行中的数据写回内存。</li><li>写回内存的操作会使缓存了此内存地址的数据无效</li></ul><p>汇编代码如下：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210315143739503.png" alt="image-20210315143739503"></p><p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>为了保证各个处理器的缓存是一致的，实现了<code>缓存一致性协议(MESI)</code>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期，当处理器发现自己缓存行对应的内存地址被修改（Modify），就会将当前处理器的缓存行设置成无效状态（Invalid），当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><h5 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h5><p>在早期的CPU 中 lock 前缀指令会产生一个<code>LOCK#信号</code>，会导致锁住整个<code>总线</code>，其他CPU 对内存的读写都将阻塞。</p><p>这会大大的影响性能，后来的 CPU 都将范围缩小到各个 CPU 的高速缓存。通过缓存一致性协议实现。</p><p>而缓存是分段（一行一行）的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，通常来说是 64 字节。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">static</span> &#123;<br>  arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>  arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_0000L</span>; i++) &#123;<br>      arr[<span class="hljs-number">0</span>].x = i;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_0000L</span>; i++) &#123;<br>      arr[<span class="hljs-number">1</span>].x = i;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>  one.start();<br>  two.start();<br><br>  one.join();<br>  two.join();<br>  System.out.println((System.nanoTime() - start) / <span class="hljs-number">100_0000</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>  <span class="hljs-comment">// public volatile long p1, p2, p3, p4, p5, p6, p7;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中两个线程都对 x 这个 Volatile 变量进行缓存（各自 CPU 的高速缓存），当线程修改时会有以下情况：</p><ul><li>注释打开，此时一个 T 对象刚好占用一个缓存行，线程发生读写，两个线程互不影响。</li><li>注释关闭，此时两个 T 对象占用一个缓存行，线程发生读写，会导致两个线程不断重置并获取最新值。</li></ul><h4 id="有序性实现原理"><a href="#有序性实现原理" class="headerlink" title="有序性实现原理"></a>有序性实现原理</h4><blockquote><p>有序性的实现是基于 happens-before 和 内存屏障</p></blockquote><h5 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h5><p>happens-before 中有一个 Volatile 规则即：所有对这个 Volatile 域前的写操作都 happens-before 后面对这个 Volatile 域的读操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> flag;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>  System.out.println(flag);  <span class="hljs-comment">// step3</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a; <span class="hljs-comment">// step4</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>  a++;           <span class="hljs-comment">// step1</span><br>  flag = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// step2 </span><br>&#125;<br></code></pre></td></tr></table></figure><p>假设先调用 write 方法在调用 read 方法，则会有以下规则：</p><ul><li>程序次序规则：step1 happens-before step2 ，step3 happens-before step4</li><li>Volatile 规则：setp1 happens-before step3， step2 happens-before step4</li><li>传递性规则：step1 happens-before step4</li></ul><p>重排序有两种方式：<code>编译器重排序</code>和<code>处理器重排序</code>，为了实现volatile内存语义，JMM会对volatile变量限制这两种类型的重排序。下面是JMM针对volatile变量所规定的重排序规则表：</p><ul><li>编译器重排序：编译器级别即 Java 代码通过 Javac 编译出的字节码顺序和源代码不一致。</li><li>处理器重排序：硬件和 CPU 级别的重排序，为了充分利用 CPU 的性能。</li></ul><p>规则表：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210315173747043.png" alt="image-20210315173747043"></p><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><p>而处理器重排序则使用了内存屏障来完成有序性，规则如下：</p><ul><li>在每个 Volatile 写操作的<code>前面</code>插入一个 StoreStore 屏障</li><li>在每个 Volatile 写操作的<code>后面</code>插入一个 StoreLoad 屏障</li><li>在每个 Volatile 读操作的<code>后面</code>插入一个 LoadLoad 屏障</li><li>在每个 Volatile 读操作的<code>后面</code>插入一个 LoadStore 屏障</li></ul><p><strong>Volatile 写操作是在前面和后面分别插入内存屏障，而 Volatile 读操作是在后面插入了两个内存屏障。</strong></p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210315174008943.png" alt="image-20210315174008943"></p><p>总结如下：</p><ul><li>当进行完普通读写时再次进行 Volatile 写时不支持重排序</li><li>当进行完 Volatile 读后再次进行普通读写或 Volatile 读或 Volatile 写时不支持重排序</li><li>当进行完 Volatile 写后再次进行 Volatile 读和 Volatile 写时不支持重排序</li></ul><p>可见性：LoadBarrier 和 StoreBarrier，LoadBarrier 作用是将其他线程对于共享变量的更新从其他处理器同步到当前线程的处理器，StoreBarrier 保证写线程对共享变量的更新对于其他读线程的处理器是可同步的。</p><p><strong>不要使用 String 类型的对象来加锁</strong></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="DCL-单例需要加-Volatile-关键字吗？"><a href="#DCL-单例需要加-Volatile-关键字吗？" class="headerlink" title="DCL 单例需要加 Volatile 关键字吗？"></a>DCL 单例需要加 Volatile 关键字吗？</h3><p>答案：</p><p>需要加 Volatile 关键字，因为对象的创建分为三个步骤：</p><ol><li><p>申请内存（赋予默认值，int &#x3D; 0）</p></li><li><p>对象赋值（用户指定的值）</p></li><li><p>对象指向目标（）</p></li></ol><p>而这三个步骤可能会被 Jvm 重排序，可能 步骤 1 执行完直接就执行步骤 3</p>]]></content>
    
    
    <categories>
      
      <category>volatile</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
      <tag>Volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap 解析</title>
    <link href="/2022/11/18/utils/hashmap_resolve/"/>
    <url>/2022/11/18/utils/hashmap_resolve/</url>
    
    <content type="html"><![CDATA[<h2 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h2><blockquote><p>本章讲解如下：</p><ol><li>HashMap 的常用方法的使用：put，set，remove</li><li>HashMap 是如何解决 hash 冲突？</li><li>HashMap 的时间复杂度&#x2F;空间复杂度？</li><li>HashMap 底层源码分析</li></ol></blockquote><span id="more"></span><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>HashMap的实例具有两个影响其性能的参数：<code>初始容量</code>和<code>负载因子</code>。容量是哈希表中存储桶的数量，初始容量只是创建哈希表时的容量。负载因子是散列表的容量自动增加之前允许其填充的完整程度的度量。当哈希表中的条目数超过负载因子和当前容量的乘积时，哈希表将被重新哈希（即，内部数据结构将被重建），因此哈希表的存储桶数约为两倍。</p><p>通常，默认负载因子（0.75）在时间和空间成本之间提供了一个很好的折衷方案。较高的值会减少空间开销，但会增加查找成本（在HashMap类的大多数操作中都得到体现，包括get和put）。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 默认加载因子</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">// 转变红黑树的阈值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// 不转变红黑树的阈值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">// 红黑树最小的容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* ---------------- Fields -------------- */</span><br><br><span class="hljs-comment">// 数组，用于存放链表。第一次使用时初始化</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><br><span class="hljs-comment">// 长度</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">// 记录 rehash 的计数</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<br><br><span class="hljs-comment">// 当前容量阈值</span><br><span class="hljs-type">int</span> threshold;<br><br><span class="hljs-comment">// 当前加载因子</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br></code></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>  <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                       initialCapacity);<br>  <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>    initialCapacity = MAXIMUM_CAPACITY;<br>  <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                       loadFactor);<br>  <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>  <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h3><h4 id="核心成员"><a href="#核心成员" class="headerlink" title="核心成员"></a>核心成员</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;  <span class="hljs-comment">// hash 值</span><br><span class="hljs-keyword">final</span> K key;     <span class="hljs-comment">// 存储的 Key</span><br>V value;    <span class="hljs-comment">// 存储的 Value</span><br>Node&lt;K,V&gt; next;  <span class="hljs-comment">// 后继节点，形成单向链表</span><br></code></pre></td></tr></table></figure><h4 id="核心构造函数"><a href="#核心构造函数" class="headerlink" title="核心构造函数"></a>核心构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>  <span class="hljs-built_in">this</span>.hash = hash;<br>  <span class="hljs-built_in">this</span>.key = key;<br>  <span class="hljs-built_in">this</span>.value = value;<br>  <span class="hljs-built_in">this</span>.next = next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>HashMap 的核心方法这里只讲解 put，get，remove 三个方法。</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><p>put 方法用于向 HashMap 中添加元素，支持</p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>  <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>hash()</code> 方法计算 key 的 hash 值(此方法后面会讲解)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>  Node&lt;K,V&gt;[] tab; <span class="hljs-comment">// 当 hashMap 的数组</span><br>  Node&lt;K,V&gt; p;   <span class="hljs-comment">// 数组中的节点</span><br>  <span class="hljs-type">int</span> n, i;<br>  <span class="hljs-comment">// 数组为空则调用 resize 方法对 table 进行初始化</span><br>  <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>    n = (tab = resize()).length;<br>  <span class="hljs-comment">// 通过数组长度 &amp; hash 值找到，此 hash 所在的节点</span><br>  <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>    tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>  <span class="hljs-comment">// 节点不为空</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    Node&lt;K,V&gt; e; <br>    K k;<br>    <span class="hljs-comment">// hash 碰撞</span><br>    <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>      e = p;<br>    <span class="hljs-comment">// 如果是 TreeNode 则调用</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br><span class="hljs-comment">// hash 未碰撞，向后遍历查找</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>        <span class="hljs-comment">// 后继节点为空，则直接创建 Node 节点</span><br>        <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>          p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>          <span class="hljs-comment">// 如果达到树节点的阈值，则调用treeifyBin将节点（链表）改为树结构</span><br>          <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>            treeifyBin(tab, hash);<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 后继节点不为空且 key-value 都相同，直接结束循环</span><br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 不同则继续向后查找</span><br>        p = e;<br>      &#125;<br>    &#125;<br>   <span class="hljs-comment">// 节点不为空，说明存在映射的 key</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>      <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>        e.value = value;<br>      afterNodeAccess(e);<br>      <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 记录 rehash 的次数</span><br>  ++modCount;<br>  <span class="hljs-comment">// 超过阈值则进行扩容</span><br>  <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>    resize();<br>  afterNodeInsertion(evict);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><ol><li>如果 HashMap 未初始化，则调用 <code>resize </code>方法进行初始化。</li><li>通过 <code>数组长度(table.length - 1)</code> <strong>&amp;</strong> <code>hash 值</code>计算出 index 并判断链表头节点是否为空<ol><li>链表头节点为空，说明可以新增节点，成功则执行步骤 4</li><li>链表头节点不为空，执行步骤 3</li></ol></li><li>当链表头节点不为空，有一下三种结果：<ol><li>当前 hash 与链表头节点产生 hash 碰撞。</li><li>链表节点为 TreeNode，说明此时数据结构不在是链表而是树结构了</li><li>当前 hash 和链表头节点未产生 hash 碰撞 <ol><li>从链表头节点向后遍历，有两种状况：<ol><li>next 节点与当前 hash 未产生碰撞，继续向后遍历，计数+1</li><li>next 节点为空，则直接创建新节点并添加到链表中，当计数超过树阈值则当前链表结构会升级为树结构（<code>treeifyBin方法</code>）, 并结束循环。</li></ol></li></ol></li><li>产生碰撞后说明存在映射的 key，则替换旧值。</li></ol></li><li>记录 hash 次数，判断 size 是否超过阈值，超过则调用<code>resize</code>进行扩容</li></ol><h5 id="树节点"><a href="#树节点" class="headerlink" title="树节点"></a>树节点</h5><p>当遍历链表时长度超过了 8 个，链表结构就会被淘汰升级会树结构，其数据结构就是 <code>TreeNode</code>。</p><p>后面会讲解 TreeNode</p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><p>get 方法用于根据指定的 key 从 HashMap 中获取 value</p><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>  Node&lt;K,V&gt; e;<br>  <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看 getNode 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>  Node&lt;K,V&gt;[] tab; <br>  Node&lt;K,V&gt; first,<br>  Node&lt;K,V&gt; e; <br>  <span class="hljs-type">int</span> n; <br>  K k;<br>  <span class="hljs-comment">// table 不为空 且 节点不为空</span><br>  <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp; (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) <br>  &#123;<br>    <span class="hljs-comment">// 头节点hash 与当前 hash 一致</span><br>    <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>      <span class="hljs-keyword">return</span> first; <span class="hljs-comment">// 直接返回</span><br>    <span class="hljs-comment">// 后继节点不为空</span><br>    <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 节点为树形结构</span><br>      <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>        <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br><span class="hljs-comment">// 开启循环， 遍历链表</span><br>      <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 判断 hash 是否一致，一致则直接返回</span><br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>          <span class="hljs-keyword">return</span> e;<br>      &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h5><ol><li>判断 table 是否为空，为空直接返回 bull，不为空执行步骤 2</li><li>获取到链表头节点，并判断是否与当前 hash 一致，一致则直接返回，否则执行步骤 3</li><li>判断后继节点是否为空，为空直接返回 null ，不为空则执行步骤 4</li><li>链表头节点为树结构，直接转成 TreeNode 获取对象，反之执行步骤 5</li><li>开启循环，不断获取后继节点，不断的判断后继节点的 hash 是否与当前 hash 一致，一致则返回，反之则继续向后遍历，如果遇到后继节点为 null，则结束循环返回 null。</li></ol><h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h4><p>用于通过 key 删除 HashMap 中的数据</p><h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>  Node&lt;K,V&gt; e;<br>  <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) == <span class="hljs-literal">null</span> ?<br>    <span class="hljs-literal">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入 removeNode 方法，查看具体的删除细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">removeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value,</span><br><span class="hljs-params">                           <span class="hljs-type">boolean</span> matchValue, <span class="hljs-type">boolean</span> movable)</span> &#123;<br>  Node&lt;K,V&gt;[] tab; <br>  Node&lt;K,V&gt; p; <br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-type">int</span> index;<br>  <span class="hljs-comment">// 数组不为空，且指定 hash 位置的链表不为空</span><br>  <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>      (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>    Node&lt;K,V&gt; node = <span class="hljs-literal">null</span>, <br>    Node&lt;K,V&gt; e; <br>    K k;<br>    V v;<br>    <span class="hljs-comment">// 命中 hash</span><br>    <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>      node = p; <span class="hljs-comment">// 赋值</span><br>    <span class="hljs-comment">// 未命中</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>        <span class="hljs-comment">// 从树形节点中获取</span><br>        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;  <span class="hljs-comment">// 开启循环，直到尾节点为 null</span><br>          <span class="hljs-comment">// 判断后继节点是否命中 hash</span><br>          <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;<br>            node = e;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-comment">// 未命中继续向后</span><br>          p = e;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// node 不为空说明 hash 命中了</span><br>    <span class="hljs-comment">// 是否匹配 value 值</span><br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                         (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)))) &#123;<br>      <span class="hljs-comment">// </span><br>      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-built_in">this</span>, tab, movable);<br><span class="hljs-comment">// 命中了链表的头节点</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>        tab[index] = node.next;<br><span class="hljs-comment">// 非头节点</span><br>      <span class="hljs-keyword">else</span><br>        p.next = node.next;<br><span class="hljs-comment">// 修改值</span><br>      ++modCount;<br>      --size;<br>      afterNodeRemoval(node);<br>      <span class="hljs-keyword">return</span> node;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="执行流程-2"><a href="#执行流程-2" class="headerlink" title="执行流程"></a>执行流程</h5><ol><li>判断数组是否为空，且 hash 索引处的链表是否为空，为空直接返回 null，反之执行步骤 2</li><li>判断hash是否命中链表的头节点，命中执行步骤 4，未命中执行步骤 3</li><li>开启循环，向后遍历链表，判断 hash 是否命中，命中则结束循环执行步骤 4，反之循环结束执行步骤 4</li><li>判断是否匹配 value<ol><li>链表升级为树，则调用 TreeNode 删除节点</li><li>命中链表头节点。</li><li>为命中链表头节点，修改 next 指针。</li></ol></li></ol><h4 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h4><p>hash 方法用于计算 key 的 hash 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>  <span class="hljs-type">int</span> h;<br>  <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>举例：此时假设默认长度是 16，则 index 的索引计算查看低 4 为</p><p>key.hashCode:    1101 0100 1010 1010 1011 1111 0010 0111</p><p>h&gt;&gt;&gt;16:               0000 0000 0000 0000 1101 0100 1010 1010 </p><p>hash ^ h&gt;&gt;&gt;16:   1101 0100 1010 1010 0110 1011 1000 1101</p><p>hash 计算后再与<code>table.length-1</code> 进行<code>或运算</code></p><p>代码： <code>tab[i = (n - 1) &amp; hash]</code>，n 为数组长度， hash 则是通过或运算计算出的 hash</p><p>table.length-1 : 0000 0000 0000 0000 0000 0000 0000 1111</p><p>hash :                1101 0100 1010 1010 0110 1011 1000 1101</p><p>i:                        0000 0000 0000 0000 0000 0000 0000 1101  （13）</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>上面知道了当大小超过了阈值就会进行扩容，调用 resize 方法</p><h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>  Node&lt;K,V&gt;[] oldTab = table;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>  <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 旧容量大于0</span><br>  <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>      threshold = Integer.MAX_VALUE;<br>      <span class="hljs-keyword">return</span> oldTab;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>      newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>  &#125;<br>  <span class="hljs-comment">// 加载因子大于 0</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>    newCap = oldThr;<br><span class="hljs-comment">// 加载默认配置</span><br>  <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>    newCap = DEFAULT_INITIAL_CAPACITY;<br>    newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>  &#125;<br>  <span class="hljs-comment">// 长度阈值为 0，则重新计算</span><br>  <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>              (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>  &#125;<br>  threshold = newThr;<br>  <span class="hljs-comment">// 创建新数组</span><br>  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>  table = newTab;<br>  <span class="hljs-comment">// 旧数组不为空</span><br>  <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 遍历数组中所有的链表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>      Node&lt;K,V&gt; e;<br>      <span class="hljs-comment">// 链表节点不为空</span><br>      <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>        oldTab[j] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 后继节点为空</span><br>        <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>          newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>        <span class="hljs-comment">// 树形结构</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>          ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br><span class="hljs-comment">// 后继节点不为空</span><br>        <span class="hljs-keyword">else</span> &#123;<br>          Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 低位头节点</span><br>          Node&lt;K,V&gt; loTail = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 低位尾节点</span><br>          Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 高位头节点</span><br>          Node&lt;K,V&gt; hiTail = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 高位尾节点</span><br>          Node&lt;K,V&gt; next;<br>          <br>          <span class="hljs-keyword">do</span> &#123;<br>            next = e.next;<br>            <span class="hljs-comment">// 索引在低位</span><br>            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                loHead = e;      <br>              <span class="hljs-keyword">else</span><br>                loTail.next = e; <br>              loTail = e;        <span class="hljs-comment">// 第一次赋值，tail 和 head 都是 e</span><br>            &#125;<br>            <span class="hljs-comment">// 索引在高位</span><br>            <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                hiHead = e;<br>              <span class="hljs-keyword">else</span><br>                hiTail.next = e;<br>              hiTail = e;<br>            &#125;<br>            <span class="hljs-comment">// 继续下一个节点</span><br>          &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>          <br>          <span class="hljs-comment">// 存储低位</span><br>          <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>            loTail.next = <span class="hljs-literal">null</span>;<br>            newTab[j] = loHead;<br>          &#125;<br>          <span class="hljs-comment">// 存储高位</span><br>          <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>            hiTail.next = <span class="hljs-literal">null</span>;<br>            newTab[j + oldCap] = hiHead;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="执行流程-3"><a href="#执行流程-3" class="headerlink" title="执行流程"></a>执行流程</h4><ol><li>重新计算阈值和加载因子</li><li>创建新数组</li><li>遍历旧数组，获取到每个下标的链表，为空则跳过继续下次循环<ol><li>链表的后继节点为空，直接插入数组</li><li>链表的后继节点不为空，开启循环遍历链表<ol><li>声明高位头尾节点，低位头尾节点</li><li>通过节点的 hash 与旧数组长度与运算，判断结果是否为 0<ol><li>为 0 则是低位，赋值低位的头尾节点</li><li>不为 0 则是高位，赋值高位的头尾节点</li></ol></li><li>判断高低位的头尾节点是否为空，不为空直接插入数组</li></ol></li><li>节点为红黑树类型，调用 TreeNode.split 方法</li></ol></li></ol><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://www.hollischuang.com/archives/2091">Hash 解析</a></p>]]></content>
    
    
    <categories>
      
      <category>HashMap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Map</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synchronized 解析</title>
    <link href="/2022/11/18/thread/synchronized-resolve/"/>
    <url>/2022/11/18/thread/synchronized-resolve/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本章讲解如下：</p><ul><li>Synchronized 关键字的使用?</li><li>Synchronized 关键字在使用中锁的变化,及其升级过程?</li><li>Synchronized 的底层实现?</li><li>锁的分类有些? </li><li>锁优化有哪些?</li></ul></blockquote><span id="more"></span><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在 Jdk1.5 之前 Synchronized 是一个重量级锁，但在 1.6 之后 Synchronized 经过优化后会经过一系列锁升级才会成为重量级锁。而 Synchronized 用的锁是存储在锁对象的<code>对象头</code>中。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Synchronized 可以解决并发编程中的三个问题分别是：原子性（CPU 分片）， 有序性（编译器指令重拍），可见性（CPU 缓存）</p><ul><li>原子性：确保线程互斥的访问同步代码</li><li>有序性：有效解决重排序问题</li><li>可见性：保证共享变量的修改能够及时可见</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Synchronized 可以使用任意<code>非 null </code>的对象来作为锁, 这些<code>锁</code>被称为<code>对象监视器(ObjectMonitor)</code>。</p><p><code>Synchronized</code>可以修饰<code>静态方法（Class 实例）、实例方法（this 实例）、对象实例（括号范围）</code>，归根结底它能上锁的资源只有一类：就是<code>对象</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//对象锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> &#123;&#125;  <span class="hljs-comment">// 此时锁的是 this 当前对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>(obj) &#123;&#125;  <span class="hljs-comment">// 锁的范围仅仅在大括号范围</span><br>&#125;<br><br><span class="hljs-comment">// 类锁</span><br><span class="hljs-keyword">public</span> statis <span class="hljs-keyword">void</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> &#123;&#125;  <span class="hljs-comment">// 此时锁的是当前Class对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>(Demo.class) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Synchronized 是通过对象内部的一个叫做<code>监视器锁（moniter）</code>来实现的，而监视器锁本质依赖OS 底层的 <code>Mutex Lock</code>（互斥锁）来实现的。且 OS 实现线程的切换需要从用户态切换到内核态，成本太高，所以将这种依赖 Mutex Lock 实现的锁称为重量级锁。</p><p>任意对象都有一个Monitor与之关联，当且一个Monitor被持有后其关联的对象将处于锁定状态。Synchronized 就是基于<code>进入</code>和<code>退出</code> Monitor 对象来实现的。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>在 Java 中任何对象都有可能成为 Monitor，当一个对象被 new 出来后都会携带一把看不见的锁：Monitor 锁</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>而 Monitor 的在 HotSpot 中是由 <code>ObjectMonitor</code> 实现的，其结构在<code>objectMonitor.hpp</code>中定义</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210312145902426.png" alt="image-20210312145902426"></p><p>其包含了三个非常的字段：WaitSet 和 EntryList 和 Owner。</p><ul><li>_WaitSet：用于存放处于 wait 状态的线程</li><li>_EntryList：用于存放处于 blocked 状态的线程</li><li>_owner：用于存储获取到锁的线程</li><li>_count：记录个数</li></ul><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>Monitor锁的获取流程紧紧围绕着 <code>_WaitSet、_EntryList、_owner</code> 三个字段展开；大致步骤如下：</p><ul><li>当线程尝试获取锁时，会被包装成 ObjectWaiter，并进入 EntryList 中等待，判断 EntryList 是否为空<ul><li>为空：直接占领 Owner，执行同步代码块</li><li>不为空：则和之前的线程一起等待</li></ul></li><li>当线程持有 Monitor 时有两个选择：<ul><li>正常执行完代码块的代码，释放监视器</li><li>执行一般等待某个条件的出现，调用 <code>wait() </code>进入 wait 状态，释放 _owner , count 减 1 ；并进入 WaitSet 中等待条件满足被唤醒。</li></ul></li><li>当被唤醒后，继续获取监视器执行代码</li></ul><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200822151020.png"></p><p>一个线程只有在持有Monitor时才能调用<code>wait()</code>方法进入<code>_WaitSet 队列</code>，而处于_WaitSet 队列的线程只有再次获得监视器才能退出等待状态。</p><h4 id="线程如何出入Monitor？"><a href="#线程如何出入Monitor？" class="headerlink" title="线程如何出入Monitor？"></a>线程如何出入Monitor？</h4><p><strong>JVM 使用 <code>monitorenter</code> 和 <code>monitorexit</code> 两个字节码指令来进入和退出 Monitor 对象</strong> </p><h4 id="线程如何找到-Monitor？"><a href="#线程如何找到-Monitor？" class="headerlink" title="线程如何找到 Monitor？"></a>线程如何找到 Monitor？</h4><p>Monitor对象存在于每个Java对象的<code>对象头</code>Mark Word中（存储的指针的指向）。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时<code>notify/notifyAll/wait</code>等方法会使用到Monitor 锁对象，所以必须在同步代码块中使用。</p><h3 id="monitorenter和monitorexit"><a href="#monitorenter和monitorexit" class="headerlink" title="monitorenter和monitorexit"></a><code>monitorenter</code>和<code>monitorexit</code></h3><p>上面将了Synchronized 的底层是通过<code>进入</code>和<code>退出</code>Monitor 对象来实现的，那么线程是如何进入和退出 Monitor 对象呢？</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>先使用 <code>javap -c -s -v -l</code> 来对一个编译好的只有一个同步方法的类进行反编译，结果如下：</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210311160653484.png" alt="image-20210311160653484"></p><p>从图中可以看出 <code>synchronized</code> 底层使用 <code>monitorenter</code> 和 <code>monitorexit</code> 两个指令完成。</p><p><strong>使用 monitorenter 来进入 monitor 对象，而 monitorexit 来退出 monitor 对象</strong>，而第二个 monitorexit 是为了防止程序出现异常锁不释放。</p><p><strong>当使用Synchronized加锁出现异常会不会释放锁？会释放，这里可以证明这点</strong></p><h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a><code>monitorenter</code></h4><p>该 <code>monitorenter</code> 用于开启对<code>monitor</code>的监控, 并获取 monitor 的所有权，只有到获取到来 monitor 的所有权此 monitor 才会锁定。</p><p>执行<code>monitorenter</code>的线程获取 monitor 的流程：</p><ol><li>如果monitor的计数条目为0，则线程进入monitor，并将计数加 1；然后该线程是monitor所有者。（获取到锁）</li><li>如果线程已经拥有计数器，那么它会重新进入monitor，增加计数条目。（可重入锁）</li><li>如果另外一个线程拥有此monitor，则线程会被阻塞，直到monitor的计数条目变为 0，则再次获取monitor所有权。（为获取到锁，但尝试获取锁）</li></ol><h4 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a><code>monitorexit</code></h4><p>而 <code>monitorexit</code> 指令用于释放monitor的所有权, 执行<code>monitorexit</code>的线程必须是monitor的所有者。该线程减少monitor的条目计数。结果，如果条目计数的值为零，则线程退出monitor，并且不再是其所有者。其他被阻止进入monitor的线程也可以尝试这样做。</p><p><strong>特点: 一个<code>monitorenter</code>指令可以和多个<code>monitorexit</code>指令结合使用。</strong></p><p><strong>可重入性</strong></p><p>Synchronized 先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一. 即通过计数器实现的 .</p><p>当Synchronized修饰实例方法时会在方法标识上添加了<code>ACC_SYNCHRONIZED</code>, 当线程池调用此方法时会去检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译结果：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210312112504055.png" alt="image-20210312112504055"></p><p><strong>在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</strong></p><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>知道了Synchronized 通过 monitorenter 和 monitorexit 来进入和退出 Monitor 来实现同步的功能，那么问题来了</p><p><strong>monitorenter 和 monitorexit 是如何找到 Monitor对象的呢？</strong></p><p>答案是<code>对象头</code>，要知道对象头在哪里就必须了解 Java 对象内存布局。</p><h4 id="对象布局"><a href="#对象布局" class="headerlink" title="对象布局"></a>对象布局</h4><p>在 Java 中对象在内存中的布局大致分为三部分： <code>对象头，实例数据， 对齐填充</code>。</p><ul><li><p>实例数据：存放类的属性信息和父类的属性信息</p></li><li><p>对齐填充：JVM 要求对象<code>起始地址</code>必须是 8 字节的整数倍</p></li><li><p>对象头中存储了：对象自身的运行时数据（Mark Word）、类型指针（Class Point）</p><ul><li>如果对象是数组类型则对象头还会存储：数组长度</li><li>对象头在 32 位和 64 位操作系统分别占用 32bit 和 64bit</li></ul></li></ul><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头分为两部分：<code>Mark Word</code> 和 <code>Class Pointer</code>。我们重点关注 Mark Word。</p><p>Class Pointer 即指向当前对象的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><p>而Mark Word 存储了<code>哈希码</code>、<code>分代年龄</code>、<code>锁标志位</code>、<code>偏向线程ID</code>、<code>偏向时间</code>戳等信息。</p><p>在 OpenJdk 的 Hotspot 源码的 markOop.hpp 文件中对 Mark Word 进行了描述</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210312162706709.png" alt="image-20210312162706709"></p><p>结果如下图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200822150953.png"  /><p>在对象的最后两个 bit 为存储了锁的标识位， 默认是 01 即正常对象， 而随着锁等级的不同。存储的数据如下列表：</p><table><thead><tr><th>锁状态</th><th>锁标识位</th><th>存储内容</th></tr></thead><tbody><tr><td>无锁</td><td>001</td><td>对象 HashCode(如果有调用)</td></tr><tr><td>偏向锁</td><td>101</td><td>持有线程的线程ID</td></tr><tr><td>轻量级锁、自旋锁</td><td>00</td><td>指向持有线程栈帧中的 Lock Record 指针</td></tr><tr><td>重量级锁</td><td>10</td><td>指向互斥量（向需要向内核申请锁）的指针</td></tr></tbody></table><p>而 monitorenter 和 monitorexit 操作的 monitor 就是对象在内存中的<code>对象头</code>(通过指针)</p><h4 id="Lock-Record"><a href="#Lock-Record" class="headerlink" title="Lock Record"></a>Lock Record</h4><p>线程要想获取到锁，则必须和对象头中的 Mark Word 建立关联，而这个关联就是通过 Lock Record 来实现的。</p><p>Lock Record 顾名思义为<code>锁记录</code>, 它主要存在于线程的栈帧中，每个线程都有属于自己的 Lock Record 列表。</p><p>主要用于<code>存储对象头中的 Mark Word 的拷贝</code>，且每个Lock Record 同一时间只能与一个 Mark Word 关联；标识该对象锁被当前线程持有。</p><p>Lock Record 中有个 <code>owner</code> 字段用于存放<code>拥有该锁的线程的唯一标识</code>或<code>锁对象的 Mark Word</code>。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>上面的内容大致讲述了 Synchronized 的底层实现，以及 Lock Record 和 Mark Word 和 Monitor 的关系。</p><p>Lock Record 通过存储对象头中 Mark Word 的拷贝来建立关联，并开始抢占 Monitor 锁。</p><ul><li><p>获取成功则修改 Mark Work 中的锁标志位，并修改其中的指针。</p></li><li><p>获取失败则进行阻塞（ObjectMonitor 的_EntreyList）。</p></li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>由于 Jdk 在 1.5 之前Synchronized是非常重的锁，在 1.6 之后对Synchronized进行了优化和调整，加入了<code>自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略</code>。</p><p>锁主要存在四种状态，依次是<strong>：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</p><p>在 JDK 1.6 中默认是开启偏向锁和轻量级锁的，可以通过<code>-XX:-UseBiasedLocking</code>来禁用偏向锁。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="为什么会有自旋锁？"><a href="#为什么会有自旋锁？" class="headerlink" title="为什么会有自旋锁？"></a>为什么会有自旋锁？</h4><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，而频繁的阻塞唤醒非常消耗 CPU 资源。</p><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>所谓自旋锁就是当一个线程尝试获取锁时，如果该锁被其他线程占用，则该线程就<code>一直循环</code>检测锁是否被释放，而不是进行<code>睡眠</code>或<code>挂起</code>状态。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>自旋锁适用于锁保护的临界区很小的情况，所谓临界区就是指访问<code>共享资源</code>的<code>程序片段</code>，当临界区很小时，锁占用的时间很短。为什么？</p><p>因为自旋锁是占用 CPU 资源的，如果临界区太大，执行时间长，则 CPU 资源会被占用很长时间，典型占着茅坑不拉屎。</p><p>在 Jdk1.6 自旋锁默认开启，自旋的默认次数为 <code>10</code>，可通过<code>-XX:PreBlockSpin</code>指令修改，但 Jvm加入了<code>自适应</code>，可自适应性的修改自旋次数。</p><h4 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a><strong>自适应自旋</strong></h4><p>如果自旋成功，则自旋的次数会增加，反之如果失败，则会减少自旋的次数，避免过度浪费 CPU 资源。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>在某些情况下当同步代码中的对象不存在被多个线程竞争时，JVM会对这些同步锁进行锁消除。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_02_Lock_Clean</span> &#123;<br><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">_02_Lock_Clean</span> <span class="hljs-variable">lock_clean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">_02_Lock_Clean</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      lock_clean.lockClean(i);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockClean</span><span class="hljs-params">(<span class="hljs-type">int</span> source)</span> &#123;<br>    lock += source;<br>    System.out.println(lock);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 main 方法 lock_clean 对象没有逃逸出 main 方法，所以 JVM 认为不存在竞争关系。</p><p>方法生成的字节码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">0</span> aload_0<br> <span class="hljs-number">1</span> aload_0<br> <span class="hljs-number">2</span> getfield #<span class="hljs-number">3</span> &lt;io/better/jdk/_synchronized/_02_Lock_Clean.lock&gt;<br> <span class="hljs-number">5</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/Integer.intValue&gt;<br> <span class="hljs-number">8</span> iload_1<br> <span class="hljs-number">9</span> iadd<br><span class="hljs-number">10</span> invokestatic #<span class="hljs-number">2</span> &lt;java/lang/Integer.valueOf&gt;<br><span class="hljs-number">13</span> putfield #<span class="hljs-number">3</span> &lt;io/better/jdk/_synchronized/_02_Lock_Clean.lock&gt;<br><span class="hljs-number">16</span> getstatic #<span class="hljs-number">8</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">19</span> aload_0<br><span class="hljs-number">20</span> getfield #<span class="hljs-number">3</span> &lt;io/better/jdk/_synchronized/_02_Lock_Clean.lock&gt;<br><span class="hljs-number">23</span> invokevirtual #<span class="hljs-number">9</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">26</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p><strong>锁消除的依据是逃逸分析的数据支持</strong></p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>在使用 Synchronized 时我们一般会加在临界区很小的地方，缩短锁的占用时间，等待锁的线程尽可能快的获取锁。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。</p><p>锁粗化：就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h4 id="为什么会有偏向锁？"><a href="#为什么会有偏向锁？" class="headerlink" title="为什么会有偏向锁？"></a><strong>为什么会有偏向锁？</strong></h4><p>因为在大多数程序中，锁不仅不存在多线程竞争，而且总是被同一个线程多次获得，为了让线程获取锁的代价更低，加入了偏向锁。</p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><p>偏向锁是在单线程执行代码块时使用的机制，如果在多线程并发的环境下（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请），则一定会转化为轻量级锁或者重量级锁。</p><h4 id="获取流程"><a href="#获取流程" class="headerlink" title="获取流程"></a><strong>获取流程</strong></h4><p>当锁对象被线程持有时，Mark Word 存储了持有锁对象的线程的线程ID，所以偏向锁的获取就是：线程通过 CAS 操作不断的比对并修改锁对象的 Mark Word 中存储的线程 ID。</p><p>大致流程如下：</p><ul><li>步骤1：检查锁对象 Mark Word 偏向标识是否为 <code>1</code><ul><li><code>=1</code>：不可偏向：说明其他线程正在拥有锁，执行步骤 2</li><li><code>!=1</code>：可偏向：直接将当前线程 ID 存储到锁对象的 Mark Word中并将偏向标识设置为 1，执行步骤 5</li></ul></li><li>步骤2：判断存储的线程 ID 是否与当前线程 ID 匹配<ul><li>匹配，则执行步骤 5</li><li>不匹配，则执行步骤 3</li></ul></li><li>步骤 3：通过 Cas 操作将 Mark Word 中的线程 ID 替换成自己的线程 ID<ul><li>成功：执行步骤 5</li><li>失败：执行步骤 4</li></ul></li><li>步骤 4：竞争失败，说明有多线程竞争，当到达全局安全点，将获取锁的线程挂起，偏向锁升级为轻量级锁，阻塞的线程在安全点继续竞争</li><li>步骤 5：执行同步代码块</li></ul><h4 id="释放流程：偏向锁撤销"><a href="#释放流程：偏向锁撤销" class="headerlink" title="释放流程：偏向锁撤销"></a><strong>释放流程：偏向锁撤销</strong></h4><p>偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。</p><p>但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。</p><p>流程如下：</p><ul><li>步骤 1：暂停拥有锁对象的线程，并判断锁对象是否处理锁定状态<ul><li>否：恢复到无锁状态，偏向标识位设置为<code>0</code>；</li><li>是：执行步骤 2</li></ul></li><li>步骤 2：挂起持有锁的线程，并在线程栈帧中创建 Lock Record 记录，并将其指针拷贝到锁对象的 Mark Word 的中，将锁标识位改为 <code>00</code>，升级为<code>轻量级锁</code>。</li></ul><h4 id="偏向锁关闭"><a href="#偏向锁关闭" class="headerlink" title="偏向锁关闭"></a><strong>偏向锁关闭</strong></h4><p>在 Jdk1.6 和 1.7后默认开启，想要关闭偏向锁可使用<code>-XX:-UseBiasedLocking=false</code>指令。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="为什么会有轻量级锁？"><a href="#为什么会有轻量级锁？" class="headerlink" title="为什么会有轻量级锁？"></a><strong>为什么会有轻量级锁？</strong></h4><p>当偏向锁存在多线程竞争时会升级为轻量级锁，偏向锁是为了某些单线程执行同步代码块的场景下使用，而轻量级锁会通过自旋的方式获取锁，不会阻塞。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><strong>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，必然就会导致轻量级锁膨胀为重量级锁。</strong></p><h4 id="获取流程-1"><a href="#获取流程-1" class="headerlink" title="获取流程"></a><strong>获取流程</strong></h4><p>大致流程如下：</p><ul><li>步骤 1：判断锁对象的状态<ul><li>无锁状态执行步骤 2</li><li>偏向锁状态：则挂起持有锁对象的线程，执行步骤 2（对应偏向锁升级轻量级锁的过程）</li></ul></li><li>步骤 2：在当前线程的栈帧中创建 Lock Record（锁记录）空间，用于存储锁对象的 Mark Word</li><li>步骤 3：拷贝锁对象的 Mark Word 到当前线程的 Lock Record 中</li><li>步骤 4：通过 CAS 操作替换锁对象的 Mark Word 中存储的 Lock Record ，并把 MarkWord 的指针设置到 LockRecord 的 <code>owner</code> 字段中。<ul><li>成功：更新锁标识位为 <code>00</code>，标识当前锁状态为轻量级锁</li><li>失败：执行步骤 5</li></ul></li><li>步骤 5：当 CAS 更新失败后，Jvm 查看锁对象的 MarkWord 中的 Lock Record 是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，可直接进入同步块执行。否则说明多个线程竞争，进入自旋，若自旋结束依旧未获取到锁，轻量级锁就要膨胀为重量级锁，锁标志位变为 10，锁对象的 MarkWord 中存储指向重量级锁的指针，当前线程以及后面等待的线程进入阻塞状态。</li></ul><p>步骤 2：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200822151013.png" alt="image-20200821193905959"></p><p>步骤 4：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200822151017.png" alt="image-20200821193950404"  /><h4 id="释放流程"><a href="#释放流程" class="headerlink" title="释放流程"></a><strong>释放流程</strong></h4><p>当持有锁对象的线程执行完同步代码块时将通过 CAS 操作将锁对象的 Mark Work 中存储的 Lock Record 指针置为 NULL。如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。 </p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>对于轻量级锁，其性能提升的依据是 “对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p><h4 id="轻量级锁膨胀为重量级锁流程"><a href="#轻量级锁膨胀为重量级锁流程" class="headerlink" title="轻量级锁膨胀为重量级锁流程"></a>轻量级锁膨胀为重量级锁流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/2062729-b952465daf77e896.png"></p><p><strong>为什么轻量级锁会在 MarkWord 中保存 LockReacord 记录？</strong></p><p>一方面可以用于 CAS 比较，其次在升级为重量级锁时，持有锁的线程和等待的线程都会被阻塞，便于唤醒线程。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>关于不同锁的使用及其有点场景如下：</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不用消耗时间</td><td>锁存在竞争会带来额外的锁撤销消耗</td><td>单线程访问同步代码块</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会长时间阻塞</td><td>自旋浪费 CPU</td><td>追求响应时间，代码块执行快</td></tr><tr><td>重量级锁</td><td>不会自旋消耗 CPU</td><td>线程阻塞响应时间慢</td><td>代码块执行时间长</td></tr></tbody></table><p><strong>推荐文章</strong></p><p><a href="https://www.cnblogs.com/aspirant/p/11470858.html">深入分析Synchronized原理(阿里面试题)</a></p>]]></content>
    
    
    <categories>
      
      <category>Synchronized</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
      <tag>Synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadPoolExecutor 解析</title>
    <link href="/2022/11/18/thread/thread-pool-resolve/"/>
    <url>/2022/11/18/thread/thread-pool-resolve/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本章主要讲述线程池</p><ol><li>线程池的核心配置参数</li><li>线程池任务提交执行流程</li><li>线程池中线程新增流程</li><li>线程池中线程回收流程</li><li>线程池核心参数动态调整</li><li>线程池队列动态调整</li></ol></blockquote><span id="more"></span><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><h3 id="继承图"><a href="#继承图" class="headerlink" title="继承图"></a>继承图</h3><p>我们先来看看线程池的类继承图</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210304173122499.png" alt="image-20210304173122499"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Executor作为线程池的顶级接口, 定义了<code>task</code>的提交方法, 并将<code>task</code>的<code>提交</code>和<code>执行</code>进行了<code>解耦</code>.</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>Executor 接口中只有一个 <code>execute</code> 方法, 用于提交任务.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Executor</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><code>Executor</code>提供了向线程池中提交任务的方式,但是却没有提供管理线程池的相关方法. </p><p><code>ExecutorService</code> 定义了基于<code>execute</code>的<code>submit</code>方法, 该方法会返回一个<code>Future</code>对象, 此对象可用于停止<code>task</code>的执行或等待<code>task</code>执行成功.</p><p>同时还定义了<code>shutdown</code>方法和<code>shutdownNow</code>方法来关闭线程池</p><h4 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span> &#123;<br><br>  <span class="hljs-comment">// 关闭线程池, 如果线程池中有task, 则会执行这些task, 该方法不会等待先前提交的task执行完成, </span><br>  <span class="hljs-comment">// 线程池将不再接受新task</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 尝试停止所有的task, 停止等待中的task, 并返回正在等待执行的task</span><br>  <span class="hljs-comment">// 此方法不等待主动执行的任务终止, 除了尽最大努力尝试停止处理正在执行的任务之外，没有任何保证.</span><br>  <span class="hljs-comment">// 典型的实现将通过Thread.interrupt取消，因此任何无法响应中断的任务都可能永远不会终止.</span><br>  List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 返回当前线程池是否关闭</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 返回此线程池所有的task是否全部停止</span><br>  <span class="hljs-comment">// 请注意，除非先调用shutdown或shutdownNow, 否则isTerminated永远不会为true.</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 阻塞，直到关闭请求后所有任务完成执行，或者发生超时，或者当前线程被中断（以先发生者为准）.</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br>  <span class="hljs-comment">// 提交一个task, 返回Future, Future.get方法可获取task的执行结果</span><br>  &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br><br>  <span class="hljs-comment">// 同上</span><br>  &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span>;<br><br>  <span class="hljs-comment">// 同上</span><br>  Future&lt;?&gt; submit(Runnable task);<br><br>  <span class="hljs-comment">// 执行集合中所有的task</span><br>  &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><br>  <span class="hljs-comment">// 超时执行集合中所有的task</span><br>  &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout,  </span><br><span class="hljs-params">                                TimeUnit unit)</span><br><br><span class="hljs-comment">// 执行集合中任意一个的task, 就返回</span><br>  &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span>;<br><br>  <span class="hljs-comment">// 超时执行集合中任意一个的task, 就返回</span><br>  &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中的<code>shutdown</code>和<code>shutdownNow</code>都不保证已执行<code>task</code>的完成, 如果想要做到已执行的<code>task</code>完成后关闭线程池, 则可以使用<code>awaitTermination</code>方法.</p><h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>该类是ExecutorService的基础实现,  对现<code>submit </code>，<code> invokeAny</code>和<code>invokeAll</code>等方法进行的简单的实现.</p><p>对Future进行了再次封装, 使用RunnableFuture来间接的替换了Future.</p><h3 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h3><p>此方法用于向线程池中提交一个任务并返回一个 Future，并通过 Future 来一步通知 task 的完成情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>  <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <span class="hljs-comment">// 包装 Runnable</span><br>  RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>  execute(ftask);<br>  <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>  <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <span class="hljs-comment">// 包装Callable</span><br>  RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>  execute(ftask);<br>  <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看出重载的 submit 都对参数进行了包装且类型为RunnableFuture，最终都调用了 execute 方法。</p><p>查看 newTaskFor 方法看看实际返回的 RunnableFuture 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>FutureTask是一个可操作的异步 Future 实现，提供了 Future 的基础实现，包含了启动，取消，查看，获取等操作。</p><h4 id="特性-x2F-作用"><a href="#特性-x2F-作用" class="headerlink" title="特性&#x2F;作用"></a><strong>特性&#x2F;作用</strong></h4><ul><li>只有在 Future 完成时获取结果才不会阻塞，如果 Future 为完成则会阻塞调用线程，直到Future 完成。</li><li>Future 一旦完成不可再次启动或取消</li></ul><p>此类主要用于包装 Runnable 和 Callable。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a><strong>状态</strong></h4><p>该类使用了一个 volatile 修饰的int 类型 state 变量来表示 Future 的状态。初始化状态为 <code>NEW</code>。</p><p>运行状态仅在<code>set、setException、cancel</code>方法中转换为终止状态。</p><p>可能的状态变化：</p><p><code>NEW -&gt; COMPLETING -&gt; NORMAL NEW -&gt; COMPLETING -&gt; EXCEPTIONAL NEW -&gt; CANCELLED NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><h4 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a><strong>核心属性</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 要执行的task</span><br><span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br><span class="hljs-comment">// 执行结果两种情况：</span><br><span class="hljs-comment">// task 执行出现异常，则outcome存储的是异常</span><br><span class="hljs-comment">// task 执行未出异常，则outcome存储的是结果</span><br><span class="hljs-keyword">private</span> Object outcome;<br><span class="hljs-comment">// 执行 task 的线程</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br><span class="hljs-comment">/** Treiber stack of waiting threads */</span><br><span class="hljs-comment">// </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br></code></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>  <span class="hljs-comment">// 封装成 Callable</span><br>  <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>  <span class="hljs-built_in">this</span>.state = NEW;       <span class="hljs-comment">// 设置初始化状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当一个 FutureTask 执行时会执行其 run 方法</p><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 状态为 NEW 的情况下设置执行当前 task 的线程（runner 成员变量赋值）</span><br>  <span class="hljs-keyword">if</span> (state != NEW ||<br>      !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<span class="hljs-literal">null</span>, Thread.currentThread()))<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    Callable&lt;V&gt; c = callable;<br>    <span class="hljs-comment">// task不为空且状态为 NEW</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>      V result;<br>      <span class="hljs-type">boolean</span> ran;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行 task</span><br>        result = c.call();<br>        ran = <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        result = <span class="hljs-literal">null</span>;<br>        ran = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 出现异常，设置异常结果</span><br>        setException(ex);<br>      &#125;<br>      <span class="hljs-comment">// 结束，设置结果</span><br>      <span class="hljs-keyword">if</span> (ran)<br>        set(result);<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    runner = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>      handlePossibleCancellationInterrupt(s);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;<br>  <span class="hljs-comment">// 更新 FutureTask 状态成功</span><br>  <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>    <span class="hljs-comment">// 设置结果</span><br>    outcome = v; <br>    UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL); <span class="hljs-comment">// final state</span><br>    <span class="hljs-comment">// 唤醒所有等待的线程，并使 FutureTask 包装的 Callable 或 Runable 无效</span><br>    finishCompletion();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// assert state &gt; COMPLETING;</span><br>  <span class="hljs-comment">// 遍历等待的线程</span><br>  <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;<br>    <span class="hljs-comment">// 将 waiters 设置为空</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;<br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 获取等待的线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>          q.thread = <span class="hljs-literal">null</span>;<br>          <span class="hljs-comment">// 不为空则解锁</span><br>          LockSupport.unpark(t);<br>        &#125;<br>        <span class="hljs-comment">// 获取下一个节点，为空则结束</span><br>        <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">break</span>;<br>        q.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// unlink to help gc</span><br>        q = next;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// 钩子函数，该方法在 invokeAny 中封装的QueueingFuture中有重写使用</span><br>  done();<br><br>  callable = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br> <span class="hljs-comment">// 根据参数更新state状态</span><br>  <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;<br>        UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,<br>                                 mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <br>  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// in case call to interrupt throws exception</span><br>    <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取到线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>          <span class="hljs-comment">// 设置中断信号</span><br>          t.interrupt();<br>      &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// final state</span><br>        <span class="hljs-comment">// 设置为中断状态</span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 唤醒等待的线程，并使 FutureTask 包装的 Callable 或 Runable 无效</span><br>    finishCompletion();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据入参判断因该中的 FutureTask 还是取消 FutureTask，中断则调用 Thread.interrupt(); 并更新 state 状态，最终唤醒等待的线程。</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>  <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>    <span class="hljs-comment">// 等待 FutureTask 完成</span><br>    s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>  <span class="hljs-comment">// 根据 state 的值作出响应的处理</span><br>  <span class="hljs-keyword">return</span> report(s);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>  <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-comment">// 计算超时时间</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>  <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 自旋</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 线程是否设置过中断标识位</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>      removeWaiter(q);  <span class="hljs-comment">// 移除等待的线程节点</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    &#125;<br><span class="hljs-comment">// 获取状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-comment">// 已经完成或取消</span><br>    <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;<br>      <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)<br>        q.thread = <span class="hljs-literal">null</span>;<br>      <span class="hljs-comment">// 返回状态</span><br>      <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-comment">// 正在执行，则让出CPU时间片</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING) <br>      Thread.yield();<br>    <span class="hljs-comment">// 初始化等待的线程节点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)<br>      q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br><span class="hljs-comment">// 将 WaitNode 入队</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>      queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,                                         <br>                                           q.next = waiters, q);<br>    <span class="hljs-comment">// 超时的话重新计算超时时间</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>      nanos = deadline - System.nanoTime();<br>      <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>        removeWaiter(q);<br>        <span class="hljs-keyword">return</span> state;<br>      &#125;<br>      LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>    &#125;<br>    <span class="hljs-comment">// 阻塞当前线程</span><br>    <span class="hljs-keyword">else</span><br>      LockSupport.park(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; T <span class="hljs-title function_">doInvokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                          <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>  <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>  <span class="hljs-keyword">if</span> (tasks == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <span class="hljs-comment">// task 数量</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">ntasks</span> <span class="hljs-operator">=</span> tasks.size();<br>  <span class="hljs-keyword">if</span> (ntasks == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>  ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(ntasks);<br>  <span class="hljs-comment">// 该类包装了 ThreadPoolExecutor，提供了 poll，take 等方法</span><br>  ExecutorCompletionService&lt;T&gt; ecs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorCompletionService</span>&lt;T&gt;(<span class="hljs-built_in">this</span>);<br>  <br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">ExecutionException</span> <span class="hljs-variable">ee</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 计算超时时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>    <br>    Iterator&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; it = tasks.iterator();<br>    <span class="hljs-comment">// 先向线程池中提交一个 task</span><br>    futures.add(ecs.submit(it.next()));<br>    --ntasks;   <span class="hljs-comment">// 计数自减</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">active</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// f 会被包装成QueueingFuture对象，其完成时才会被添加到队列中</span><br>      Future&lt;T&gt; f = ecs.poll();<br>      <span class="hljs-comment">// 为空，说明还未执行</span><br>      <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ntasks &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 还有 task</span><br>          --ntasks;<br>          <span class="hljs-comment">// 继续向线程池中提交</span><br>          futures.add(ecs.submit(it.next()));<br>          ++active;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (active == <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 超时，重新计算时间</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;  <br>          f = ecs.poll(nanos, TimeUnit.NANOSECONDS);<br>          <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>          nanos = deadline - System.nanoTime();<br>        &#125;<br>        <span class="hljs-comment">// 就一个 task</span><br>        <span class="hljs-keyword">else</span><br>          f = ecs.take(); <span class="hljs-comment">// 阻塞等待 task 的完成</span><br>      &#125;<br>      <span class="hljs-comment">// 不为空，说明在执行中</span><br>      <span class="hljs-keyword">if</span> (f != <span class="hljs-literal">null</span>) &#123;<br>        --active;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 获取 task 结果</span><br>          <span class="hljs-keyword">return</span> f.get();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException eex) &#123;<br>          ee = eex;<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException rex) &#123;<br>          ee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>(rex);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ee == <span class="hljs-literal">null</span>)<br>      ee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>();<br>    <span class="hljs-keyword">throw</span> ee;<br><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = futures.size(); i &lt; size; i++)<br>      <span class="hljs-comment">// 对每个 task 进行取消</span><br>      futures.get(i).cancel(<span class="hljs-literal">true</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>  <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>  ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 遍历 task</span><br>    <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;<br>      <span class="hljs-comment">// 包装成 RunnableFuture</span><br>      RunnableFuture&lt;T&gt; f = newTaskFor(t);<br>      futures.add(f);<br>      <span class="hljs-comment">// 提交 task 并执行</span><br>      execute(f);<br>    &#125;<br>    <span class="hljs-comment">// 遍历提交的 Future</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = futures.size(); i &lt; size; i++) &#123;<br>      Future&lt;T&gt; f = futures.get(i);<br>      <span class="hljs-comment">// 判断是否完成</span><br>      <span class="hljs-keyword">if</span> (!f.isDone()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 获取结果</span><br>          f.get();<br>        &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;<br>        &#125;<br>      &#125;<br>    &#125;<br>    done = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> futures; <span class="hljs-comment">// 返回</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (!done)  <span class="hljs-comment">// 未完成</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = futures.size(); i &lt; size; i++)<br>        <span class="hljs-comment">// 取消 FutureTask</span><br>        futures.get(i).cancel(<span class="hljs-literal">true</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>此类为线程池的最终实现, 主要实现了 execute 方法,不论是 ExecutorService中的submit 方法 它们最终调用的都是 <code>execute</code> 方法.</p><h3 id="核心参数配置"><a href="#核心参数配置" class="headerlink" title="核心参数配置"></a>核心参数配置</h3><p>创建一个线程池必须要用其构造函数, 下面来看看 ThreadPoolExecutor 的构造函数</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210304183341075.png" alt="image-20210304183341075"></p><p>上面的三个构造函数最终都会调用到最后一个构造函数即参数最多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,<span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>  <span class="hljs-comment">// 忽略代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到ThreadPoolExecutor的构造函数一共有四个, 但每个函数至少会有四个参数,分别是:</p><ul><li><code>corePoolSize:</code> 此参数表示当前线程池有多少<code>核心线程</code></li><li><code>maximumPoolSize:</code> 此参数表示当前线程池<code>最大</code>能创建多少<code>线程</code></li><li><code>keepAliveTime: </code> 此参数表示<code>超过核心线程数量的线程存活的时间</code></li><li><code>unit:</code> 时间单位,需要结合 <code>keepAliveTime</code> 使用</li><li><code>workQueue:</code> 此参数用于存放想线程池提交的任务</li></ul><p>而 <code>ThreadFactory</code> 和 <code>RejectedExecutionHandler</code> 分别用于创建线程和拒绝任务(<code>当队列满,且线程池中存活线程达到最大线程池</code>)</p><p>在 ThreadPoolExecutor 中默认提供了四种拒绝策略, 都已内部类的形式.</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210304184245365.png" alt="image-20210304184245365"></p><h4 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h4><p>线程的创建就是交给 ThreadFactory 参数实例来完成的, 线程池 默认使用<code>Executors.defaultThreadFactory</code>, 该工厂创建的线程拥有同一个ThreadGroup,且拥有相同的优先级和非守护进程状态. 也可以通过自定义线程池来定义线程名称和修改优先级和守护线程状态.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><span class="hljs-comment">// 创建一个新线程 ,具有相同的ThreadGroup和优先级</span><br>  Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要实现创建不同优先级或守护线程状态, 可自定义 ThreadFactory.</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>线程池使用了队列来存储调用线程提交的<code>task</code>. </p><p>队列的使用和线程池的大小有关系:</p><ul><li>如果线程池中运行的线程小于corePoolSize, 会直接创建线程执行task</li><li>如果线程池中运行的线程大于corePoolSize,<ul><li>队列未满直接入队,并创建一个 Worker 执行 task (此 Worker 不一定马上执行此 task)</li><li>队列已满时, 则会创建线程执行, 如果创建后的线程数大于<code>maximumPoolSize</code>, 则会执行拒绝策略.</li></ul></li></ul><p>而排队的策略有以下三种:</p><ol><li>同步队列, 比较好的队列是<code>SynchronousQueue</code></li><li>无限队列<ol><li>当线程池中执行线程达到corePoolSize时, 新提交的task将会直接排队.</li><li>maximumPoolSize属性的设置将没有意义</li></ol></li><li>有界队列<ol><li>当maximumPoolSizes有限时, 可使用有界队列, 防止资源耗尽</li></ol></li></ol><p>队列的具体实现由:</p><ol><li><code>ArrayBlockingQueue</code> : 有界的数组队列, 初始化时指定大小</li><li><code>LinkedBlockingQueue</code> : 有界的链表队列, 默认值为 Integer.MAX</li><li><code>DelayQueue</code> : 延迟队列, 只要延迟时间到期才能获取</li><li><code>SynchronousQueue</code> : 同步队列, 获取和放入是同步完成的</li><li><code>PriorityBlockingQueue</code> : 优先级队列, 可通过compareTo 来排序, 同级别的不能保证</li></ol><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>拒绝策略在<code>队列已满时</code>且<code>线程达到maximumPoolSize</code>时将会执行, 当达到前面两种情况时线程池会通过<code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code>来拒绝task的提交.</p><p><code>RejectedExecutionHandler </code>提供了四种拒绝策略实现:</p><ol><li>AbortPolicy 实现: 拒绝策略在拒绝时会抛出<code>RejectedExecutionException</code></li><li>CallerRunsPolicy 实现: 使用调用execute方法的调用线程(<code>自身而非线程池中的线程</code>)来执行task.</li><li>DiscardPolicy 实现: 删除队列中无法执行的task</li><li>DiscardOldestPolicy 实现: 丢弃队列的<code>头</code>任务, 然后重试执行(该操作可能再次失败)</li></ol><p>也可以通过实现RejectedExecutionHandler接口来实现自定义拒绝策略.</p><h2 id="线程池启动"><a href="#线程池启动" class="headerlink" title="线程池启动"></a>线程池启动</h2><p>线程池开启执行的动作由 execute 方法触发，查看 execute 方法了解线程池任务的执行流程和细节。</p><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>  <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <span class="hljs-comment">// 获取线程池的状态字段</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>  <span class="hljs-comment">// step1: 如果工作线程数小于核心线程数, 则可以直接创建一个 Worker</span><br>  <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>    <span class="hljs-comment">// 尝试添加一个工作线程并执行task</span><br>    <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>      <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 失败重新获取ctl</span><br>    c = ctl.get();<br>  &#125;<br><span class="hljs-comment">// 可能出现的情况:</span><br>  <span class="hljs-comment">// 1. 线程池未在运行状态(忽略)</span><br>  <span class="hljs-comment">// 2. task入队失败(队列已满)</span><br>  <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">// 再次检查线程池状态, 如果未运行, 则从队列中删除此 task, 并执行拒绝策略</span><br>    <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>      reject(command);<br>    <span class="hljs-comment">// 线程池运行且工作线程数量为 0, 则添加一个空任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)  <br>      addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>  &#125;<br><span class="hljs-comment">// 执行此 else if 的情况</span><br>  <span class="hljs-comment">// 1. 队列已满, 会导致上面的入队失败</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>    reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a><strong>执行流程</strong></h4><ul><li>步骤1: 获取线程数并判断线程池中的线程是否小于核心线程数<ul><li>小于则添加一个Worker(addWorker方法)</li><li>大于则执行步骤2</li></ul></li><li>步骤2: 判断线程池是否运行, 且task是否能插入队列成功?<ul><li>成功: 双重检查线程池状态<ul><li>未运行: 则将刚刚入队的 task 移除,并执行拒绝策略</li><li>运行中: 如果线程池工作线程为 0, 则添加一个 Worker(一个 Worker 就是一个线程)</li></ul></li><li>失败: 执行步骤3</li></ul></li><li>步骤3: 再次尝试添加Worker, 如果失败则执行拒绝策略</li></ul><p>注意上面的代码多次调用了<code>addWorker</code>方法, 顾名思义该方法添加了一个工作者去执行用户提交的task. </p><p><strong>且addWorker方法的第二个参数在第一次调用和后面一次调用时值不一样</strong> </p><p><strong>该值在 addWorker 方法中用于区分比较的值(true: 比较的是核心线程, false: 比较的是最大线程)</strong></p><h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>  <span class="hljs-comment">// 开启死循环</span><br>  retry:<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c); <span class="hljs-comment">// 获取运行状态</span><br><br>    <span class="hljs-comment">// step1: 检查队列和线程池状态和firstTask参数</span><br>    <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>        ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span> &amp;&amp; ! workQueue.isEmpty()))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 死循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);  <span class="hljs-comment">// 获取线程池中的工作线程</span><br>      <span class="hljs-comment">// step2: 判断工作线程是否达到阈值</span><br>      <span class="hljs-comment">// 这里的 core 就解释了上面为什么了 workerCoun&gt;corePoolSize 传递的参数为 false</span><br>      <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-comment">// 工作线程自增 1, 失败说明其他线程也调用了此方法</span><br>      <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c)) &#123;<br>        <span class="hljs-keyword">break</span> retry;<br>      &#125;<br><br>      c = ctl.get();<br>      <span class="hljs-keyword">if</span> (runStateOf(c) != rs)  <span class="hljs-comment">// 线程池状态发生改变(调用了 shutdown 方法), 继续自旋</span><br>        <span class="hljs-keyword">continue</span> retry;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 执行到此,说明workerCount已经自增成功</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 实例化Worker</span><br>    w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread; <span class="hljs-comment">// 获取到Worker的thread, 此线程使用线程池的ThreadFactory创建</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 获取到锁(线程池级别)</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>      mainLock.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 忽略部分代码</span><br>        workers.add(w);        <span class="hljs-comment">// 将Worker添加到hash表中, 方便后期线程释放 回收处理</span><br>        <span class="hljs-comment">// 忽略部分代码</span><br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock(); <span class="hljs-comment">// 解锁</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>        t.start();      <span class="hljs-comment">// 添加成功启动Worker的线程</span><br>        workerStarted = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (! workerStarted)  <span class="hljs-comment">// worker启动失败, 执行</span><br>      addWorkerFailed(w);  <br>  &#125;<br>  <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h4><p>大致分为两个阶段: </p><ol><li>修改<code>workerCount</code>数量<ol><li>开启一个死循环, 获取到线程池运行状态, 判断状态和队列及入参是否合法,不合法直接返回</li><li>在开启一个死循环, 比较workerCount是否超过maximumPoolSize或corePoolSize, 超过直接返回.</li><li>对工作线程数进行自增+1 操作成功,结束第一阶段.<ol><li>自增失败的情况: 1. 其他线程修改了workerCount 2. 线程池状态发生改变</li><li>如果其他线程修改了 workerCount,则继续执行内层循环, 直到修改 workerCount成功</li><li>如果是线程池状态改变, 则继续外层循环</li></ol></li></ol></li><li>创建 Worker<ol><li>创建一个 Worker 实例, 并获取到其线程, 如果Worker 中的线程为空, 说明 ThreadFactory 创建线程失败</li><li>获取到线程池的锁, 将 Worker 实例放入到 workers 集合中, 方便后续线程销毁</li><li>启动 Worker 中的线程, 如果启动失败, 执行步骤 4</li><li>执行<code>addWorkerFailed</code>方法</li></ol></li></ol><h4 id="添加失败"><a href="#添加失败" class="headerlink" title="添加失败"></a>添加失败</h4><p>当 Worker 创建完成后, 如果其线程启动失败则会执行<code>addWorkerFailed</code>方法来对线程池做一个回滚操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>      workers.remove(w);   <span class="hljs-comment">// 从队列中删除 task</span><br>    decrementWorkerCount(); <span class="hljs-comment">// 自减 workCount</span><br>    tryTerminate();    <span class="hljs-comment">// 尝试终止线程池</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只需要记住<code>tryTerminate</code>用于终止线程池，后面线程池关闭会讲解。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>Worker 主要维护线程运行任务的中断控制状态，以及其他次要记录。同时扩展了AbstractQueuedSynchronizer来简化获取和释放围绕每个任务执行的锁。</p><p>这可以防止旨在唤醒工作线程等待任务的中断，而不是中断正在运行的任务。</p><p>我们实现了一个简单的<code>非可重入互斥锁</code>，而不是使用ReentrantLock，因为我们不希望辅助任务在调用诸如setCorePoolSize之类的池控制方法时能够重新获取该锁。<br>另外，为了抑制直到线程真正开始运行任务之前的中断，我们将锁定状态初始化为负值，并在启动时将其清除（在runWorker中）。</p><h3 id="核心字段"><a href="#核心字段" class="headerlink" title="核心字段"></a>核心字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Worker运行的线程 */</span><br><span class="hljs-keyword">final</span> Thread thread;<br><span class="hljs-comment">/** 初始化Worker时要执行的task */</span><br>Runnable firstTask;<br></code></pre></td></tr></table></figure><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Worker(Runnable firstTask) &#123;<br>  setState(-<span class="hljs-number">1</span>); <br>  <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>  <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 调用 ThreadFactory 创建线程</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Worker执行"><a href="#Worker执行" class="headerlink" title="Worker执行"></a>Worker执行</h3><p>由于 Worker 实现了 Runnable 接口，并在 addWorker 中调用了 Worker 中 Thread.start 方法，最后知道 runWorker。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>  <span class="hljs-comment">// step1: 获取Worker的thread和task, 并解锁</span><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>  w.firstTask = <span class="hljs-literal">null</span>;<br>  w.unlock(); <span class="hljs-comment">// 疑问: 为什么要解锁?</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// step2: 循环获取任务</span><br>    <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 此处加锁表示当前 Worker 正在运行。与后续 shutdown 中呼应。</span><br>      w.lock(); <br>      <span class="hljs-comment">// （线程未停止或清除线程标识位）且 线程设置过标识位</span><br>      <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp;<br>runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())&#123;<br>         wt.interrupt();  <span class="hljs-comment">// 设置中断标识位</span><br>      &#125;<br><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 钩子函数</span><br>        beforeExecute(wt, task);<br>        <br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 执行 task，此时可能出现异常</span><br>          task.run();  <br>        <span class="hljs-comment">// 忽略异常的处理</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          afterExecute(task, thrown);  <span class="hljs-comment">// step4: 执行后操作</span><br>        &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        task = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 将task的引用置为空, 方便回收</span><br>        w.completedTasks++;<br>        w.unlock();<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 上面的代码未出现异常会执行此行代码，出现异常是不会执行此行代码</span><br>    <span class="hljs-comment">// 此标识位关系到下面processWorkerExit方法的执行逻辑</span><br>    completedAbruptly = <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// setp5: task.run 前置和后置处理出现 或 getTask 出现异常</span><br>    processWorkerExit(w, completedAbruptly);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="执行流程-2"><a href="#执行流程-2" class="headerlink" title="执行流程"></a>执行流程</h4><ol><li>获取 Worker 的线程, 并解锁(Worker 构造时已经加锁了), 初始 task 为空则调用 <code>getTask</code> 获取任务</li><li>task 执行前先加锁, 避免线程池状态更改时(<code>SHUTDOWN</code>), task 执行了</li><li>调用 <code>beforeExecute</code> 前置方法</li><li>执行 task, 是否出现异常, 出现异常执行最后一步</li><li>执行完成调用<code>afterExecute</code>后置方法, 并对数据进行自增</li><li>出现异常,则调用<code>processWorkerExit</code>方法回收当前 Worker</li></ol><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210323155115259.png" alt="image-20210323155115259"></p><h3 id="获取任务"><a href="#获取任务" class="headerlink" title="获取任务"></a>获取任务</h3><p>在 Worker 的启动代码中知道了 Worker 是如何执行 task 的, 缺不太了解是如何获取 Task 的, 而获取 Task 则是调用 getTask 方法实现的.</p><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p>该方法根据当前线程池的配置来设置阻塞或定时获取任务, 但出现以下一些情况则会返回 null:</p><ol><li>当 workerCount &gt; maximumPoolSize , 即超过了最大线程数, 不能再创建 Worker 了</li><li>线程池状态为 <code>STOP</code></li><li>线程池状态为 <code>SHUTDOWN</code> 或<code>队列为空</code></li><li>Worker 等待 task 的时间超过了 <code>keepAliveTime</code>(workerCount &gt; corePoolSize 的情况)</li></ol><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>  <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 自旋等待task</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>    <span class="hljs-comment">// 线程池处于 SHUTDOWN 且 (线程池处于 STOP 或队列为空)</span><br>    <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; <br>      decrementWorkerCount();  <span class="hljs-comment">// 自减 workerCount, 并返回 null</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);  <span class="hljs-comment">// 获取 workerConut</span><br><br><span class="hljs-comment">// allowCoreThreadTimeOut: 表示是否开启核心线程过期销毁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>    <span class="hljs-comment">// 如果超过了最大线程数 或 已超时</span><br>    <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>        &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123; <span class="hljs-comment">// 队列为空</span><br>      <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="hljs-comment">// 自减 workerCount</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 根据当前 workerCount 来判断是否应该超时从队列中获取 task</span><br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS):workQueue.take();<br>      <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> r;<br>      timedOut = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 超时, 继续下一次自旋(最终会退出)</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>      timedOut = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="执行流程-3"><a href="#执行流程-3" class="headerlink" title="执行流程"></a>执行流程</h4><ol><li>开启自旋, 判断线程池状态, 如果处于 SHUTDOWN 或 STOP 或 队列为空 则直接返回 null</li><li>获取到 workerCount, 判断是否开启核心线程超时(<code>allowCoreThreadTimeOut</code>)<ol><li>未开启则比较 workerCount &gt; coolPoolSize 是否成立</li><li>开启则从队列获取 task 时为超时获取</li></ol></li><li>判断 workerCount &gt; maximumPoolSize 和 队列为空 和 超时过(<code>timedOut</code>) 等条件是否成立<ol><li>成立则修改 workerCount , 成功返回 null , 失败(其他 Worker 可能也在修改 workerCount)则继续自旋</li></ol></li><li>根据步骤2 的结果判断中队列中获取是<code>超时</code>获取还是<code>阻塞</code>获取, 如果是超时获取且结果为空, 则会进入下一次自旋再次执行步骤 1,2,3中的判断逻辑.</li></ol><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210305141210441.png" alt="image-20210305141210441"></p><h3 id="Worker退出"><a href="#Worker退出" class="headerlink" title="Worker退出"></a>Worker退出</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><p>该方法用于处理 Worker 的退出逻辑，completedAbruptly的取值有以下两种情况：</p><ul><li><code>completedAbruptly=true</code>：默认值。</li><li><code>completedAbruptly=false</code>：runWorker 中循环结果时会执行<code>completedAbruptly = false</code>。</li></ul><p>该方法会执行的条件有一下：</p><ol><li>当<code>beforeExecute、afterExecute、task.run()</code>三个方法出现异常。</li><li><code>getTask</code> 返回 <code>null</code>。</li></ol><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>  <span class="hljs-comment">// completedAbruptly: 标识当前 Worker 是否是因为 task 执行异常而需要销毁的</span><br>  <span class="hljs-keyword">if</span> (completedAbruptly)<br>    decrementWorkerCount();<br><br>  <span class="hljs-comment">// step1: 统计所有 worker 完成的 task 数量</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock(); <br>  <span class="hljs-keyword">try</span> &#123;<br>    completedTaskCount += w.completedTasks;  <span class="hljs-comment">// 统计完成的 task 数量</span><br>    workers.remove(w); <span class="hljs-comment">// 删除此 Worker 的引用</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br><br>  <span class="hljs-comment">// step2: 尝试终止此 Worker</span><br>  tryTerminate();   <br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>  <span class="hljs-comment">// step3: 线程池处于 SHUTDOWN 或 RUNNING 状态</span><br>  <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;   <br>    <span class="hljs-comment">// step4: 判断是否是用户异常导致 Worker 退出</span><br>    <span class="hljs-comment">// true：标识用户 task 出现异常</span><br>    <span class="hljs-comment">// false：标识 getTask 返回 null，即超时获取或线程被中断（调用 shutdown 方法）</span><br>    <span class="hljs-keyword">if</span> (!completedAbruptly) &#123; <br>      <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>      <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())   <span class="hljs-comment">// 如果队列不为空，则需要线程来执行 task</span><br>        min = <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 如果不成立。则说明工作线程为 0，需要创建一个 Worker 执行任务</span><br>      <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// step5: 执行到这里的可能:</span><br>    <span class="hljs-comment">// 1. completedAbruptly=false</span><br>    <span class="hljs-comment">// 2. 上面的if (workerCountOf(c) &gt;= min) 判断不成立, 即 workerCount = 0</span><br>    addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);   <span class="hljs-comment">// 新建一个 Worker</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池停止"><a href="#线程池停止" class="headerlink" title="线程池停止"></a>线程池停止</h2><p>线程池关闭有两个方法可以进行操作: <code>shutdown</code> <code>shutdownNow</code></p><p>它两的区别是: </p><ul><li><p><code>shutdown</code> : 等待正在执行任务的 Worker 执行完成, 不接受新的 task 提交</p></li><li><p><code>shutdownNow</code> : 尝试停止所有正在执行的任务, 从队列中删除等待执行的 task 并返回</p><ul><li>此实现通过<code>Thread.interrupt</code>取消任务，因此任何无法响应中断的任务都可能永远不会终止。</li></ul></li></ul><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    checkShutdownAccess(); <span class="hljs-comment">// 忽略</span><br>    <span class="hljs-comment">// 变更线程池状态</span><br>    advanceRunState(SHUTDOWN);  <br>    <span class="hljs-comment">// 中断空闲 Worker</span><br>    interruptIdleWorkers();<br>    <span class="hljs-comment">// 钩子函数</span><br>    onShutdown(); <br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br>  <span class="hljs-comment">// 尝试终止线程池</span><br>  tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tryTerminate</code> 后面会做讲解，这里不再阐述。重点关注<code>interruptIdleWorkers</code>方法。</p><h5 id="interruptIdleWorkers"><a href="#interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers"></a>interruptIdleWorkers</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">()</span> &#123;<br>  interruptIdleWorkers(<span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">// 中断空闲 Worker</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//  遍历所有的 Worker</span><br>    <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>      <span class="hljs-comment">// 判断 Worker 是否设置过中断标识位</span><br>      <span class="hljs-comment">// tryLock=true: 表示此 Worker 未运行。tryLock=false: 表示此 Worker 正在运行。</span><br>      <span class="hljs-comment">// runWorker 方法中的 while 循环在执行时会获取锁。</span><br>      <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          t.interrupt(); <span class="hljs-comment">// 设置中断标识位</span><br>        &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          w.unlock();<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 如果只中断一个则直接返回</span><br>      <span class="hljs-keyword">if</span> (onlyOne)<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 tryLock 来判断当前 Worke 是否空闲，因为Worker 在运行时会先获取到锁才会执行。</p><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>  List&lt;Runnable&gt; tasks;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    checkShutdownAccess();  <span class="hljs-comment">// 忽略</span><br>    <span class="hljs-comment">// 设置状态</span><br>    advanceRunState(STOP);  <br>    <span class="hljs-comment">// 中断线程</span><br>    interruptWorkers();  <br>    <span class="hljs-comment">// 获取为执行完成的 Task</span><br>    tasks = drainQueue();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br>  <span class="hljs-comment">// 尝试终止线程池</span><br>  tryTerminate();<br>  <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点关注 drainQueue 和 interruptWorkers 两个方法。</p><h5 id="interruptWorkers"><a href="#interruptWorkers" class="headerlink" title="interruptWorkers"></a>interruptWorkers</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptWorkers</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (Worker w : workers)<br>      w.interruptIfStarted();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>  Thread t;<br>  <span class="hljs-comment">// 持有锁且（线程不为空且线程未设置过中断标识位）</span><br>  <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      t.interrupt();  <span class="hljs-comment">// 设置中断标识位</span><br>    &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="drainQueue"><a href="#drainQueue" class="headerlink" title="drainQueue"></a>drainQueue</h5><p>通常使用drainTo将任务队列排放到新集合中。 但是，如果队列是DelayQueue或其他类型的队列，但poll或drainTo可能无法删除某些元素，则将其逐个删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Runnable&gt; <span class="hljs-title function_">drainQueue</span><span class="hljs-params">()</span> &#123;<br>  BlockingQueue&lt;Runnable&gt; q = workQueue;<br>  ArrayList&lt;Runnable&gt; taskList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Runnable&gt;();<br>  q.drainTo(taskList);<br>  <span class="hljs-comment">// 队列可能为DelayQueue，drainTo方法可能不生效</span><br>  <span class="hljs-keyword">if</span> (!q.isEmpty()) &#123;<br>    <span class="hljs-keyword">for</span> (Runnable r : q.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>[<span class="hljs-number">0</span>])) &#123;<br>      <span class="hljs-keyword">if</span> (q.remove(r))<br>        taskList.add(r);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> taskList;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="treTerminate"><a href="#treTerminate" class="headerlink" title="treTerminate"></a>treTerminate</h4><p>在 shutdown 和 shutdownNow 两个方法中都调用了tryTerminate方法。</p><p>该方法作用是当线程处于(SHUTDOWN <code>或</code> 队列为空)<code>或</code> (STOP <code>或</code> 队列为空)时将线程池状态置为TERMINATED。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">// step1: 判断线程池状态。可能出现的情况如下:</span><br>    <span class="hljs-comment">// 1.线程池处于 RUNNING 状态，直接返回</span><br>    <span class="hljs-comment">// 2.线程池处于 SHUTDOWN 或 STOP 状态，避免重复</span><br>    <span class="hljs-comment">// 3.线程池处于 SHUTDOWN 且队列不为空，直接返回（消费队列中的任务）</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) ||<br>        runStateAtLeast(c, TIDYING) ||<br>        (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>      <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 如果工作线程不为 0，则中断一个空闲的工作线程</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 中断一个空闲的工作线程</span><br>      interruptIdleWorkers(ONLY_ONE);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 钩子函数</span><br>          terminated();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>          <span class="hljs-comment">// 唤醒所有等待持有 mainLock 锁的线程</span><br>          termination.signalAll();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      mainLock.unlock();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态参数配置"><a href="#动态参数配置" class="headerlink" title="动态参数配置"></a>动态参数配置</h3><p>虽然网上有线程池配置的公式, 但是公司不一定适合所有场景, 因此线程池提供了动态修改线程池的方法.</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210305152123194.png" alt="image-20210305152123194"></p><p>其中我们比较关心的是核心线程, 最大线程, 队列大小的设置</p><h4 id="核心线程设置"><a href="#核心线程设置" class="headerlink" title="核心线程设置"></a>核心线程设置</h4><h5 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h5><p>核心线程的配置可以通过 <code>setCorePoolSize()</code> 来设置.</p><p>此方法用于设置核心线程数。 这将覆盖在构造函数中设置的任何值。 如果新值小于当前值，则多余的现有线程将在下次空闲时终止。 如果更大，将在需要时启动新线程以执行任何排队的任务。</p><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCorePoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>  <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>  <span class="hljs-comment">// 计算核心线程差值, 利于后面判断</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> corePoolSize - <span class="hljs-built_in">this</span>.corePoolSize;<br>  <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;  <span class="hljs-comment">// 先赋值</span><br><br>  <span class="hljs-comment">// workerCount 超过 corePoolSize</span><br>  <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)<br>    interruptIdleWorkers(); <span class="hljs-comment">// 中断Worker, 调用 Worker 中 Thread.interrupt 方法实现</span><br>  <span class="hljs-comment">// workerCount 还未达到 corePoolSize</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delta &gt; <span class="hljs-number">0</span>) &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Math.min(delta, workQueue.size()); <br><span class="hljs-comment">// 如果新 corePoolSize 还未达到 和 workQueueSize 至少有一个task, 则创建一个 Worker</span><br>    <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span> &amp;&amp; addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>)) &#123;<br>      <span class="hljs-keyword">if</span> (workQueue.isEmpty())<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol><li>计算 <code>新corePoolSize</code> 和<code>旧corePoolSize</code> 的差值, 并修改线程池的 corePoolSize</li><li>判断 workerCount 是否大于新 corePoolSize 是否成立, 成立则中断多余的 Worker, 反之继续执行</li><li>判断是否需要新增 Worker(delta&gt;0), 成立则开启自旋创建, 当 delta&lt;&#x3D;0 或队列为空时结束</li></ol><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210305172152265.png" alt="image-20210305172152265"></p><h4 id="最大线程设置"><a href="#最大线程设置" class="headerlink" title="最大线程设置"></a>最大线程设置</h4><h5 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h5><p>设置允许的最大线程数。 这将覆盖在构造函数中设置的任何值。 如果新值小于当前值，则多余的现有线程将在下次空闲时终止。</p><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaximumPoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> maximumPoolSize)</span> &#123;<br>  <span class="hljs-keyword">if</span> (maximumPoolSize &lt;= <span class="hljs-number">0</span> || maximumPoolSize &lt; corePoolSize)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>  <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>  <span class="hljs-comment">// workerCount &gt; 新maximumPoolSize, 则中断多余的 Worker</span><br>  <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)<br>    interruptIdleWorkers();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列大小设置"><a href="#队列大小设置" class="headerlink" title="队列大小设置"></a>队列大小设置</h4><p>线程池没有提供修改队列大小的方法, 当时提供了获取队列的方法: <code> getQueue</code>, 该方法返回的类型为 <code>BlockingQueue</code></p><p>常用的是 <code>LinkedBlockingQueue</code> 但是其 capacity 是 final 类型的, 不支持修改,  可以自行拷贝一份源代码,将其 <code>capacity</code> 修改成非 final 的, 并提供 <code>get set</code> 方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此线程池的核心参数和以及动态调整, 实际场景中参数的配置可能是根据场景 QPS 进行变化的, 所以一般都会使用线程池监控, 来监控线程池的状态. </p><p>本文主要偏向于源码的分析, 和对线程池执行流程的分析, 需要将整个流程串起来. 才能更好的理解线程池.</p><p>一些看法和理解如有错误,请指出, 多多交流. </p><p>推荐文章:</p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团</a> </p><p><a href="https://www.cnblogs.com/thisiswhy/p/12690630.html">博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
      <tag>源码分析</tag>
      
      <tag>ThreadPool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture源码分析</title>
    <link href="/2022/11/18/juc/completable_future/"/>
    <url>/2022/11/18/juc/completable_future/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲解CompletableFuture的设计以及源码分析</p><span id="more"></span><h2 id="CompletableFuture源码分析"><a href="#CompletableFuture源码分析" class="headerlink" title="CompletableFuture源码分析"></a>CompletableFuture源码分析</h2><blockquote><p>本文主要讲解CompletableFuture的设计以及源码分析</p><ul><li>是如何唤醒的后续Future?</li></ul></blockquote><h3 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h3><p>一个<code>CompletionStage</code>代表了一个可异步计算的<code>阶段</code>. 在另一个<code>CompletionStage</code>完成时执行一个操作或者计算一个值.</p><p>一个<code>CompletionStage</code>的执行可以由另一个单独阶段完成后触发, 也可以由两个阶段都完成触发, 或者两个阶段中任意一个完成后触发. </p><h3 id="CompletableFuture整体设计"><a href="#CompletableFuture整体设计" class="headerlink" title="CompletableFuture整体设计"></a>CompletableFuture整体设计</h3><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220616171712.png" alt="image-20220616171712930"></p><p>简易版</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220616171528.png" alt="image-20220616171528593"></p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220614_completableFuture.png" alt="image-20220614164755597"></p><p>一个CompletableFuture实现了<code>Future</code>和<code>CompletionStage</code>两个接口.</p><p><code>所以每个CompletableFuture都是一个阶段</code></p><p>核心变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 运行结果</span><br><span class="hljs-keyword">volatile</span> Object result;<br><span class="hljs-comment">// 存储后续执行动作的栈</span><br><span class="hljs-keyword">volatile</span> Completion stack;<br></code></pre></td></tr></table></figure><h4 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h4><p>一个Completion是一个特殊的FutureTask, 可以由线程池提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Completion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt; <br>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>, AsynchronousCompletionTask &#123;<br>  <br>  <span class="hljs-comment">// 下一个Completion, 即Completion可以组成栈</span><br>  <span class="hljs-keyword">volatile</span> Completion next;      <br><br>  <span class="hljs-comment">// 如果触发则执行Completion的动作, 并返回一个可能需要传播的阶段(如果存在的话)</span><br>  <span class="hljs-comment">// 触发的模式有三种: SYNC=同步, ASYNC=异步, NESTED=嵌套</span><br>  <span class="hljs-keyword">abstract</span> CompletableFuture&lt;?&gt; tryFire(<span class="hljs-type">int</span> mode);<br><br><span class="hljs-comment">// 当前Completion是否能继续触发</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLive</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 执行当前Completion, 提交到线程池中执行, 所以模式是异步</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>                &#123; tryFire(ASYNC); &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span>            &#123; tryFire(ASYNC); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="UniCompletion"><a href="#UniCompletion" class="headerlink" title="UniCompletion"></a>UniCompletion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UniCompletion</span>&lt;T,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Completion</span> &#123;<br>  <span class="hljs-comment">// 执行此Completion的线程池</span><br>  Executor executor;        <br>  <span class="hljs-comment">// 下个阶段的CF</span><br>  CompletableFuture&lt;V&gt; dep; <br>  <span class="hljs-comment">// 上个阶段的CF</span><br>  CompletableFuture&lt;T&gt; src; <br><br>  UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,CompletableFuture&lt;T&gt; src) &#123;<br>    <span class="hljs-built_in">this</span>.executor = executor; <br>    <span class="hljs-built_in">this</span>.dep = dep; <br>    <span class="hljs-built_in">this</span>.src = src;<br>  &#125;<br><br>  <span class="hljs-comment">// 当前Completion能否执行</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">claim</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Executor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> executor;<br>    <span class="hljs-comment">// 设置Task的标志位</span><br>    <span class="hljs-keyword">if</span> (compareAndSetForkJoinTaskTag((<span class="hljs-type">short</span>)<span class="hljs-number">0</span>, (<span class="hljs-type">short</span>)<span class="hljs-number">1</span>)) &#123;<br>      <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      executor = <span class="hljs-literal">null</span>; <span class="hljs-comment">// disable</span><br>      <span class="hljs-comment">// 向线程池中提交当前Completion</span><br>      e.execute(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><span class="hljs-comment">// 当前Completion是否关联下个阶段</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLive</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> dep != <span class="hljs-literal">null</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>UniCompletion子类如图:</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220616174008.png" alt="image-20220616174008226" style="zoom:50%;" /><p>除去<code>AsyncSupply</code>和<code>AsyncRun</code>两个类其他类都是UniCompletion的子类.</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> CompletableFuture                            <br>    .supplyAsync(() -&gt; <span class="hljs-number">10</span>)                        <span class="hljs-comment">// step1      </span><br>    .thenApplyAsync(res -&gt; res + <span class="hljs-number">1</span>)               <span class="hljs-comment">// step2                                  </span><br>    .thenApplyAsync(res -&gt; res + <span class="hljs-number">2</span>).get();        <span class="hljs-comment">// step3                           </span><br>  System.out.println(result);    <br>&#125;<br></code></pre></td></tr></table></figure><p>此代码等效于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <br>  <span class="hljs-comment">// step1  </span><br>  CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">10</span>);<br>  <span class="hljs-comment">// step2</span><br>  CompletableFuture&lt;Integer&gt; cf2 = cf1.thenApplyAsync(res -&gt; res + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// step3</span><br>  CompletableFuture&lt;Integer&gt; cf3 = cf2.thenApplyAsync(res -&gt; res + <span class="hljs-number">2</span>);<br>  System.out.println(cf3.get());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在CompletableFuture中可以使用一些静态方法来快捷的创建CompletableFuture.</p><p><code>supplyAsync</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span> &#123;<br>  <span class="hljs-comment">// 包装步骤</span><br>  <span class="hljs-keyword">return</span> asyncSupplyStage(asyncPool, supplier);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span> &#123;<br>  <br>  <span class="hljs-keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runAsync</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span> &#123;<br>  <span class="hljs-keyword">return</span> asyncRunStage(asyncPool, runnable);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executor)</span> &#123;<br>  <span class="hljs-keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法的区别就是: <code>runAsync</code>返回的CompletableFuture没有结果, 即<code>get</code>返回null. 而<code>supplyAsync</code>方法则由返回值.</p><h4 id="asyncSupplyStage方法原理"><a href="#asyncSupplyStage方法原理" class="headerlink" title="asyncSupplyStage方法原理"></a>asyncSupplyStage方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">asyncSupplyStage</span><span class="hljs-params">(Executor e, Supplier&lt;U&gt; f)</span> &#123;<br><br>  <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <span class="hljs-comment">// 新建一个 CompletableFuture</span><br>  CompletableFuture&lt;U&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;U&gt;();<br>  <span class="hljs-comment">// 向线程池中提交一个任务, 注意此任务类型是 AsyncSupply</span><br>  e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSupply</span>&lt;U&gt;(d, f));<br>  <span class="hljs-comment">// 返回新创建的 CompletableFuture</span><br>  <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="asyncRunStage方法原理"><a href="#asyncRunStage方法原理" class="headerlink" title="asyncRunStage方法原理"></a>asyncRunStage方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">asyncRunStage</span><span class="hljs-params">(Executor e, Runnable f)</span> &#123;<br>  <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <span class="hljs-comment">// 新建一个CompletableFuture</span><br>  CompletableFuture&lt;Void&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;Void&gt;();<br>  <span class="hljs-comment">// 提交一个 AsyncRun 的任务执行</span><br>  e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncRun</span>(d, f));<br>  <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对两个方法的解析, 可以看看出代码的流程是一致的, 只是最终想线程池中提交的任务类型不一样.</p><p><code>asyncSupplyStage ==&gt; AsyncSupply</code> 而 <code>asyncRunStage ==&gt; AsyncRun</code>.</p><p>查看AsyncSupply和AsyncRun两个内部类的<code>run</code>方法.</p><p><code>AsyncSupply.run</code>代码如下</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220617_async_apply_run.png" alt="image-20220617105321703"></p><p><code>AsyncRun.run</code>代码如下</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220617_async_run.png" alt="image-20220617105620095"></p><p>通过代码可以看出AsyncRun和AsyncSupply两个类的区别:</p><ul><li>都存在<code>fn</code>字段, 用于存储当前阶段执行的动作, 但是一个是Supplier类, 一个是Runnable类型.</li></ul><p>两个类的run方法在最后都调用了<code>CompletableFuture.postComplete()</code>方法.</p><p>在<code>supplyAsync()</code>或<code>runAsync()</code>执行完后会返回一个<code>CF</code>. 在其内部将需要执行的操作封装成了<code>AsyncSupply</code>或&#96;&#96;AsyncRun<code>并与</code>代表当前阶段的CF<code>进行关联. 此</code>AsyncSupply<code>和</code>AsyncRun<code>都是一个</code>FutureTask&#96;可以被线程池执行.</p><p>执行流程大致为: </p><ul><li>将执行的动作(<code>Supplier</code>或<code>Runnable</code>)和对应的<code>CF</code>通过<code>AsyncSupply</code>或<code>AsyncRun</code>进行封装</li><li>将<code>AsyncSupply</code>或<code>AsyncRun</code>并扔到线程池中执行. </li><li>而<code>AsyncSupply</code>或<code>AsyncRun</code>通过判断<code>CF.result==null</code>是否完成. 为空执行动作,反之则设置结果.</li><li>最终调用<code>postComplete</code>方法唤醒后续依赖的CF.</li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="thenApplyAsync方法原理"><a href="#thenApplyAsync方法原理" class="headerlink" title="thenApplyAsync方法原理"></a>thenApplyAsync方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApplyAsync</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>  <span class="hljs-comment">// 封装UniApply对象</span><br>  <span class="hljs-keyword">return</span> uniApplyStage(asyncPool, fn);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="uniApplyStage方法原理"><a href="#uniApplyStage方法原理" class="headerlink" title="uniApplyStage方法原理"></a>uniApplyStage方法原理</h5><p>此方法每次调用都会返回一个的CF, 但是每次调用的对象是不同的. </p><p>执行<code>step2</code>时是调用的<code>CF1.uniApplyStage</code>, 而在执行<code>step3</code>时是调用的<code>CF2.uniApplyStage</code>.</p><p><code>所以我们分析此段源码时 需要注意this所指向的对象</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">uniApplyStage</span><span class="hljs-params">(Executor e, </span><br><span class="hljs-params">                                               Function&lt;? <span class="hljs-built_in">super</span> T,? extends V&gt; action)</span> &#123;<br>  <br>  <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <span class="hljs-comment">// 假设step2创建的CF2, step3创建的是CF3</span><br>  CompletableFuture&lt;V&gt; cf =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;V&gt;();<br><br>  <span class="hljs-comment">// cf.uniApply 方法可以简单理解成执行一个action参数的动作, 后面会分析.</span><br>  <span class="hljs-comment">// step2执行时, this == CF1; step3执行时, this == CF2</span><br>  <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> || !cf.uniApply(<span class="hljs-built_in">this</span>, action, <span class="hljs-literal">null</span>)) &#123;<br>    <span class="hljs-comment">// 创建Completion对象关联当前阶段CF和下阶段CF</span><br>    UniApply&lt;T,V&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UniApply</span>&lt;T,V&gt;(e, cf, <span class="hljs-built_in">this</span>, action);<br>    <span class="hljs-comment">// 入栈, 每个CF都有一个stack变量存储Completion对象</span><br>    push(c);<br>    <span class="hljs-comment">// 尝试触发</span><br>    <span class="hljs-comment">// 疑问: 为什么会有同步和异步? 因为UniApply的父类Completion实现了Runnable接口</span><br>    c.tryFire(SYNC);<br>  &#125;<br>  <span class="hljs-keyword">return</span> cf;<br>&#125;<br></code></pre></td></tr></table></figure><p>看完这段代码可能非常疑惑.</p><ul><li>uniApply干了什么?</li><li>push方法做了什么?</li><li>tryFire干了什么?</li><li>UniApply是用于干什么的?</li></ul><p>但是大致流程是: </p><ul><li>创建了一个<code>UniApply</code>对象绑定了<code>新CF(cf对象)</code>和<code>当前CF(this)</code>同时还有新CF执行的<code>动作(action参数)</code><ul><li>此步骤体现: <code>new UniApply&lt;T,V&gt;(e, cf, this, action);</code></li></ul></li><li>然后将<code>UniApply</code>对象推送到<code>当前CF</code>的某个<code>地方</code><ul><li>此步骤体现: <code>push(c);</code></li></ul></li><li>最后尝试触发<code>UniApply</code>对象.<ul><li>此步骤体现: <code>c.tryFire(SYNC);</code></li></ul></li></ul><h5 id="uniApply方法原理"><a href="#uniApply方法原理" class="headerlink" title="uniApply方法原理"></a>uniApply方法原理</h5><p>step2执行时调用此方法的CF对象为: <code>CF2</code>. 所以参数a表示的是CF1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> &lt;S&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">uniApply</span><span class="hljs-params">(CompletableFuture&lt;S&gt; a, Function&lt;? <span class="hljs-built_in">super</span> S,? extends T&gt; f,</span><br><span class="hljs-params">                           UniApply&lt;S,T&gt; c)</span> &#123;<br>  Object r; Throwable x;<br>  <span class="hljs-comment">// 依赖的上一个CF还未执行完, 直接返回</span><br>  <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || (r = a.result) == <span class="hljs-literal">null</span> || f == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 当前CF结果为空</span><br>  tryComplete: <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 依赖的上一个CF执行出现异常, 则当前CF也设置异常</span><br>    <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> AltResult) &#123;<br>      <span class="hljs-keyword">if</span> ((x = ((AltResult)r).ex) != <span class="hljs-literal">null</span>) &#123;<br>        completeThrowable(x, r);<br>        <span class="hljs-keyword">break</span> tryComplete;<br>      &#125;<br>      r = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 依赖的上一个CF正常结束</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; !c.claim())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">S</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (S) r;<br>      <span class="hljs-comment">// 当前CF能执行则直接执行</span><br>      completeValue(f.apply(s));<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      completeThrowable(ex);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>可以看出此方法就是想尝试的执行一下当前CF的动作.</code> </p><p>如果依赖的上一个CF还未执行完或出现异常, 则当前CF的动作不会执行, 会直接返回.</p><h5 id="push-x2F-tryPushStack方法原理"><a href="#push-x2F-tryPushStack方法原理" class="headerlink" title="push&#x2F;tryPushStack方法原理"></a>push&#x2F;tryPushStack方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(UniCompletion&lt;?,?&gt; c)</span> &#123;<br>  <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">while</span> (result == <span class="hljs-literal">null</span> &amp;&amp; !tryPushStack(c))<br>      lazySetNext(c, <span class="hljs-literal">null</span>); <span class="hljs-comment">// clear on failure</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryPushStack</span><span class="hljs-params">(Completion c)</span> &#123;<br><span class="hljs-comment">// 获取当前CF的栈顶对象</span><br>  <span class="hljs-type">Completion</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> stack;<br>  <span class="hljs-comment">// 将c.next 指针指向了当前 Completion.stack</span><br>  lazySetNext(c, h);<br>  <span class="hljs-comment">// 将当前 CF.stack 更新成 c</span><br>  <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, STACK, h, c);<br>&#125;<br></code></pre></td></tr></table></figure><p>简而言之push方法就是将传递的Completion压入当前CF的stack变量的顶部.</p><p>当上述测试代码执行完, CF的执行结构如下图:</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220616154723.png" alt="image-20220616154723907"></p><h3 id="唤醒操作"><a href="#唤醒操作" class="headerlink" title="唤醒操作"></a>唤醒操作</h3><p>唤醒操作由大致有两类: 一类是CompletableFuture的唤醒, 一类是Completion的唤醒</p><p>通过整体的代码分析, 得知了触发后续CF的方法目前有两个:  <code>tryFire</code>和<code>postComplete</code>.</p><h4 id="postComplete方法原理"><a href="#postComplete方法原理" class="headerlink" title="postComplete方法原理"></a>postComplete方法原理</h4><p>该方法属于CompletableFuture</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postComplete</span><span class="hljs-params">()</span> &#123;<br>  <br>  CompletableFuture&lt;?&gt; src = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-comment">// 当前CF的栈顶对象</span><br>  Completion completion;<br>  <br>  <span class="hljs-comment">// 当step1执行时, src就是CF1</span><br>  <span class="hljs-keyword">while</span> ((completion = src.stack) != <span class="hljs-literal">null</span> <br>         || (src != <span class="hljs-built_in">this</span> &amp;&amp; (completion = (src = <span class="hljs-built_in">this</span>).stack) != <span class="hljs-literal">null</span>)) &#123;<br><br>    CompletableFuture&lt;?&gt; dep; Completion nextCompletion;<br><br>    <span class="hljs-comment">// 将当前CF的栈顶Completion出栈</span><br>    <span class="hljs-keyword">if</span> (src.casStack(completion, nextCompletion = completion.next)) &#123;<br>      <span class="hljs-comment">// 不为空, 说明当前CF调用了多次thenXXX, 生成了多个Completion</span><br>      <span class="hljs-keyword">if</span> (nextCompletion != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// src已经变化</span><br>        <span class="hljs-keyword">if</span> (src != <span class="hljs-built_in">this</span>) &#123;<br>          <span class="hljs-comment">// 将completion压入当前阶段CF的栈顶</span><br>          pushStack(completion);<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 便于垃圾回收</span><br>        completion.next = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// detach</span><br>      &#125;<br>      <span class="hljs-comment">// Completion.tryFire 返回代表下个阶段的CF, 所以每次循环</span><br>      <span class="hljs-comment">// NESTED: 表示内嵌触发, 即在一个CF中触发另一个CF</span><br>      src = (dep = completion.tryFire(NESTED)) == <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span> : dep;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用上面的测试代码分析流程: </p><p>第一次循环: src &#x3D; CF1. while循环第一个条件满足, 此时将CF1的栈顶Completion出栈. 由于栈中只有一个Completion所以<code>nextCompletion != null</code>不成立.</p><p>通过Completion的tryFire方法唤醒与此绑定的后续阶段(CF2). 然后dep!&#x3D;null, 返回dep, 此时src &#x3D; CF2</p><p>第二次循环: src &#x3D; CF2, while循环第一个条件满足, 此时将CF2的栈顶Completion出栈, 同样的<code>nextCompletion != null</code>不成立.</p><p>通过Completion的tryFire方法唤醒与此绑定的后续阶段(CF3). 然后dep!&#x3D;null, 返回dep, 此时src &#x3D; CF3</p><p>第三次循环: src&#x3D;CF3, while循环第一个条件不满足(CF3没有发生thenXXX调用, 所以它的栈是空的), 此时会走while循环第二个条件, 此时src被重新切回到了CF1. 但是CF1的栈也只有一个, 所以while循环终止(第一次循环时唯一的Completion出栈了).</p><p><code>注意这三次循环都是在CF1.postCompele方法中完成的.</code></p><p>当第二次循环后, CF2开始执行.</p><h4 id="tryFire方法原理"><a href="#tryFire方法原理" class="headerlink" title="tryFire方法原理"></a>tryFire方法原理</h4><p>此方法属于Completion, 用于触发依赖此Completion的阶段(dep字段即代表下个阶段的CF).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> CompletableFuture&lt;V&gt; <span class="hljs-title function_">tryFire</span><span class="hljs-params">(<span class="hljs-type">int</span> mode)</span> &#123;<br><br>  CompletableFuture&lt;V&gt; d; CompletableFuture&lt;T&gt; a;<br>  <span class="hljs-comment">// 参数合法的情况下执行一下 当前阶段. dep为当前阶段, src为上个阶段</span><br>  <span class="hljs-keyword">if</span> ((d = dep) == <span class="hljs-literal">null</span> || !d.uniApply(a = src, fn, mode &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : <span class="hljs-built_in">this</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// 参数不合法 或者 执行失败 直接返回</span><br><br>  <span class="hljs-comment">// 字段置为空, 则当调用Completion.isLive时返回false. 便于清理栈中死亡的Completion</span><br>  dep = <span class="hljs-literal">null</span>; src = <span class="hljs-literal">null</span>; fn = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 能执行, 则继续向后触发</span><br>  <span class="hljs-keyword">return</span> d.postFire(a, mode);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法用于尝试触发下个阶段的执行, 此时上个阶段<code>已执行完成</code>,或者还<code>未执行完成</code>.</p><p><strong>postFire方法原理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">postFire</span><span class="hljs-params">(CompletableFuture&lt;?&gt; a, <span class="hljs-type">int</span> mode)</span> &#123;<br>  <span class="hljs-comment">// a为当前阶段所依赖的上一个阶段</span><br>  <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span> &amp;&amp; a.stack != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 上阶段的CF还未执行完</span><br>    <span class="hljs-comment">// 内嵌模式 或 非内嵌且上阶段的结果为空.</span><br>    <span class="hljs-keyword">if</span> (mode &lt; <span class="hljs-number">0</span> || a.result == <span class="hljs-literal">null</span>)<br>      <span class="hljs-comment">// 清楚栈</span><br>      a.cleanStack();<br>    <span class="hljs-comment">// 上阶段CF执行结束</span><br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 触发上阶段CF的后续阶段</span><br>      a.postComplete();<br>  &#125;<br>  <span class="hljs-comment">// 当前阶段的CF执行完成, 且有下阶段CF</span><br>  <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span> &amp;&amp; stack != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 内嵌模式, 返回当前阶段</span><br>    <span class="hljs-keyword">if</span> (mode &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 触发下阶段的CF</span><br>      postComplete();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法作用就是: </p><ol><li>检查是否存在另一个阶段和当前阶段一样, 依赖上阶段完成时触发. </li><li>如果当前阶段已完成则触发后续阶段</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CompletableFuture的核心就是Completion, 通过Completion就前后阶段的CF连接了起来. </p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="/2022/11/18/tcp/Tcp/"/>
    <url>/2022/11/18/tcp/Tcp/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>TCP&#x2F;IP协议栈时一系列网络协议的总和，是构成网络通信的核心骨架，定义了电子设备如何连入互联网，以及数据如何在它们之间进行传输。</p><p>TCP&#x2F;IP协议采用<strong>4</strong>层结构，分别是<code>应用层,传输层,网络层,链路层,物理层</code>，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>TCP是<code>面向连接, 可靠的, 面向流</code>的传输协议.</p><p>TCP和UDP都是<code>传输层</code>协议.</p><h4 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h4><p><code>面向有链接型</code> 和 <code>面向无连接型</code>两类</p><h3 id="TCP数据包"><a href="#TCP数据包" class="headerlink" title="TCP数据包"></a>TCP数据包</h3><p>应用层发送数据, 首先经过传输层进行包装 添加TCP等信息, 在经过网络层添加IP等信息, 最后链路层进行包装</p><p>TCP首部最小<code>20</code>个字节,分为<code>5层</code>, 每层4个字节 即32位.</p><ul><li><p>第一层: 源端口号 + 目标端口号 分别占用16位.</p></li><li><p>第二层: 32位序列号</p><ul><li>TCP使用序列号对数据进行标记, 便于到达目的后重新组装.</li></ul></li><li><p>第三层: 32位确认号</p><ul><li>确认号用于表示期望收到对方下一次报文段的序号值</li></ul></li><li><p>第四层: 4位首部长度 + 6位保留 + 6位标识 + 16位窗口大小</p><ul><li>4位表示了TCP的报文段的首部长度, 指出了<code>TCP数据起始处</code>到<code>TCP报文起始处</code>的长度</li><li>6位用于保留使用</li><li>6个标志位, 每个1bit</li></ul></li><li><p>第五层: 16位校验和 + 16位紧急指针</p></li></ul><h4 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h4><p>序列号占32位, 用于对数据进行标记, 便于到达目的后重新组装</p><h4 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h4><p>确认好占32位, 用于表示期望收到对方下一次报文段的序号值</p><h4 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h4><p>一共有六个标志位, 每一位1个bit. 分别是: <code>ACK, RST, FIN, SYN, PSH, URG</code>.</p><ul><li>ACK: 确认序号有效</li><li>RST: 重置连接</li><li>SYN: 发起新连接</li><li>FIN: 释放一个连接</li><li>URG: 紧急消息</li><li>PSH: 缓冲区未填满</li></ul><p>当TCP连接建立后, 传送的所有报文段的ACK必须设置为1.</p><p>PSH&#x3D;1 表明该报文段高优先级, 不用等待缓冲区填满.</p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>窗口大小位于第4层, 占16位.</p><p>主要用于告知对方端: <code>当前端的TCP缓冲区还能容纳多少数据. 可以控制发送数据的速度.</code></p><h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p>校验占用两个字节, 16位,位于第五层.</p><p>主要用于结合CRC算法校验TCP的报文是否损坏过. 校验范围: <code>首部+数据</code></p><h4 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h4><p>紧急指针占2个字节, 16位当URG&#x3D;1时才有效.</p><p> 用于表示当前报文段中紧急数据的大小.</p><h3 id="TCP为什么可靠"><a href="#TCP为什么可靠" class="headerlink" title="TCP为什么可靠?"></a>TCP为什么可靠?</h3><p>因为TCP使用了三次握手才建立了连接.</p><p>C代表客户端, S代表服务端</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>C —-&gt; SYN K —-&gt; S</p><p>C &lt;—- SYN N + ACK K + 1 &lt;—- S</p><p>C —-&gt; ACK N + 1 —-&gt; S</p><h4 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h4><p>客户端主动发起断开操作:</p><p>C —-&gt; FIN K —-&gt; S</p><p>C &lt;—-  ACK K + 1 &lt;—- S   :  客户端端和服务端都进入等待状态</p><p>C &lt;—-  FIN N &lt;—- S          : 客户端进入<code>TIME_WAIT</code>, 等待2MSL时间</p><p>C —-&gt;  ACK N + 1 —-&gt; S   : </p><p>MSL 表明最长报文段寿命.</p><h4 id="等待2MSL"><a href="#等待2MSL" class="headerlink" title="等待2MSL?"></a>等待2MSL?</h4><p>当C进入TIME_WAIT时, 需要再次向S响应一个ACK报文段, 表明客户端收到了关闭请求.</p><ol><li>保证此次连接的数据段在网络中消失</li><li>保证TCP协议的全双工连接能够可靠关闭</li></ol><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>当网络出现阻塞, 发送的数据会丢失, 此时发送方会重试, 从加重拥塞.  解决此问题一共有四种算法:</p><p><code>慢开始, 拥塞避免, 快重传, 快恢复</code>.</p><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><p>发送方会维护一个发送窗口的状态变量(<code>cwnd</code>). </p><p>当建立连接后首次发送数据时进入<code>慢开启 cwnd=1</code>, 当收到确认后 cwnd 开始成倍递增. 随着报文段数量上升, 网络的拥塞的可能性越大, 当cwnd达到一个阈值后(<code>ssthresh 同时进入拥塞避免</code>), 则cwnd将不会成倍增长, 而是+1. 如果超时则cwnd &#x2F;&#x3D; 2.</p><h4 id="快重传-x2F-快恢复"><a href="#快重传-x2F-快恢复" class="headerlink" title="快重传&#x2F;快恢复"></a>快重传&#x2F;快恢复</h4><p>当接受方收到报文后, 主要向发送方发送确认消息, <code>确认最后一个有序报文段</code>. 如果发送方收到对某个报文段的多次且重复的确认,则会进入<code>快重传</code>, 重新发送丢失的报文段. </p><p>而由于报文段丢失, 接受方位收到确认, 则可能重新进入慢开始. 此时则需要执行<code>快恢复</code>. 将<code>cwnd = ssthresh = cwnd / 2</code>.</p><h3 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h3><p>粘包就是连续发送的两个数据包 粘到了一块. 本来接受方需要接受两次的, 发生粘包后一次就可以了.</p><p>拆包就是连续发送的两个数据包, 其中一个被拆成了两部分. 例如: packetA 被拆成了 packetA.1 packetA.2 两个.</p><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么?"></a>为什么?</h4><ul><li><code>发送的数据小于TCP的缓冲区会发生拆包</code></li><li><code>发送的数据大于MSS(报文最大长度)会发生拆包</code></li><li><code>发送的数据小于TCP的缓冲区会发生粘包 或 TCP将多次写入缓冲区的数据一次刷出也会发生粘包</code></li><li><code>接受方没有及时读取接受缓冲区的中的数据</code></li></ul><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>由于TCP是面向流的, 所以从底层是无法解决的. 只能从上层(应用层)解决.</p><ul><li>消息定长: 发送的数据包长度一致, 不够的话填充0</li><li>设置消息边界: 类似于标识, 例如FTP使用<code>回车换行符</code>来进行数据分割.</li><li>消息分割: 将消息分为<code>头</code>和<code>体</code>.  头中会保存消息体的长度.</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先梳理一下每层模型的职责：</p><ul><li>链路层：对0和1进行分子，定义数据帧，确认主机的物理地址，传输数据。</li><li>网络层：定义IP地址，确认主机所在网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发。</li><li>传输层：定义端口，确认主机上应用程序身份，并将数据包交给对应的应用程序。</li><li>应用层：定义数据格式，并按照对应的格式解读数据。</li></ul>]]></content>
    
    
    <categories>
      
      <category>底层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS源码分析v2.0</title>
    <link href="/2022/11/18/juc/abstract_queue_synchronizer/"/>
    <url>/2022/11/18/juc/abstract_queue_synchronizer/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲解在向AQS的源码解析</p><span id="more"></span><h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><h3 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h3><blockquote><p>本章主要讲述 JUC 包下的 AQS 的设计与现实, 同时了解 AQS 中独占和共享模式的运转原理和机制</p><ol><li>AQS 的设计和实现</li><li>AQS 中独占和共享模式的源代码分析</li></ol></blockquote><h3 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h3><p>该类为<code>AbstractQueuedSynchronizer</code>的父类,  其中包含了一个核心的字段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;<br></code></pre></td></tr></table></figure><p>此字段用于标识<code>独占模式下</code>当前持有锁的线程.</p><h3 id="AbstractQueuedSynchronizer-Node"><a href="#AbstractQueuedSynchronizer-Node" class="headerlink" title="AbstractQueuedSynchronizer.Node"></a>AbstractQueuedSynchronizer.Node</h3><p>在AQS中队列的节点由内部类<code>Node</code>来表示. 队列则是由一个个Node节点来形成的. 而从Node自身的变量可以知道当前节点的上一下节点(pre)和一下个节点(next). 同时每个节目都含有状态(唤醒时使用). </p><p>由于需要知道具体抢锁的线程, 所以Node包含了<code>Thread</code>的引用. </p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>  <span class="hljs-comment">// 当前节点是否是共享节点</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br><span class="hljs-comment">// 当前节点是否是独立节点</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 取消状态</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 唤醒状态</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 条件队列状态</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 传播状态, 共享模式下使用</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment">// 存储当前节目的状态</span><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br><br>  <span class="hljs-comment">// 当前节点的上一个节点</span><br>  <span class="hljs-keyword">volatile</span> Node prev;<br><br>  <span class="hljs-comment">// 当前节点的下一个节点</span><br>  <span class="hljs-keyword">volatile</span> Node next;<br><br>  <span class="hljs-comment">// 节点对应的线程</span><br>  <span class="hljs-keyword">volatile</span> Thread thread;<br><br>  <span class="hljs-comment">// 下一个等待节点, 此字段在条件等待队列中使用</span><br>  Node nextWaiter;<br><br>  <span class="hljs-comment">// 是否是共享节点</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>  &#125;<br><br>  <span class="hljs-comment">// 返回上一个节点</span><br>  <span class="hljs-keyword">final</span> Node <span class="hljs-title function_">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> prev;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过源码知道了每个节点的状态有四个取值分别是: <code>SIGNAL, CANCELLED, CONDITION, PROPAGATE</code>.</p><p>其中需要注意<code>CANCELLED</code>的取值为正数(大于0),  其他的状态值都为负数. 后续此条件会经常用到. 需要特殊注意.</p><p><code>注意: waitStatus 默认初始化值为0.</code></p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Node(Thread thread, Node mode) &#123;     <br>  <span class="hljs-comment">// 赋值</span><br>  <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>  <span class="hljs-built_in">this</span>.thread = thread;<br>&#125;<br><br>Node(Thread thread, <span class="hljs-type">int</span> waitStatus) &#123; <br>  <span class="hljs-comment">// 赋值</span><br>  <span class="hljs-built_in">this</span>.waitStatus = waitStatus;<br>  <span class="hljs-built_in">this</span>.thread = thread;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心变量"><a href="#核心变量" class="headerlink" title="核心变量"></a>核心变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队列头结点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 队列尾节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br></code></pre></td></tr></table></figure><p>AQS可以通过<code>head, tail</code>变量来操作队列中的元素. 此时队列已经完善了, 那么使用什么来表示锁呢?</p><p>AQS使用了一个<code>int</code>类型的字段来表示锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure><p>AQS中所有的操作都是围绕这个字段来展开的, 线程通过CAS来不断的修改这个值, 来模拟抢锁(修改成功则代表抢锁成功, 反之则抢锁失败).</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>AQS的核心方法包括: </p><ul><li><code>acquire(int arg):</code> 独占模式下获取锁.</li><li><code>acquireInterruptibly(int arg): </code> 独占模式下可中断获取锁, 当线程中断时直接抛出中断异常.</li><li><code>release(int arg):</code> 独占模式下释放锁</li><li><code>acquireShared(int arg):</code> 共享模式下获取锁</li><li><code>acquireSharedInterruptibly(int arg):</code> 共享模式下可中断获取锁</li><li><code>releaseShared(int arg):</code> 共享模式下释放锁</li></ul><h4 id="acquire方法原理"><a href="#acquire方法原理" class="headerlink" title="acquire方法原理"></a>acquire方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>    selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tryAcquire</code>方法有具体的子类实现, 返回值代表抢锁是否成功: <code>true</code>表示抢锁成功, <code>false</code>表示抢锁失败.</p><p>当抢锁失败时, 会调用<code>addWaiter</code>方法来创建Node节点并入队. 注意<code>Node.EXCLUSIVE</code>是个空对象.  当入队完成时可能有其他线程释放锁了, 所以调用<code>acquireQueued</code>开启循环不断去获取锁.</p><h5 id="acquireQueued方法原理"><a href="#acquireQueued方法原理" class="headerlink" title="acquireQueued方法原理"></a>acquireQueued方法原理</h5><p>该方法就是开启一个循环, 不断的去获取锁同时判断前置节目的状态. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 开启自旋</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 当前节点的上一个节点</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>      <span class="hljs-comment">// 如果是头结点, 则再次尝试获取锁</span><br>      <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>        <span class="hljs-comment">// 设置头结点</span><br>        setHead(node);<br>        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>        failed = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> interrupted;<br>      &#125;<br>      <span class="hljs-comment">// 当获取锁失败时, 则根据前置节点的状态来判断是否需要阻塞当前线程</span><br>      <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>        interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (failed)<br>      <span class="hljs-comment">// 获取失败则取消当前节点</span><br>      cancelAcquire(node);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意此时循环的结束条件: <code>只有当前节点获取锁成功才会结束循环. 即p == head &amp;&amp; tryAcquire(arg)条件成立</code>.</p><p><code>shouldParkAfterFailedAcquire</code>方法就是根据前置节点的状态来判断当前线程是否应该被阻塞. </p><p>而<code>parkAndCheckInterrupt</code>方法就是阻塞当前线程并检查线程中断标志位. 底层调用<code>LockSupport.park</code>方法.</p><h4 id="addWaiter方法原理"><a href="#addWaiter方法原理" class="headerlink" title="addWaiter方法原理"></a>addWaiter方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>  <span class="hljs-comment">// 创建Node节点, 并传递当前线程池</span><br>  <span class="hljs-comment">// 当独占模式时, mode==null, 共享模式时 mode==Node.SHARED</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>  <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>  <span class="hljs-comment">// 尾节点不为空, 则将当前节点置为尾节点</span><br>  <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>    node.prev = pred;<br>    <span class="hljs-comment">// cas 将当前节点设置成尾节点, 如果失败则会执行enq方法</span><br>    <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>      pred.next = node;<br>      <span class="hljs-keyword">return</span> node;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 到这里两种情况: 1. tail==null 2. compareAndSetTail(pred, node) 失败</span><br>  enq(node);<br>  <span class="hljs-comment">// 返回当前节点</span><br>  <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法比较简单, 就是创建<code>Node</code>节点并通过<code>cas修改tail节点</code>. 如果<code>cas修改失败</code>或者<code>队列为初始化</code>, 则调用<code>enq</code>方法开启循环进行队列初始化和<code>cas</code>修改<code>tail</code>节点.</p><h4 id="enq方法原理"><a href="#enq方法原理" class="headerlink" title="enq方法原理"></a>enq方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>  <span class="hljs-comment">// 开启循环</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 尾节点为空, 则头结点必然也为空</span><br>      <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<span class="hljs-comment">// 初始化头结点</span><br>        tail = head;<br>    &#125; <br>    <span class="hljs-comment">// 不为空</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      node.prev = t;<br>      <span class="hljs-comment">// 设置node节点为尾节点</span><br>      <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>        t.next = node;<br>        <span class="hljs-keyword">return</span> t;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出此方法的作用有两个: <code>1. 初始化队列头(head) 和 尾(tail); 2.将指定节点添加到尾部(即tail)</code></p><p>循环的终止条件为: 通过cas将tail节点修改成当前节点成功才会结束.</p><h4 id="release方法原理"><a href="#release方法原理" class="headerlink" title="release方法原理"></a>release方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-comment">// 尝试释放锁</span><br>  <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>      <span class="hljs-comment">// 解锁后继者</span><br>      unparkSuccessor(h);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 失败直接返回</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="acquireShared方法原理"><a href="#acquireShared方法原理" class="headerlink" title="acquireShared方法原理"></a>acquireShared方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-comment">// 尝试获取共享锁, 小于0说明共享锁已经没了.</span><br>  <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 再次尝试获取</span><br>    doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="doAcquireShared方法原理"><a href="#doAcquireShared方法原理" class="headerlink" title="doAcquireShared方法原理"></a>doAcquireShared方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-comment">// 添加一个共享节点</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 循环, 也叫自旋</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 前置节点</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>      <span class="hljs-keyword">if</span> (p == head) &#123;<span class="hljs-comment">// 如果前置节点为头结点</span><br>        <span class="hljs-comment">// 再次尝试获取共享锁. 此时两种情况: 头结点释放了锁 或者 没有释放锁.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>        <span class="hljs-comment">// 大于0, 说明还有锁资源</span><br>        <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// 设置头结点, 并传播</span><br>          setHeadAndPropagate(node, r);<br>          p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>          <span class="hljs-comment">// 如果线程设置过中断标志位, 则直接抛出中断异常</span><br>          <span class="hljs-keyword">if</span> (interrupted)<br>            selfInterrupt();<br>          failed = <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 前置节目非头结点 或者 前置节点是头节点但确没有释放锁</span><br><span class="hljs-comment">// shouldParkAfterFailedAcquire参考上面的解析</span><br>      <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>        interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (failed)<br>      <span class="hljs-comment">// 失败则取消节点</span><br>      cancelAcquire(node);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当执行此方法时, 存在的场景如下:</p><ol><li>成功获取到锁, 执行完<code>setHeadAndPropagate</code>返回.</li><li>继续循环, 不断调用<code>shouldParkAfterFailedAcquire</code>方法修改前置节目的状态(修改成SIGNAL).</li><li>已经调用<code>parkAndCheckInterrupt</code>阻塞.</li></ol><h5 id="setHeadAndPropagate方法原理"><a href="#setHeadAndPropagate方法原理" class="headerlink" title="setHeadAndPropagate方法原理"></a>setHeadAndPropagate方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>  <span class="hljs-comment">// 该方法可能同时有多个线程进入</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>  <span class="hljs-comment">// 设置并更新头结点</span><br>  setHead(node);<br><br>  <span class="hljs-comment">// propagate &gt; 0: 说明还有多余的锁资源. 后续节点可以被唤醒</span><br>  <span class="hljs-comment">// propagate = 0: 说明没有多余的所资源. 需要根据头结点状态来进行判断</span><br>  <span class="hljs-comment">// h.waitStatus &lt; 0: 后续线程可以被唤醒</span><br>  <span class="hljs-comment">// h.waitStatus = 0: 等于0说明可能有其他线程在执行释放锁操作(即调用doReleaseShared方法)</span><br>  <span class="hljs-comment">// 因为可能有人在释放锁, 此时head节点可能已经更新了, 所以再次获取head节点用于判断</span><br>  <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>      (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 获取下一个节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">// 处于共享状态, 则执行共享释放.</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())<br>      doReleaseShared();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于<code>releaseShared</code>方法最终调用的也是<code>doReleaseShared</code>方法, 所以将其解析放在下面.</p><h4 id="releaseShared方法原理"><a href="#releaseShared方法原理" class="headerlink" title="releaseShared方法原理"></a>releaseShared方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-comment">// 尝试释放共享锁</span><br>  <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>    doReleaseShared();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="doReleaseShared方法原理"><a href="#doReleaseShared方法原理" class="headerlink" title="doReleaseShared方法原理"></a>doReleaseShared方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 调用此方法有两处: 1. 获取锁时调用, 2. 释放锁时调用</span><br><br>  <span class="hljs-comment">// 开启自旋</span><br>  <span class="hljs-keyword">for</span> (; ; ) &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// 获取头</span><br>    <span class="hljs-comment">// 条件成立的情况: 队列中还有节点</span><br>    <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;    <span class="hljs-comment">// 获取节点状态</span><br>      <span class="hljs-comment">// 头结点为SIGNAL, 说明有线程在执行doAcquireShared方法中的循环(且获取共享锁失败)</span><br>      <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>        <span class="hljs-comment">// cas更新状态, 告知其他线程有现成在释放锁</span><br>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>)) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        unparkSuccessor(h);<br>      &#125;<br><br>      <span class="hljs-comment">// ws == 0 表明有可能其他线程也在释放锁</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 到这里说明, 执行完 unparkSuccessor 或 compareAndSetWaitStatus(h, 0, Node.PROPAGATE) 成功后</span><br>    <span class="hljs-comment">// 如果有后续节目被唤醒且获取锁成功, 则head势必会更改, 反之则不会. 结束循环.</span><br>    <span class="hljs-keyword">if</span> (h == head)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看完此方法可能有点疑惑, 举个例子: 此时有 A, B, C三个线程, 只有一把共享锁, 假设此时B和C在队列中排队等待A释放锁.</p><p>此时队列如下:<code>head -&gt; B(blocked) -&gt; C(blocked)</code>  &#x2F;   <code>A -- lock</code></p><p>当A线程调用<code>doReleaseShared</code>方法时,  此时head的状态必然是<code>SIGNAL</code>, 所以会cas修改状态并唤醒B线程. </p><p>注意此时会出现两种情况:</p><ol><li>A线程执行到<code>h == head</code>时, head还未更改, A线程结束循环, 完成释放是操作. 情况如下:<ol><li>出现新的D线程抢走了锁</li><li>B线程抢到了锁,但是还未执行<code>setHead</code>操作即更新头结点.</li></ol></li><li>A线程执行到<code>h == head</code>时, head已经更改, A线程继续循环. 情况如下:<ol><li>B线程执行完了<code>setHead</code>操作</li></ol></li></ol><p>当B线程执行<code>setHeadAndPropagate</code>方法后最终进入<code>doReleaseShared</code>方法, 同A线程一样执行起了相同的唤醒操作.</p><p>此时唤醒的线程有A和B两个线程, 注意此时B还未释放锁. 当C线程被唤醒后, 尝试去获取锁, 结果失败. head节点不会更改, 此时<code>h == head</code>成立, A线程和B线程结束循环. 退出释放的操作.</p><p>后续B线程调用<code>releaseShared</code>方法释放锁,则和A线程当初一样. 继续循环唤醒.</p><p>简单来说就是: 只要有线程释放锁或获取到锁, 此线程都会加入唤醒后续线程的<code>队伍</code>. 直到后续线程唤醒后无法抢锁. 导致head不更新, <code>队伍</code>中的唤醒线程才会停止唤醒操作.</p><h4 id="shouldParkAfterFailedAcquire方法原理"><a href="#shouldParkAfterFailedAcquire方法原理" class="headerlink" title="shouldParkAfterFailedAcquire方法原理"></a>shouldParkAfterFailedAcquire方法原理</h4><p>此方法无论是在独享锁或共享锁的情况下都会有调用, 且都是在获取锁失败的情况下.</p><p>该方法主要是判断前置节点去状态来对当前节点进行操作: 1. 继续循环获取锁 2. 直接阻塞. 由返回结果标识.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>  <span class="hljs-comment">// 获取上一个节点的状态</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>  <span class="hljs-comment">// 状态为SIGNAL, 说明前置节点也需要被唤醒</span><br>  <span class="hljs-comment">// 疑问: 前置节点的状态在哪里修改的?</span><br>  <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">// 大于0, 说明是前置节点为取消状态, 则跳过, 直到找到非取消状态的节点</span><br>  <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-comment">// 跳过取消的前置节点</span><br>      node.prev = pred = pred.prev;<br>    &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>    pred.next = node;<br>  &#125; <br>  <span class="hljs-comment">// 非取消状态</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// cas修改前置节点的状态, 可能成功或失败</span><br>    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出此方法做了两件事:</p><ul><li>清理队列中的取消节点</li><li>设置前置节点的状态为<code>SIGNAL</code>, 以表示当前节点可以被安全的阻塞</li></ul><p>此方法仅当前置节点的状态为<code>SIGNAL</code>返回<code>true</code>, 其余情况返回<code>false</code>. </p><h4 id="unparkSuccessor方法原理"><a href="#unparkSuccessor方法原理" class="headerlink" title="unparkSuccessor方法原理"></a>unparkSuccessor方法原理</h4><p>注意此方法的调用有多处: 1. 独享锁的释放<code>release</code> 2. 共享锁的获取或释放<code>releaseShared</code> 3. 取消节点</p><p>此方法根据传入的node节点, 唤醒node的后继节点.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>  <span class="hljs-comment">// 节点</span><br>  <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 尝试cas更新节点状态, 可能成功或失败</span><br>    compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 获取到当前节点的下一个节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>  <span class="hljs-comment">// 如果节点状态为CANCELLED状态</span><br>  <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>    s = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 从尾部开始向前寻找, 直到找到一个正常节点.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>      <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>        s = t;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>    <span class="hljs-comment">// 解锁下一个节点中的线程</span><br>    LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="cancelAcquire方法原理"><a href="#cancelAcquire方法原理" class="headerlink" title="cancelAcquire方法原理"></a>cancelAcquire方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br><br>  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">return</span>;<br>  node.thread = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 向前找到状态小于0的节点(即未取消的节点)</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>  <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)&#123;<br>    node.prev = pred = pred.prev;<br>  &#125;<br><br>  <span class="hljs-comment">// 获取到前置节点的next节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br><br>  <span class="hljs-comment">// 将状态更新为取消, 下次节点入队会清除掉此节点</span><br>  node.waitStatus = Node.CANCELLED;<br><br>  <span class="hljs-comment">// 当前节点为尾节点则直接cas更新tail</span><br>  <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>    <span class="hljs-comment">// 此时pred已经是尾节点, 将其next引用设置为null</span><br>    compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);<br>  &#125;<br>  <span class="hljs-comment">// 当前节点非tail节点</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">int</span> ws;<br>    <span class="hljs-comment">// pred非头结点</span><br>    <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>        <span class="hljs-comment">// 且判断前置节点是否为SIGNAL, 不是则通过CAS修改为SIGNAL</span><br>        <span class="hljs-comment">// 此时pred的状态可能是: SIGNAL, CONDITION, PROPAGATE, 0</span><br>        ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL)))<br>        <span class="hljs-comment">// 且前置节点线程不为空</span><br>        &amp;&amp; pred.thread != <span class="hljs-literal">null</span><br>       ) &#123;<br>      <span class="hljs-comment">// 获取当前节点的next</span><br>      <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>      <span class="hljs-comment">// 当前节点的后继节点有效</span><br>      <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 则将前置节点的next指针指向当前节点的后继节点</span><br>        compareAndSetNext(pred, predNext, next);<br>    &#125;<br>    <span class="hljs-comment">// pred为头结点, 则说明当前节点是第二个. 直接唤醒后续即可.</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      unparkSuccessor(node);<br>    &#125;<br><br>    node.next = node; <span class="hljs-comment">// help GC</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>Condition是ConditionObject实现的接口, 定义了ConditionObject包含了那些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;<br><br>  <span class="hljs-comment">// 使当前线程阻塞, 直到有信号唤醒或中断</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>  <span class="hljs-comment">// 使当前线程阻塞, 直到有信号唤醒, 不响应中断</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span>;<br>  <br>  <span class="hljs-comment">// 使当前线程阻塞指定时间</span><br>  <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>  <span class="hljs-comment">// 使当前线程阻塞指定时间</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>  <span class="hljs-comment">// 使当前线程阻塞</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>  <span class="hljs-comment">// 唤醒一个等待的线程</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 唤醒所有等待的线程. 所有唤醒的线程都要重新获取锁才会返回.</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>在ConditionObject内部其实也是使用的队列来管理等待的线程. 它和AQS使用的队列隔离.</p><h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 条件队列的头</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br><span class="hljs-comment">// 条件队列的尾</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br><span class="hljs-comment">/** Mode meaning to reinterrupt on exit from wait */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REINTERRUPT</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br><span class="hljs-comment">/** Mode meaning to throw InterruptedException on exit from wait */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THROW_IE</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>可以看到<code>ConditionObject</code>也使用了<code>Node</code>内部类来封装节点. </p><p>由于AQS中也存在队列所以我们称之为: <code>同步队列</code>. 而ConditionObject也存在队列所以称为: <code>条件等待队列</code></p><h4 id="await方法原理"><a href="#await方法原理" class="headerlink" title="await方法原理"></a>await方法原理</h4><p>调用此方法时, 线程必须持有锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-comment">// 线程由中断标志位,直接抛出异常</span><br>  <span class="hljs-keyword">if</span> (Thread.interrupted())<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-comment">// 添加一个新的条件等待节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>  <span class="hljs-comment">// 全部释放锁</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>  <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 当前节点是否在 同步队列 中</span><br>  <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>    <span class="hljs-comment">// 阻塞</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 循环结束u</span><br>  <span class="hljs-comment">// acquireQueued该方法和独享模式下获取锁调用的方法一致</span><br>  <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>    interruptMode = REINTERRUPT;<br>  <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>    unlinkCancelledWaiters();<br>  <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>    reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="addConditionWaiter方法原理"><a href="#addConditionWaiter方法原理" class="headerlink" title="addConditionWaiter方法原理"></a>addConditionWaiter方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>  <span class="hljs-comment">// 节点是取消状态</span><br>  <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>    <span class="hljs-comment">// 将取消状态的节点提出队列</span><br>    unlinkCancelledWaiters();<br>    t = lastWaiter;<br>  &#125;<br>  <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>    firstWaiter = node;<br>  <span class="hljs-keyword">else</span><br>    t.nextWaiter = node;<br>  lastWaiter = node;<br>  <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>从这个方法可以看出 <code>条件等待队列</code> 是一个<code>单向</code>的链表, 只能<code>从头向尾</code>遍历.</p><h4 id="signal方法原理"><a href="#signal方法原理" class="headerlink" title="signal方法原理"></a>signal方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 非独占模式抛出异常</span><br>  <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>  <span class="hljs-comment">// 获取到第一个节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br><br>  <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>    <span class="hljs-comment">// 唤醒一个节点</span><br>    doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure><p>从<code>signal</code>方法可以看出使用<code>ConditionObject</code>必须要在独占模式下才能使用.</p><h5 id="doSignal方法原理"><a href="#doSignal方法原理" class="headerlink" title="doSignal方法原理"></a>doSignal方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 此时first节点已经出队, 即条件等待队列中是否还有节点</span><br>    <span class="hljs-keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>      lastWaiter = <span class="hljs-literal">null</span>;<br>    first.nextWaiter = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-comment">// 唤醒条件等待队列的第一个线程, 且条件队列后续节点不为空</span><br>  <span class="hljs-comment">// transferForSignal 返回false: 说明first节点已经取消, 跳下一个节点继续执行</span><br>  <span class="hljs-comment">// transferForSignal 返回true: 说明first节点已经进入同步队列, 结束循环.</span><br>  <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="signalAll方法原理"><a href="#signalAll方法原理" class="headerlink" title="signalAll方法原理"></a>signalAll方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 非独占模式抛出异常</span><br>  <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>  <span class="hljs-comment">// 获取到第一个节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>  <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>    <span class="hljs-comment">// 唤醒所有节点</span><br>    doSignalAll(first);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="doSignalAll方法原理"><a href="#doSignalAll方法原理" class="headerlink" title="doSignalAll方法原理"></a>doSignalAll方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;<br>  <span class="hljs-comment">// 将头和尾节点都置为空</span><br>  lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 获取第二个节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br>    first.nextWaiter = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 添加节点到 同步队列 中, 并解锁线程(可能发生)</span><br>    transferForSignal(first);<br>    first = next;<br>  &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="transferForSignal方法原理"><a href="#transferForSignal方法原理" class="headerlink" title="transferForSignal方法原理"></a>transferForSignal方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br><br>  <span class="hljs-comment">// 当前节点已经取消, 单值cas修改当前节点状态失败.</span><br>  <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 调用enq方法进入 同步队列. 此时p指针指向的是node节点的前置节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>  <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br><br>  <span class="hljs-comment">// 前置节点为取消或cas修改前置节点失败则唤醒当前线程</span><br>  <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>    LockSupport.unpark(node.thread);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<code>p</code>节点如果被阻塞, 那么cas必然是能成功的, 只有<code>p</code>节点是活动的(可能在获取锁 或者 刚好被唤醒), 才会导致cas修改失败.</p><p>此时<code>node</code>节点有可能获取到锁, 所以需要唤醒node节点的线程.</p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock和ReentrantReadWriteLock源码分析</title>
    <link href="/2022/11/18/juc/reentrantLock_reentrantReadWriteLock/"/>
    <url>/2022/11/18/juc/reentrantLock_reentrantReadWriteLock/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲解ReentrantReadWriteLock和ReentrantLock的实现以及源码分析</p><span id="more"></span><h2 id="ReentrantLock-x2F-ReentrantReadWriteLock"><a href="#ReentrantLock-x2F-ReentrantReadWriteLock" class="headerlink" title="ReentrantLock&#x2F;ReentrantReadWriteLock"></a>ReentrantLock&#x2F;ReentrantReadWriteLock</h2><h3 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h3><blockquote><p>本文主要讲解<code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>锁实现.</p><ul><li><code>ReentrantLock</code>如何实现的可重入锁?</li><li><code>ReentrantReadWriteLock</code>是如何设计的?</li><li><code>ReentrantReadWriteLock</code>读锁数量是如何记录的?</li><li><code>ReentrantReadWriteLock</code>中读锁和写锁的最大数量是多少?</li></ul></blockquote><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p><code>ReentrantLock</code>实现了<code>Lock</code>接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>  <span class="hljs-comment">// 获取锁</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 获取锁, 支持中断</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>  <span class="hljs-comment">// 尝试获取锁, 没有锁时, 直接返回</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 尝试获取锁, 没有锁时, 超时指定时间后返回</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>  <span class="hljs-comment">// 解锁</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 创建一个条件队列</span><br>  Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>该类为<code>ReentrantLock</code>的内部类, 是一个抽象同步器,继承了<code>AQS</code>, 其两个子类<code>NonfairSync</code>和<code>FairSync</code>分别代表了<code>非公平锁</code>和<code>公平锁</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>  <span class="hljs-comment">// 抽象获取锁方法</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 获取状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">// 未持有锁</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 直接cas更新</span><br>      <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 已经持有锁, 重复获取锁(可重入)</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>      <span class="hljs-comment">// 增加操作</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>      <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>      <span class="hljs-comment">// 更新状态</span><br>      setState(nextc);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 释放锁流程</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">// 获取释放锁后的状态值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">// 调用该方法的线程和持有锁的线程不一致</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 只有c等于0, 才真正释放锁. 可重入.</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>      free = <span class="hljs-literal">true</span>;<br>      setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">// 更新状态</span><br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>  &#125;<br>  <span class="hljs-comment">// 忽略其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h4><p>非公平锁实现. 即获取锁时不会立即排队, 而是会先尝试获取锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>  <span class="hljs-comment">// 实现了父类Sync的方法</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 直接cas修改状态, cas成功表明获取锁成功</span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>      <span class="hljs-comment">// 直接设置当前线程</span><br>      setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-comment">// cas失败说明有现成已经抢到锁并修改了state</span><br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 排队AQS提供的方法获取锁</span><br>      acquire(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">// 调用父类Sync的方法获取锁</span><br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h4><p>公平锁实现, 每次获取锁时都会排队, 知道其他线程释放锁并唤醒此线程才会继续抢锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取锁</span><br>    acquire(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 拿到状态值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">// 没有获取到锁</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// hasQueuedPredecessors=false: 表示队列为空 或 当前线程已经在排队. 不能重复入队</span><br>      <span class="hljs-comment">// 然后直接抢锁</span><br>      <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 获取到了锁, 即锁重入</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>      <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>      setState(nextc);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对<code>state</code>状态值的操作来判断锁是否获取, 且把<code>state</code>的值当做锁重入的次数(<code>大于0</code>).</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 同步器, 有非公平和公平两种实现, 默认是非公平</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 默认创建非公平锁</span><br>  sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>  <span class="hljs-comment">// 根据参数创建锁</span><br>  sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>  sync.lock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> sync.nonfairTryAcquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>  sync.release(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到大部分方法都是调用的<code>Sync</code>类中的方法.</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>读写锁</p><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>此接口为<code>ReentrantReadWriteLock</code>实现的接口. 定义了获取<code>读锁</code>和<code>写锁</code>方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br>  <span class="hljs-comment">// 读锁</span><br>  Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 获取写锁</span><br>  Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 默认非公平锁</span><br>  <span class="hljs-built_in">this</span>(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>  sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>  <span class="hljs-comment">// 读锁和写锁共享同一个同步器</span><br>  readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);<br>  writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内部类图"><a href="#内部类图" class="headerlink" title="内部类图"></a>内部类图</h3><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220613_ReentrantReadWriteLock.png" alt="image-20220613144753945" style="zoom:50%;" /><p>可以看到<code>ReentrantReadWriteLock</code>也有<code>公平</code>和<code>非公平</code>的两种模式. </p><h3 id="FairSync-x2F-NonfairSync"><a href="#FairSync-x2F-NonfairSync" class="headerlink" title="FairSync&#x2F;NonfairSync"></a>FairSync&#x2F;NonfairSync</h3><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220613_read_write_sync.png" alt="image-20220613163449700" style="zoom:50%;" /><p>可以看出<code>公平</code>和<code>非公平</code>主要是针对于<code>写锁</code>. 两个子类没有具体的获取锁和释放锁的代码, 全部都在Sync中.</p><h3 id="WriteLock-x2F-ReadLock"><a href="#WriteLock-x2F-ReadLock" class="headerlink" title="WriteLock&#x2F;ReadLock"></a>WriteLock&#x2F;ReadLock</h3><p>写锁代码</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220613_writeLock.png" alt="image-20220613162543592" style="zoom:50%;" /><p>读锁代码</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220613_readLock.png" alt="image-20220613162709108" style="zoom:50%;" /><p>从代码中可以看出, 读锁和写锁的加锁和释放锁的操作都是调用的sync中的方法来完成的. 所以我们重点关注<code>Sync</code>类的实现.</p><h3 id="Sync-1"><a href="#Sync-1" class="headerlink" title="Sync"></a>Sync</h3><p>抽象同步器, 封装了获取&#x2F;释放读锁和写锁相关的代码.</p><h4 id="核心变量"><a href="#核心变量" class="headerlink" title="核心变量"></a>核心变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 共享位移量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_SHIFT</span>   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-comment">// 共享单位</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_UNIT</span>    <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT);<br><span class="hljs-comment">// 低16位最大值 65535</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span>      <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 低16位 标记(即最大的写锁值) 65535</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCLUSIVE_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 线程持有的读锁计数器, 用于计算每个线程持有了多少个读锁.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ThreadLocalHoldCounter readHolds;<br><span class="hljs-comment">// 持有计数器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HoldCounter cachedHoldCounter;<br><br><span class="hljs-comment">// 第一个获取读锁的线程, 用于优化操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">firstReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 第一个线程持有的读锁次数, 用于优化操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> firstReaderHoldCount;<br></code></pre></td></tr></table></figure><p>从<code>SHARED_UNIT</code>和<code>EXCLUSIVE_MASK</code>等变量可以看出, 同步器使用了<code>高16位</code>来存储读锁数量, <code>低16位</code>来存储写锁数量. 且每个<code>读线程</code>持有的<code>读锁数量</code>有各自线程进行管理.</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync() &#123;<br>    readHolds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span>();<br>    setState(getState()); <span class="hljs-comment">// ensures visibility of readHolds</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HoldCounter原理"><a href="#HoldCounter原理" class="headerlink" title="HoldCounter原理"></a>HoldCounter原理</h4><p>该类的实例被每个线程持有, 由ThreadLocal来绑定.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HoldCounter</span> &#123;<br>  <span class="hljs-comment">// 线程ID, 后续用于比对使用</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> getThreadId(Thread.currentThread());<br>  <span class="hljs-comment">// 计数器</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ThreadLocalHoldCounter原理"><a href="#ThreadLocalHoldCounter原理" class="headerlink" title="ThreadLocalHoldCounter原理"></a>ThreadLocalHoldCounter原理</h4><p>ThreadLocal子类, 用于初始化与线程绑定的<code>HoldCounter</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;<br>    <span class="hljs-comment">// 每个线程都会有一个HoldCounter.</span><br>    <span class="hljs-comment">// 即各自线程 记自己可重入的次数</span><br>    <span class="hljs-keyword">public</span> HoldCounter <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HoldCounter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此类在Sync类初始化时被创建.</p><h4 id="tryRelease方法原理"><a href="#tryRelease方法原理" class="headerlink" title="tryRelease方法原理"></a>tryRelease方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>  <span class="hljs-comment">// 独占线程不是当前线程,抛出异常</span><br>  <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>  <span class="hljs-comment">// 计算state</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;<br>  <span class="hljs-comment">// 计算写锁数量</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (free)<span class="hljs-comment">// 重入次数还未到0</span><br>    setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>  <span class="hljs-comment">// 重新设置state</span><br>  setState(nextc);<br>  <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法用于写线程释放锁. 只有当重入的次数为0, 才会将持有锁线程置为空.</p><h4 id="tryAcquire方法原理"><a href="#tryAcquire方法原理" class="headerlink" title="tryAcquire方法原理"></a>tryAcquire方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>  <span class="hljs-comment">// 获取当前线程</span><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>  <span class="hljs-comment">// 写线程数量</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>  <span class="hljs-comment">// 此时有线程获取到了锁, 但是不知道是读锁还是写锁?</span><br>  <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// c != 0 and w == 0 表明一定有线程抢到了读锁(修改了state), 即此时不允许获取写锁</span><br>    <span class="hljs-comment">// w != 0 and current != getExclusiveOwnerThread() 表明其他线程获取到了读锁</span><br>    <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 已经有其他线程获取到了读锁, 直接返回</span><br><br>    <span class="hljs-comment">// w != 0 and current == getExclusiveOwnerThread() 表明其他线程获取到了读锁</span><br>    <span class="hljs-comment">// w == 0 没有线程获取到读锁</span><br>    <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br><br>    <span class="hljs-comment">// 此时就是可重入获取锁, 直接修改数即可</span><br>    setState(c + acquires);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 此时没有线程获取到锁, 所以可以直接获取写锁</span><br>  <span class="hljs-comment">// 在非公平模式下永远是false, 直接修改state变量</span><br>  <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 设置线程</span><br>  setExclusiveOwnerThread(current);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="tryWriteLock方法原理"><a href="#tryWriteLock方法原理" class="headerlink" title="tryWriteLock方法原理"></a>tryWriteLock方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryWriteLock</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 获取当前线程</span><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">// 有线程持有锁</span><br>  <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 写锁数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>    <span class="hljs-comment">// c != 0 and w == 0 表明有线程获取到了读锁, 此时不允许获取写锁</span><br>    <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (w == MAX_COUNT)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!compareAndSetState(c, c + <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  setExclusiveOwnerThread(current);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法和<code>tryAcquire</code>方法差不多, 只不过少了<code>writerShouldBlock</code>方法的调用.  由于其通常被<code>tryLock</code>方法调用. 因此调用线程不用阻塞.</p><h4 id="tryAcquireShared方法原理"><a href="#tryAcquireShared方法原理" class="headerlink" title="tryAcquireShared方法原理"></a>tryAcquireShared方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>  <span class="hljs-comment">// 当前线程</span><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>  <span class="hljs-comment">// 如果已经有线程持有写锁且持有锁线程不是当前线程. 不允许获取读锁</span><br>  <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// 读锁数量</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>    <span class="hljs-comment">// 当前还没有读锁, 则当前线程就是第一个读锁</span><br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>      firstReader = current;<br>      firstReaderHoldCount = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 重复获取读锁</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>      firstReaderHoldCount++; <span class="hljs-comment">// 直接增加计数</span><br>    &#125;<br>    <span class="hljs-comment">// 非第一个获取锁的读锁线程</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>      <span class="hljs-comment">// 为空, 或者不是当前线程绑定的HoldCounter, 则直接初始化一个</span><br>      <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>        cachedHoldCounter = rh = readHolds.get();<br>      <span class="hljs-comment">// 更新当前线程绑定的HoldCounter</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>        readHolds.set(rh);<br>      rh.count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// cas失败 或 r &gt; MAX_COUNT 或 readerShouldBlock=true</span><br>  <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fullTryAcquireShared方法原理"><a href="#fullTryAcquireShared方法原理" class="headerlink" title="fullTryAcquireShared方法原理"></a>fullTryAcquireShared方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullTryAcquireShared</span><span class="hljs-params">(Thread current)</span> &#123;<br>    <span class="hljs-comment">// 执行到此方法的情况: cas修改state失败, readerShouldBlock=true即当前读线程应该阻塞</span><br>    <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">// 有线程持有写锁且非当前线程</span><br>        <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != current)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 直接返回</span><br>        &#125;<br>        <span class="hljs-comment">// 没有线程持有写锁</span><br>        <span class="hljs-comment">// 写锁是否应该被阻塞, 因为同步队列可能已经发生改变</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readerShouldBlock()) &#123;<br>            <span class="hljs-comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span><br>            <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>                <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;</span><br>            &#125;<br>            <span class="hljs-comment">// 当前线程非首个线程</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 操作每个线程的计数器</span><br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span>) &#123;<br>                    rh = cachedHoldCounter;<br>                    <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current)) &#123;<br>                        rh = readHolds.get();<br>                        <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                            readHolds.remove();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 当前线程持有的读锁为0</span><br>                <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 到此的情况: 读锁不应该被阻塞</span><br><br>        <span class="hljs-comment">// 判断最大读锁数</span><br>        <span class="hljs-keyword">if</span> (sharedCount(c) == MAX_COUNT)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br><br>        <span class="hljs-comment">// cas更新状态</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>            <span class="hljs-keyword">if</span> (sharedCount(c) == <span class="hljs-number">0</span>) &#123;<br>                firstReader = current;<br>                firstReaderHoldCount = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>                firstReaderHoldCount++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span>)<br>                    rh = cachedHoldCounter;<br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                    rh = readHolds.get();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                    readHolds.set(rh);<br>                rh.count++;<br>                cachedHoldCounter = rh; <span class="hljs-comment">// cache for release</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看出此方法和<code>tryAcquireShared</code>方法代码类似, 只不过<code>fullTryAcquireShared</code>方法开启了一个循环, 不断的去获取锁.</p><p>可以将<code>tryAcquireShared</code>方法看做读锁的优化操作. 类似于提前尝试一下, 不行在开启循环.</p><h4 id="tryReadLock方法原理"><a href="#tryReadLock方法原理" class="headerlink" title="tryReadLock方法原理"></a>tryReadLock方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReadLock</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 当前线程</span><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-comment">// 循环</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">// 有线程持有了写锁</span><br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>    <span class="hljs-keyword">if</span> (r == MAX_COUNT)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>    <br>    <span class="hljs-comment">// cas修改状态</span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>      <span class="hljs-comment">// cas成功后 修改计数器</span><br>      <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>        firstReader = current;<br>        firstReaderHoldCount = <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>        firstReaderHoldCount++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>        <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>          cachedHoldCounter = rh = readHolds.get();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>          readHolds.set(rh);<br>        rh.count++;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tryReadLock</code>方法相较于<code>fullTryAcquireShared</code>方法只是少了<code>readerShouldBlock</code>调用来判断当前读线程是都应该被阻塞; 由于此方法是在<code>tryLock</code>中调用, 调用线程不应该阻塞. 没有锁直接返回即可, 不用阻塞</p><h4 id="tryReleaseShared方法原理"><a href="#tryReleaseShared方法原理" class="headerlink" title="tryReleaseShared方法原理"></a>tryReleaseShared方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>  <span class="hljs-comment">// 获取到当前线程</span><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-comment">// 当前线程是第一个读取的线程</span><br>  <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>    <span class="hljs-comment">// 对读数量进行减1操作</span><br>    <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)<br>      firstReader = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">else</span><br>      firstReaderHoldCount--;<br>  &#125;<br>  <span class="hljs-comment">// 当前线程非第一个读取的线程</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>    <span class="hljs-comment">// 不为空且线程ID不等</span><br>    <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>      <span class="hljs-comment">// 获取当前线程的HoldCounter</span><br>      rh = readHolds.get();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> rh.count;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// 解除当前线程的HoldCounter</span><br>      readHolds.remove();<br>      <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> unmatchedUnlockException();<br>    &#125;<br>    <span class="hljs-comment">// 反之则count自减1</span><br>    --rh.count;<br>  &#125;<br>  <span class="hljs-comment">// 开启自旋</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>      <span class="hljs-comment">// 读锁和写锁是否都为0</span><br>      <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>ReentrantReadWriteLock</code>巧妙的使用了<code>int</code>变量32位的设计, 将其拆分成两个16位, 低16位存储写锁, 高16位存储读锁. </p><p>由于写锁是互斥的, 所以不用记录. 但是读锁是共享的, 所以需要知道线程获取读锁的次数. </p><p>使用<code>HoldCounter</code>来记录每个线程获取读锁的次数, 且此类实例与获取读锁的线程绑定. 通过<code>ThreadLocalHoldCounter</code>对象实现.</p><p>读锁每次操作状态变量 都是以<code>SHARED_UNIT</code>变量为单位来进行操作. </p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调度线程池源码分析</title>
    <link href="/2022/11/18/juc/scheduled_thread_pool_source_analysis/"/>
    <url>/2022/11/18/juc/scheduled_thread_pool_source_analysis/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲解普通线程池子类调度线程池的源码分析</p><span id="more"></span><h2 id="定时线程池源码分析"><a href="#定时线程池源码分析" class="headerlink" title="定时线程池源码分析"></a>定时线程池源码分析</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><code>ScheduledThreadPoolExecutor</code>继承了ThreadPoolExecutor, 并且可以延迟执行某个任务或定期执行一个任务</p></blockquote><p>类继承图如下</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220528_ScheduledExecutorService_extend.png" alt="image-20220528091007019" style="zoom:50%;" /><h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>作为ScheduledThreadPoolExecutor的父接口, 其定义了<code>schedule</code>等方法来向线程池提交定时任务.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ExecutorService</span> &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 向线程池提交一个任务, 并在指定延迟时间后执行</span><br><span class="hljs-comment">    */</span><br>  ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit);<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 向线程池提交一个任务, 并在指定延迟时间后执行</span><br><span class="hljs-comment">    */</span><br>  &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 向线程池提交一个任务, 并周期性的执行.</span><br><span class="hljs-comment">    * &lt;p&gt;</span><br><span class="hljs-comment">    * preStartTime: 上一次任务执行开始时间</span><br><span class="hljs-comment">    * preEndTime: 上一次任务执行结束时间</span><br><span class="hljs-comment">    * nextTime: 下一次任务执行的时间</span><br><span class="hljs-comment">    * taskTime: task执行的时间</span><br><span class="hljs-comment">    * &lt;p&gt;</span><br><span class="hljs-comment">    * 下次任务触发时间:  preStartTime + delay</span><br><span class="hljs-comment">    * &lt;p&gt;</span><br><span class="hljs-comment">    * 如果 preEndTime &lt; preStartTime + delay, 则preEndTime就是下次任务执行时间</span><br><span class="hljs-comment">    * 如果 preEndTime &gt;= preStartTime + delay, 则延迟 preEndTime - (taskTime + delay) 时间后下次任务将执行</span><br><span class="hljs-comment">    */</span><br>  ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-type">long</span> initialDelay, <br>                                         <span class="hljs-type">long</span> period, TimeUnit unit);<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 向线程池提交一个任务, 并周期性执行.</span><br><span class="hljs-comment">    * &lt;p&gt;</span><br><span class="hljs-comment">    * preStartTime: 上一次任务执行开始时间</span><br><span class="hljs-comment">    * preEndTime: 上一次任务执行结束时间</span><br><span class="hljs-comment">    * nextTime: 下一次任务执行的时间</span><br><span class="hljs-comment">    * &lt;p&gt;</span><br><span class="hljs-comment">    * 下次任务触发时间: nextTime = preEndTime + delay;</span><br><span class="hljs-comment">    */</span><br>  ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-type">long</span> initialDelay, <br>                                            <span class="hljs-type">long</span> delay, TimeUnit unit);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>scheduleAtFixedRate</code>和<code>scheduleWithFixedDelay</code>方法都是提交的周期性任务. 但是两个方法唯一的区别是参考的计算时间点不同. <code>一个是上次任务执行开始时间, 一个是上次任务的执行结束时间</code>. </p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>和ThreadPoolExecutor相比, ScheduledThreadPoolExecutor使用了新的<code>ScheduledFutureTask</code>类来包装向线程池提交的任务, 重写了父类的<code>submit</code>方法.  并且是使用了<code>DelayQueue</code>的变体<code>DelayedWorkQueue</code>来存储任务.</p><h3 id="核心构造函数"><a href="#核心构造函数" class="headerlink" title="核心构造函数"></a>核心构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化调度线程池, 使用DelayedWorkQueue来存储提交的任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>  <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br><br><span class="hljs-comment">// 初始化调度线程池, 指定核心线程数和线程工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;<br>  <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory);<br>&#125;<br><br><span class="hljs-comment">// 初始化调度线程池, 指定核心线程数和拒绝策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, RejectedExecutionHandler handler)</span> &#123;<br>  <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), handler);<br>&#125;<br><br><span class="hljs-comment">// 初始化调度线程池, 指定核心线程数和线程工厂和拒绝策略</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, ThreadFactory threadFactory,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br>  <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出线程池的最大线程数都是<code>Integer.MAX_VALUE</code>, 且空闲线程的存活时间为 0 . 则表明<code>非核心线程存活时间为0, 即没有任务就会退出</code>, 因为 getTask 方法中的 poll 方法很快就会超时. </p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>调度线程池核心方法为: <code>submit</code> 和 <code>schedule</code>两个, 由于调度线程池使用的ScheduledFutureTask, 所以submit方法最终都调用的是<code>schedule</code>方法.</p><h4 id="submit方法原理"><a href="#submit方法原理" class="headerlink" title="submit方法原理"></a>submit方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>  <span class="hljs-keyword">return</span> schedule(task, <span class="hljs-number">0</span>, NANOSECONDS);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>  <span class="hljs-keyword">return</span> schedule(Executors.callable(task, result), <span class="hljs-number">0</span>, NANOSECONDS);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>  <span class="hljs-keyword">return</span> schedule(task, <span class="hljs-number">0</span>, NANOSECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出调度线程池重写了所有的submit方法, 并最终调用了schedule, 但是延迟相关的参数都是0.</p><h4 id="schedule方法原理"><a href="#schedule方法原理" class="headerlink" title="schedule方法原理"></a>schedule方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>  <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <span class="hljs-comment">// 使用 ScheduledFutureTask 包装任务</span><br>  RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,triggerTime(delay, unit)));<br><span class="hljs-comment">// 延迟执行  </span><br>  delayedExecute(t);<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;<br><br>  <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-comment">// 同上, 只是构建的ScheduledFutureTask参数不同</span><br>  RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,                                    <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;V&gt;(callable,triggerTime(delay, unit)));<br>  <span class="hljs-comment">// 同上</span><br>  delayedExecute(t);<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用ScheduledFutureTask对提交的任务进行了封装, 并调用<code>triggerTime</code>方法计算出延迟的时间.</p><p>可以看出核心方法应该存在于<code>delayedExecute</code>中.</p><h4 id="delayedExecute方法原理"><a href="#delayedExecute方法原理" class="headerlink" title="delayedExecute方法原理"></a>delayedExecute方法原理</h4><p>此方法为延迟或周期性执行任务的核心方法. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;<br>  <span class="hljs-comment">// 如果池处于关闭状态, 则直接拒绝任务</span><br>  <span class="hljs-keyword">if</span> (isShutdown())<br>    reject(task);<span class="hljs-comment">// 拒绝任务</span><br>  <span class="hljs-comment">// 池未处于关闭状态</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 现将任务入队</span><br>    <span class="hljs-built_in">super</span>.getQueue().add(task);<br>    <span class="hljs-comment">// 池处于关闭状态</span><br>    <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))<br>      <span class="hljs-comment">// 当前任务不能执行, 且出队成功, 则取消当前任务</span><br>      task.cancel(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 池非关闭状态</span><br>    <span class="hljs-keyword">else</span><br>      ensurePrestart();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意<code>canRunInCurrentRunState</code>方法其判断的条件, 同时了解<code>ensurePrestart</code>方法执行细节.</p><h4 id="ensurePrestart方法原理"><a href="#ensurePrestart方法原理" class="headerlink" title="ensurePrestart方法原理"></a>ensurePrestart方法原理</h4><p>此方法处于ThreadPoolExecutor类中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePrestart</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 获取工作线程数量</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(ctl.get());<br>  <span class="hljs-comment">// 小于核心线程数</span><br>  <span class="hljs-keyword">if</span> (wc &lt; corePoolSize)<br>    <span class="hljs-comment">// 添加核心线程</span><br>    addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>  <span class="hljs-comment">// 工作线程为0</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wc == <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 添加非核心线程</span><br>    addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="scheduleAtFixedRate原理"><a href="#scheduleAtFixedRate原理" class="headerlink" title="scheduleAtFixedRate原理"></a>scheduleAtFixedRate原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-type">long</span> initialDelay, <br>                                              <span class="hljs-type">long</span> period, TimeUnit unit) &#123;<br>  <span class="hljs-comment">// 忽略参数校验</span><br><br>  <span class="hljs-comment">// 使用ScheduledFutureTask包装任务</span><br>  ScheduledFutureTask&lt;Void&gt; sft =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(initialDelay, unit), <br>                                  unit.toNanos(period));<br><br>  RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<br><br>  <span class="hljs-comment">// </span><br>  sft.outerTask = t;<br><span class="hljs-comment">// 同上</span><br>  delayedExecute(t);<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="scheduleWithFixedDelay原理"><a href="#scheduleWithFixedDelay原理" class="headerlink" title="scheduleWithFixedDelay原理"></a>scheduleWithFixedDelay原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-type">long</span> initialDelay,<br>                                                 <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>  <span class="hljs-comment">// 忽略参数校验</span><br><br>  <span class="hljs-comment">// 使用ScheduledFutureTask包装任务</span><br>  ScheduledFutureTask&lt;Void&gt; sft =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(initialDelay, unit),<br>                                  unit.toNanos(-delay));<br>  <br>  RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<br>  sft.outerTask = t;<br>  delayedExecute(t);<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>scheduleAtFixedRate和scheduleWithFixedDelay代码大致相同, 只是构建ScheduledFutureTask的参数有所差异.</p><h4 id="triggerTime方法原理"><a href="#triggerTime方法原理" class="headerlink" title="triggerTime方法原理"></a>triggerTime方法原理</h4><p>该方法用于计算出周期性任务的执行时间, 此方法在<code>schedule</code>也有用调用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造函数调用此方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">triggerTime</span><span class="hljs-params">(<span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;<br>  <span class="hljs-keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : delay));<br>&#125;<br></code></pre></td></tr></table></figure><p>调用下面的重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">triggerTime</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;<br>  <span class="hljs-comment">// 根据当前时间计算出延迟时间</span><br>  <span class="hljs-keyword">return</span> now() +<br>    ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>)) ? delay : overflowFree(delay));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">overflowFree</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;<br>  <span class="hljs-comment">// 获取到任务队列的头</span><br>  <span class="hljs-type">Delayed</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> (Delayed) <span class="hljs-built_in">super</span>.getQueue().peek();<br>  <span class="hljs-comment">// 头不为空</span><br>  <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 获取到任务延迟</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">headDelay</span> <span class="hljs-operator">=</span> head.getDelay(NANOSECONDS);<br>    <span class="hljs-comment">// 使延迟时间大于Long.MAX_VALUE, 避免compareTo计算溢出</span><br>    <span class="hljs-keyword">if</span> (headDelay &lt; <span class="hljs-number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="hljs-number">0</span>))<br>      delay = Long.MAX_VALUE + headDelay;<br>  &#125;<br>  <span class="hljs-keyword">return</span> delay;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此可以看出所有 schedule 开头的方法都是先构建ScheduledFutureTask对象, 然后在 <code>delayedExecute</code>方法将构建好的任务提交到线程池并添加一个Worker. </p><h3 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h3><p>看完池的任务提交代码, 可以知道池的核心逻辑在父类ThreadPoolExecutor已经实现好了, 唯一需要了解的就是ScheduledFutureTask, 此类决定了任务的执行逻辑, 和执行时间.</p><p>此类类似于FutureTask.</p><h4 id="核心变量"><a href="#核心变量" class="headerlink" title="核心变量"></a>核心变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 序列号用于打断FIFO</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequenceNumber;<br><br><span class="hljs-comment">// 重复执行任务的周期, 单位纳秒.</span><br><span class="hljs-comment">// 正数表示固定周期执行, 负数表示固定延迟执行. 0 标识非周期性任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> period;<br><br><span class="hljs-comment">// 下一个周期需要入队的任务</span><br>RunnableScheduledFuture&lt;V&gt; outerTask = <span class="hljs-built_in">this</span>;<br><br><span class="hljs-comment">// 延迟队列中的索引, 用于支持快速取消</span><br><span class="hljs-type">int</span> heapIndex;<br><br><span class="hljs-comment">// 任务开始执行的时间</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<br></code></pre></td></tr></table></figure><h4 id="核心构造函数-1"><a href="#核心构造函数-1" class="headerlink" title="核心构造函数"></a>核心构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> ns) &#123;<br>  <span class="hljs-built_in">super</span>(r, result);<br>  <span class="hljs-built_in">this</span>.time = ns;<br>  <span class="hljs-built_in">this</span>.period = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();<br>&#125;<br><br>ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> ns, <span class="hljs-type">long</span> period) &#123;<br>  <span class="hljs-built_in">super</span>(r, result);<br>  <span class="hljs-built_in">this</span>.time = ns;<br>  <span class="hljs-built_in">this</span>.period = period;<br>  <span class="hljs-built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();<br>&#125;<br><br>ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> ns) &#123;<br>  <span class="hljs-built_in">super</span>(callable);<br>  <span class="hljs-built_in">this</span>.time = ns;<br>  <span class="hljs-built_in">this</span>.period = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h4><h5 id="run方法原理"><a href="#run方法原理" class="headerlink" title="run方法原理"></a>run方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 是否是周期性执行任务</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<br>  <span class="hljs-comment">// 当前池状态能否执行周期</span><br>  <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<br>    <span class="hljs-comment">// 不能则取消任务</span><br>    cancel(<span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">// 不能周期执行</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>    <span class="hljs-comment">// 调用父类</span><br>    ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();<br>  <span class="hljs-comment">// 可以周期性执行</span><br>  <span class="hljs-comment">// runAndReset 此方法只会执行Future但是不会设置结果</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>    setNextRunTime();   <span class="hljs-comment">// 设置下一次运行时间</span><br>    reExecutePeriodic(outerTask);   <span class="hljs-comment">// 再次执行周期任务</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="setNextRunTime方法原理"><a href="#setNextRunTime方法原理" class="headerlink" title="setNextRunTime方法原理"></a>setNextRunTime方法原理</h5><p>设置Task下次执行的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;<br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)  <span class="hljs-comment">// 固定周期执行</span><br>        time += p;  <span class="hljs-comment">// 替换下次task执行时间</span><br>    <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 固定延迟周期执行</span><br>        time = triggerTime(-p);     <span class="hljs-comment">// 根据当前时间计算出下次延迟的时间, 此时任务已经执行完成</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h3><p>此队列用来存储向调度线程池提交的任务. 底层使用数组来存储任务, 并将任务在数组中的索引存储在任务中.</p><h4 id="核心变量-1"><a href="#核心变量-1" class="headerlink" title="核心变量"></a>核心变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;Runnable&gt;<br>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;Runnable&gt; &#123;<br><br>  <span class="hljs-comment">// 初始化容量</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>  <span class="hljs-comment">// 任务数组</span><br>  <span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;?&gt;[<span class="hljs-number">16</span>];<br>  <span class="hljs-comment">// 锁</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>  <span class="hljs-comment">// 数组大小</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 阻塞在队列的第一个线程</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">leader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 当队列头部有新任务可用或新线程可能需要成为领导者时发出条件信号</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="核心方法-2"><a href="#核心方法-2" class="headerlink" title="核心方法"></a>核心方法</h4><p>在线程池的源码分析中, 我们知道了线程池操作队列的基本方法: </p><ul><li>offer: 向队列中添加任务</li><li>poll: 超时阻塞获取队列中的任务</li><li>take: 阻塞获取队列中的任务</li><li>remove: 删除队列中的任务</li></ul><p>所以重点关注这几个方法.</p><h5 id="offer方法原理"><a href="#offer方法原理" class="headerlink" title="offer方法原理"></a>offer方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Runnable x)</span> &#123;<br>  <span class="hljs-comment">// 忽略参数非空校验</span><br>  <br>  RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>  lock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-comment">// 数组容量太小</span><br>    <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>      <span class="hljs-comment">// 重新计算数组大小</span><br>      grow();             <br><br>    size = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 第一次添加</span><br>      queue[<span class="hljs-number">0</span>] = e;<br>      setIndex(e, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 非第一次添加</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 入队, 该方法从数组的后面向前找, 会对数组中任务的延迟时间进行排序</span><br>      <span class="hljs-comment">// 避免任务延迟时间到了, 但是未执行的情况.</span><br>      siftUp(i, e);<br>    &#125;<br>    <span class="hljs-comment">// 任务处于第一个</span><br>    <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;<br>      leader = <span class="hljs-literal">null</span>;<br>      available.signal();     <span class="hljs-comment">// 唤醒等待的线程, 调用take</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="poll方法原理"><a href="#poll方法原理" class="headerlink" title="poll方法原理"></a>poll方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="hljs-type">long</span> timeout, TimeUnit unit)<br>  <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>  <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>  <span class="hljs-comment">// 可中断</span><br>  lock.lockInterruptibly();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 获取数组头的任务</span><br>      RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];<br>      <span class="hljs-comment">// 为空, 表示数组中无任务</span><br>      <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 等待指定时间</span><br>        <span class="hljs-keyword">else</span><br>          nanos = available.awaitNanos(nanos);<br>      &#125;<br>      <span class="hljs-comment">// 不为空</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获取到任务的延迟时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>        <span class="hljs-comment">// 可以立即执行</span><br>        <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">return</span> finishPoll(first);<br>        <span class="hljs-comment">// 延迟时间未到就已经超时了</span><br>        <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        first = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 超时时间小于延迟时间, 或者 超时时间大于延迟时间且等待线程已经存在</span><br>        <span class="hljs-keyword">if</span> (nanos &lt; delay || leader != <span class="hljs-literal">null</span>)<br>          <span class="hljs-comment">// 延迟等待</span><br>          nanos = available.awaitNanos(nanos);<br>        <span class="hljs-comment">// 超时时间大于延迟时间且等待线程不存在, 则将当前线程设置上</span><br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>          <span class="hljs-comment">// 复制</span><br>          leader = thisThread;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 阻塞延迟时长</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">timeLeft</span> <span class="hljs-operator">=</span> available.awaitNanos(delay);<br>            <span class="hljs-comment">// 重新计算超时时间</span><br>            nanos -= delay - timeLeft;<br>          &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (leader == thisThread)<br>              leader = <span class="hljs-literal">null</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 没有等待头线程,且队列头任务不为空</span><br>    <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)<br>      available.signal();     <span class="hljs-comment">// 唤醒一个等待线程</span><br>    lock.unlock();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在线程池的<code>runWorker</code>源码中, 只有当工作线程大于核心线程数时才会使用poll方法来超时获取任务.</p><p>而此方法的逻辑, 则是开启循环, 不断计算任务的延迟时间, 当任务的延迟时间到了, 则出队. 反之则一直循环.  </p><h5 id="take方法原理"><a href="#take方法原理" class="headerlink" title="take方法原理"></a>take方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>  lock.lockInterruptibly();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 获取到队列中的头任务</span><br>      RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 为空则阻塞调用线程</span><br>        available.await();<br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 不为空,则获取到任务的延迟时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>        <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)<br>          <span class="hljs-comment">// 延迟时间已过, 直接获取任务</span><br>          <span class="hljs-keyword">return</span> finishPoll(first);<br>        <span class="hljs-comment">// 延迟时间未过</span><br>        first = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)<br>          <span class="hljs-comment">// 已经有线程在等待了,则阻塞当前线程</span><br>          available.await();<br>        <span class="hljs-comment">// 没有线程等待</span><br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>          leader = thisThread;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 延迟指定时间</span><br>            available.awaitNanos(delay);<br>          &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 线程被唤醒后, 如果相等</span><br>            <span class="hljs-keyword">if</span> (leader == thisThread)<br>              leader = <span class="hljs-literal">null</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)<br>      available.signal(); <span class="hljs-comment">// 唤醒一个等待线程</span><br>    lock.unlock();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>take方法和poll比较类似, 只是判断的条件少了很多.</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>调度线程池复用了很多线程池的代码. 特别注意在初始化调度线程池时部分参数的特殊性. 且是使用的队列和普通线程池不同.</p><p>调度线程池执行的任务由 <code>ScheduledFutureTask</code> 封装, 且如果任务为周期性任务, 则任务的再次入队操作在 <code>run</code> 方法中完成提交. 同时使用了 <code>time</code> 和 <code>period</code> 变量来分别存储<code>任务的执行时间</code>和<code>任务执行间隔</code>.</p><p>调度线程池使用 <code>DelayedWorkQueue</code> 来存储提交的任务, 底层使用数组结构. 并且在 <code>poll</code> 和 <code>take</code> 方法中不断读取 <code>ScheduledFutureTask</code> 的延迟时间以便执行此任务(循环+条件队列). 同时可以使用 <code>offer</code> 方法将任务入队, 同时唤醒等待的线程和对队列中的任务进行排序. <code>(保证任务能够执行)</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AbstractQueuedSynchronizer 解析</title>
    <link href="/2022/11/18/thread/aqs-source-code-resolve/"/>
    <url>/2022/11/18/thread/aqs-source-code-resolve/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲述 Java 中 Juc 包下的 AbstractQueuedSynchronizer<br>主要讲述 AQS 的设计及其独占模式和共享模式的获取和释放流程</p><span id="more"></span><h2 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h2><blockquote><p>本章主要讲述 JUC 包下的 AQS 的设计与现实, 同时了解 AQS 中独占和共享模式的运转原理和机制</p><ol><li>AQS 的设计和实现</li><li>AQS 中队列介绍及其变体</li><li>AQS 中独占和共享模式的源代码分析</li></ol></blockquote><h2 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h2><p>此类为AbstractQueuedSynchronizer的父类,  一个同步器框架有可能在一个时刻被某一个线程独占，<code>AbstractOwnableSynchronizer</code>就是为所有的同步器实现和锁相关实现提供了基础的保存、获取和设置独占线程的功能.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个线程可以独占的同步器,  此类提供了创建锁和相关的同步器（可能涉及所有权概念）的基础</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * AbstractOwnableSynchronizer 类本身并不管理或使用此信息。 </span><br><span class="hljs-comment"> * 但是，子类和工具可以使用适当维护的值来帮助控,制和监视访问并提供诊断。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">3737899427754241961L</span>;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractOwnableSynchronizer</span><span class="hljs-params">()</span> &#123; &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 独占模式同步的当前所有者</span><br><span class="hljs-comment">    */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置当前拥有独占访问权的线程</span><br><span class="hljs-comment">    * null参数表示没有线程拥有访问权限, 否则, 此方法不会强加任何同步或&#123;<span class="hljs-doctag">@code</span> volatile&#125;字段访问</span><br><span class="hljs-comment">    */</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> &#123;<br>    exclusiveOwnerThread = thread;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getExclusiveOwnerThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> exclusiveOwnerThread;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a><code>AbstractQueuedSynchronizer</code></h2><p>Juc 包下的多数同步器都是基于<code>AbstractQueuedSynchronizer（简称 AQS）</code>框架实现的，AQS为<code>同步状态</code>的<code>原子性管理</code>、<code>线程的阻塞</code>和<code>解除阻塞</code>以及<code>排队</code>提供了一种通用的机制。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>同步器一般包含两种方法，一种是<code>acquire</code>，另一种是<code>release</code>。acquire操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而release操作则是通过某种方式改变同步状态，使得一或多个被acquire阻塞的线程继续执行。</p><p>但是 Juc 包中不同的同步器其相应的 API 页不相，<code>Lock.lock，Semaphore.acquire，CountDownLatch.await</code>（但本质都是<code>acquire</code>或<code>release</code>操作），但都支持下面的操作：</p><ul><li>阻塞和非阻塞同步</li><li>可选的超时设置，让调用者可以放弃等待</li><li>通过中断实现任务取消，通常分为两个版本，一个<code>acquire</code>可取消，而另一个不可以。</li></ul><p>同步器的实现根据其状态分为两种：<code>独占状态</code>和<code>共享状态</code>。</p><ul><li>独占状态：同步器在同一时间允许一个线程执行（<code>Lock</code>）</li><li>共享状态：同步器在同一时间允许多个线程执行（<code>Semaphore</code>）</li></ul><h3 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h3><p><code>acquire</code>和<code>release</code>简单的伪代码实现：</p><p><code>acquire</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (synchronization state does not allow acquire) &#123;<br>    enqueue current thread <span class="hljs-keyword">if</span> not already queued;<br>    possibly block current thread;<br>&#125;<br>dequeue current thread <span class="hljs-keyword">if</span> it was queued;<br></code></pre></td></tr></table></figure><p><code>release</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">update synchronization state;<br><span class="hljs-keyword">if</span> (state may permit a blocked thread to acquire)<br>    unblock one or more queued threads;<br></code></pre></td></tr></table></figure><p>实现上面的操作，需要下面三个操作：</p><ul><li>同步状态的原子性管理；</li><li>线程的阻塞与解除阻塞；</li><li>队列的管理；</li></ul><h4 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h4><p>AQS类使用单个<code>int</code>（32位）来保存同步状态，并暴露出<code>getState</code>、<code>setState</code>以及<code>compareAndSet</code>操作来读取和更新这个状态。</p><p>基于AQS的具体实现类必须根据暴露出的状态相关的方法定义<code>tryAcquire</code>和<code>tryRelease</code>方法，以控制<code>acquire</code>和<code>release</code>操作。当同步状态满足时，<code>tryAcquire</code>方法必须返回<code>true</code>，而当新的同步状态允许后续<code>acquire</code>时，<code>tryRelease</code>方法也必须返回<code>true</code>。这些方法都接受一个<code>int</code>类型的参数用于传递想要的状态。</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>Juc包中提供了一个<code>LockSupport</code>类，其<code>LockSupport.park</code>和<code>LockSupport.unpark</code>用于替换传统的 <code>Thread.suspend</code>和 <code>Thread.resume</code>（同一产生死锁），<code>LockSupport.unpark</code>方法被提前调用也是可以的。</p><p><code>LockSupport.unpark</code>的调用是没有被计数的，因此在一个<code>park</code>调用前多次调用<code>unpark</code>方法只会解除一个<code>park</code>操作。</p><p>另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可能有“剩余的”<code>unpark</code>操作。</p><p>但是，在缺少一个<code>unpark</code>操作时，下一次调用<code>park</code>就会阻塞。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的FIFO队列，因此，框架不支持基于优先级的同步。</p><p>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，已知 MCS 和 CLH 两种锁队列，但在 AQS 中使用了 CLH 锁队列，因为CLH 更容易实现<code>超时</code>和<code>取消</code>功能。AQS 基于 CLH 进行了修改和 CLH有较大的出入。</p><p><img src="http://ifeve.com/wp-content/uploads/2013/01/CLHNode.png"></p><p>第一个对CLH队列主要的修改是添加了 next 字段，来用于唤醒后继节点</p><p>第二个对CLH队列主要的修改是将每个节点都有的状态字段用于控制阻塞而非自旋。</p><p>而AQS中同步队列的基础实现是其内部类<code>Node</code></p><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><br>  <span class="hljs-comment">// 标记共享模式</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br><br>  <span class="hljs-comment">// 标记排他模式</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 取消状态</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//表示后续节点需要释放</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// 节点出去等待状态</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br><br>  <span class="hljs-comment">// 下一个acquireShared应该无条件传播</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment">// 状态字段</span><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>  <br>  <span class="hljs-comment">// 前继节点, 在入队期间分配，并且仅在出队时将其清空, 前置节点取消时, 会短路</span><br>  <span class="hljs-keyword">volatile</span> Node prev;<br><br>  <span class="hljs-comment">// 前继节点, 在排队过程中分配，在绕过取消的前任对象时进行调整，并在出队时清零</span><br>  <span class="hljs-comment">// 被取消节点的next字段设置为指向节点本身而不是null</span><br>  <span class="hljs-keyword">volatile</span> Node next;<br><br>  <span class="hljs-comment">// 使该节点排队的线程。在构造上初始化，使用后消失</span><br>  <span class="hljs-keyword">volatile</span> Thread thread;<br><br>  <span class="hljs-comment">// 链接到等待条件的下一个节点，或者链接到特殊值SHARED</span><br>  <span class="hljs-comment">// 由于条件队列仅在以独占模式保存时才被访问，因此我们只需要一个简单的链接队列即可在节点等待条件时保存节点。</span><br>  <span class="hljs-comment">// 然后将它们转移到队列中以重新获取</span><br>  <span class="hljs-comment">// 由于条件只能是互斥的，因此我们使用特殊值来表示共享模式来保存字段</span><br>  <span class="hljs-comment">// 下一个等待节点</span><br>  Node nextWaiter;<br><br>  Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>  &#125;<br><br>  Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span><br>    <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>    <span class="hljs-built_in">this</span>.thread = thread;<br>  &#125;<br><br>  Node(Thread thread, <span class="hljs-type">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br>    <span class="hljs-built_in">this</span>.waitStatus = waitStatus;<br>    <span class="hljs-built_in">this</span>.thread = thread;<br>  &#125;<br><br>  <span class="hljs-comment">// 返回ture表示当前节点处于共享模式等待</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>  &#125;<br><br>  <span class="hljs-comment">// 返回前一个节点, 如果为null抛出空指针异常</span><br>  <span class="hljs-keyword">final</span> Node <span class="hljs-title function_">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> prev;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>waitStatus</code>的取值:</p><ul><li><code>CANCELLED</code>: 由于超时或中断导致该节点被取消,被取消节点的线程永远不会再次阻塞</li><li><code>CONDITION</code>: 该节点当前在<code>条件队列</code>中, 在传输之前, 它不会用作<code>同步队列</code>节点, 此时状态将设置为<code>0</code>.</li><li><code>SIGNAL</code>: 当前节点的后继节点被阻塞, 如果当前节点释放或取消时必须唤醒其后继节点</li><li><code>PROPAGATE</code>:  此状态值通常只设置到调用了<code>doReleaseShared()</code>方法的头节点，确保<code>releaseShared()</code>方法的调用可以传播到其他的所有节点，简单理解就是共享模式下节点释放的传递标记。</li></ul><p>非负值表示节点不需要发信号, 对于常规同步节点，该字段初始化为0, 对于条件节点，该字段初始化为CONDITION<br>使用CAS对其进行修改</p><p><code>nextWaiter</code>该字段字面意思是:下一个等待节点，其实有三个取值:</p><ul><li><code>Node.EXCLUSIVE</code>: 独占模式</li><li><code>Node.SHARED</code>: 共享模式</li><li>其他值: <strong>代表Condition等待队列中当前节点的下一个等待节点</strong></li></ul><h2 id="队列变体"><a href="#队列变体" class="headerlink" title="队列变体"></a>队列变体</h2><p>知道了AQS 的队列是使用的CLH队列的变体, 所以有必要看看 CLH 和 MCS 两个队列.</p><h3 id="CLH-锁队列"><a href="#CLH-锁队列" class="headerlink" title="CLH 锁队列"></a>CLH 锁队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_CLH_Lock</span> &#123;<br><br>  <span class="hljs-keyword">final</span> AtomicReference&lt;Node&gt; tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>());<br>  <span class="hljs-keyword">final</span> ThreadLocal&lt;Node&gt; current;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">_CLH_Lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.current = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Node&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> Node <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        System.out.println(<span class="hljs-string">&quot;构造器: &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;-&quot;</span> + node);<br>        <span class="hljs-keyword">return</span> node;<br>      &#125;<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">_CLH_Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">_CLH_Lock</span>();<br><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        lock.lock();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;获取到了锁&quot;</span>);<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;释放到了锁&quot;</span>);<br>        lock.unlock();<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;线程 A&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;线程 B&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;线程 C&quot;</span>).start();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">own</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.current.get();<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-&quot;</span> + own);<br>    own.locked = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> tail.getAndSet(own);<br><br>    <span class="hljs-keyword">while</span> (preNode.locked) &#123;<br>      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始自旋....&quot;</span>);<br>      TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    current.get().locked = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>CLH 队列类似于一个伪链表，每个线程在通过 CAS 操作替换 <code>tail</code> 节点引用后，拿到上一个线程节点引用，不断循环检测该线程节点中的 blocked 字段（这个操作就是自旋）。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20200831111943196.png"></p><h3 id="MCS锁队列"><a href="#MCS锁队列" class="headerlink" title="MCS锁队列"></a>MCS锁队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_MCS_Lock</span> &#123;<br><br>  <span class="hljs-keyword">final</span> AtomicReference&lt;Node&gt; tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-literal">null</span>);<br>  ThreadLocal&lt;Node&gt; current;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">_MCS_Lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.current = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Node&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> Node <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>      &#125;<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">own</span> <span class="hljs-operator">=</span> current.get();<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> tail.getAndSet(own);<br><br>    <span class="hljs-keyword">if</span> (Objects.nonNull(preNode)) &#123;<br>      preNode.next = own;<br>      own.locked = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">while</span> (own.locked) &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始自旋....&quot;</span>);<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">own</span> <span class="hljs-operator">=</span> current.get();<br>    <span class="hljs-keyword">if</span> (Objects.isNull(own.next)) &#123;<br>      <span class="hljs-comment">// CAS操作失败，说明当前节点后面新加入了节点</span><br>      <span class="hljs-keyword">if</span> (tail.compareAndSet(own, <span class="hljs-literal">null</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">// 条件不成立，执行下面的解锁流程代码</span><br>      <span class="hljs-keyword">while</span> (own.next == <span class="hljs-literal">null</span>) &#123;<br>      &#125;<br>    &#125;<br>    own.next.locked = <span class="hljs-literal">false</span>;<br>    own.next = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">volatile</span> Node next;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> locked;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">_MCS_Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">_MCS_Lock</span>();<br><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        lock.lock();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;获取到了锁&quot;</span>);<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;释放到了锁&quot;</span>);<br>        lock.unlock();<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;线程 A&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;线程 B&quot;</span>).start();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;线程 C&quot;</span>).start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>MCS 是一个真正的链表通过 <code>next</code> 字段来关联下一个线程节点，但是相对于 CLH 它的 CAS 操作多了</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20200831144343389.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CLH 适用于SMP 系统架构，不适用于NUMA架构(内存分隔)，如果前一个节点的内存过远会导致性能下降。</p><p>CLH 对比 MCS: </p><p>（1）从代码实现来看，CLH比MCS要简单得多。</p><p>（2）从自旋的条件来看，CLH依靠前驱节点自旋，而MCS是依靠自身自旋。</p><p>（3）从链表队列来看，CLH的队列是隐式的，MCS的队列是物理存在的，通过 next 字段。</p><p>（4）CLH 锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。</p><p>（5）CLH 适合CPU个数不多的计算机硬件架构上，MCS则适合拥有很多CPU的硬件架构上</p><p>（6）CLH和MCS实现的自旋锁都是不可重入的</p><h2 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h2><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-comment">// 如果tryAcquire获取失败, 且添加队列</span><br>  <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>    selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>acquire</code>方法在独占模式下修改<code>同步状态</code>, 会至少调用一次<code>tryAcquire</code>方法, 如果<code>tryAcquire</code>返回<code>true</code>代表状态修改成功, 反之则尝试调用<code>acquireQueued</code>方法入队. </p><p><code>addWaiter</code>是入队操作, 而<code>acquireQueued</code>则是从队列中获取操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 获取到 tail 节点, 如果不为空,则调用 cas 将 node 入队</span><br><span class="hljs-comment">// 2. 如果为空,则调用 enq 方法初始化队列,且将 node 节点入队</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>  <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>  <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>  <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>    node.prev = pred;<br>    <span class="hljs-comment">// 入队操作</span><br>    <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>      pred.next = node;<br>      <span class="hljs-keyword">return</span> node;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 队列为空,则进行初始化</span><br>  enq(node);<br>  <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h4><p>在调用<code>addWaiter</code>进行入队操作时, 可能会出现队列为初始化的情况, 即<code>pred == null</code>.此时调用了 <code>enq</code> 来对队列进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果为空,则进行处处华</span><br>      <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>        tail = head;<br>    &#125; <br>    <span class="hljs-comment">// 不为空</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      node.prev = t; <span class="hljs-comment">// 先设置尾节点的前置节点,保证队列的完整性</span><br>      <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="hljs-comment">// 在 CAS 设置尾节点</span><br>        t.next = node;<br>        <span class="hljs-keyword">return</span> t;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自旋获取"><a href="#自旋获取" class="headerlink" title="自旋获取"></a>自旋获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 入队成功后,再次从队列中获取锁</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// step1: 获取到当前节点的前置节点</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>      <span class="hljs-comment">// step2: 如果前置节点是头节点,则说明前置节点已经获取到锁, 且再次调用tryAcquire方法获取锁</span><br>      <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>        <span class="hljs-comment">// 成功,说明前置节点已经释放了搜</span><br>        setHead(node);<br>        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>        failed = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> interrupted;<br>      &#125;<br>      <span class="hljs-comment">// step3: 此时前置节点可能还未释放锁, 则判断是否应该阻塞当前节点</span><br>      <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>        interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (failed)<br>      cancelAcquire(node);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在自旋时, 前置节点的状态: </p><ol><li>waitStatus&#x3D;0: 说明当前节点可以继续自旋, 说不定下次自旋就能获取到锁</li><li>waitStatus&gt;0: 说明前置节点已经取消, 更新当前节点的前置节点, 并进行下次自旋</li><li>waitStatus&lt;0: 说明当前节点可以阻塞, 这个状态可能是当前节点在执行<code>shouldParkAfterFailedAcquire</code>修改的.</li></ol><h4 id="获取失败后更新状态"><a href="#获取失败后更新状态" class="headerlink" title="获取失败后更新状态"></a>获取失败后更新状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>  <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) <span class="hljs-comment">// 前置状态为 SIGNAL,说明当前节点需要被唤醒, 可以安全的的被阻塞</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回 true,则会执行 parkAndCheckInterrupt 方法</span><br><br>  <span class="hljs-comment">// 大于 0,说明前置节点已经取消, 则从前置节点向前查找,直到遇到未取消的节点,</span><br>  <span class="hljs-comment">// 将当前节点的 prev 指向为取消的节点</span><br>  <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-comment">// 寻找未取消的前置节点</span><br>      node.prev = pred = pred.prev;<br>    &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 更新当前节点的 prev</span><br>    pred.next = node;<br>  &#125; <br>  <span class="hljs-comment">// 此时状态只能是 0 或 PROPAGATE, 表明当前节点需要一个唤醒信号</span><br>  <span class="hljs-comment">// 而 PROPAGATE 是在共享模式下使用的, CONDITION 则是在条件队列中时的状态</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 将前置节点状态更新成 SINGAL</span><br>    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当前节点的唤醒是保存在前置节点中的</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 头节点不为空,且状态不等于0</span><br>      unparkSuccessor(h);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 唤醒后续节点</span><br><span class="hljs-comment">// 回顾获取的代码, 在后续节点获取失败后可能会修改前置节点的状态(shouldParkAfterFailedAcquire方法)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br><br>  <span class="hljs-comment">// 如果状态为正数(可能需要唤醒)</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>  <span class="hljs-comment">// 此时waitStatus是SINGAL,</span><br>  <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>    compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>); <span class="hljs-comment">// 更新成 0, 利于后续节点获取锁</span><br><br>  <span class="hljs-comment">// 后继节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>  <span class="hljs-comment">// 疑问: 后继节点为 null 或已取消为啥还要从尾节点开始遍历</span><br>  <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>    s = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 当上面判断成立时的一瞬间, 可能有新节点入队了, 这么做就是为了避免新节点的加入,而被忽略</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>      <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>        s = t;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>    <span class="hljs-comment">// 解锁后继线程</span><br>    LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后继节点状态"><a href="#后继节点状态" class="headerlink" title="后继节点状态"></a>后继节点状态</h4><p>在执行释放时, 后继节点可能处于以下几种状态:</p><ol><li>已经阻塞.</li><li>还在<code>acquireQueued</code>方法中执行自旋,还未阻塞.</li><li>已经取消.</li></ol><h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><p>在<code>unparkSuccessor</code>中将当前节点的状态更新成了 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>    compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>而后继节点在获取失败后可能在执行 spaf 将前置节点置为 SIGNAL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br></code></pre></td></tr></table></figure><p><strong>为什么这是个优化操作呢?</strong></p><p>假设队列 : <code>A -&gt; B -&gt; C</code></p><p>假设 B 已经自旋了一次(获取失败), 调用<code>spaf</code>方法将 A 的状态设置成了 SIGNAL, 进行下一次自旋, 此时 A 会有两种操作:</p><ol><li>调用release方法, 此时 A 的状态会变成 0, B 在下一次自旋后发现 A 的状态变成了 0, 则会继续自旋</li><li>未调用release方法, 此时 A 的状态还是 SIGNAL(被 B 修改的), 此时 B 在下一次自旋后就可以被阻塞了</li></ol><p>这样可以加速锁的获取, 避免了一次没必要的 park. </p><h3 id="取消获取"><a href="#取消获取" class="headerlink" title="取消获取"></a>取消获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>  <span class="hljs-comment">// 为空忽略</span><br>  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">return</span>;<br><br>  node.thread = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 线程置为空</span><br><br><span class="hljs-comment">// 跳过取消的节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>  <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>    node.prev = pred = pred.prev;<br><br><span class="hljs-comment">// 获取点未取消前置节点的前置节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br><br><span class="hljs-comment">// 修改 ws</span><br>  node.waitStatus = Node.CANCELLED;<br><br><span class="hljs-comment">// 如果是尾节点,则直接 CAS 更新</span><br>  <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>    compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);<br>  &#125; <br>  <span class="hljs-comment">// 非尾节点</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span><br>    <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span><br>    <span class="hljs-type">int</span> ws;<br>    <span class="hljs-keyword">if</span> (pred != head &amp;&amp;  <span class="hljs-comment">// 前置节点不是头节点</span><br>        ((ws = pred.waitStatus) == Node.SIGNAL || <span class="hljs-comment">// pred.ws = SIGNAL</span><br>         (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; <span class="hljs-comment">// </span><br>        pred.thread != <span class="hljs-literal">null</span>) &#123;<br>      <br>      <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next; <span class="hljs-comment">// 获取当前节点的后继节点</span><br><br>      <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// 后继节点有效</span><br>        compareAndSetNext(pred, predNext, next); <span class="hljs-comment">// 将 pred 前置节点的 next 修改成 node.next</span><br>    &#125; <br>    <span class="hljs-comment">// 1. pred 为头节点s</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      unparkSuccessor(node);  <span class="hljs-comment">// 解锁后继者</span><br>    &#125;<br><br>    node.next = node; <span class="hljs-comment">// help GC</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h2 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h2><p>共享模式下的<code>获取</code>和<code>释放</code>和独占模式有一些区别, 共享模式下,锁是可以被多个线程锁持有的.</p><p>下面的会涉及到源代码的分析, 再看每行代码时, 都要记住一点:<code>所有的方法都有可能并发执行</code></p><h3 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>    doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tryAcquireShared</code>返回值有以下几种情况:</p><ul><li><code>&lt;0</code>: 表示获取失败</li><li><code>=0</code>:表示获取成功,但是后继节点不能获取成功</li><li><code>&gt;0</code>:表示获取成功</li></ul><h4 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a><code>doAcquireShared</code></h4><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行共享获取操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-comment">// step1: 入队</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// step2: 前继节点</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>      <span class="hljs-keyword">if</span> (p == head) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>        <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// step2.1: 设置头节点并传播</span><br>          setHeadAndPropagate(node, r);<br>        &#125;<span class="hljs-comment">// 忽略部分代码</span><br>      &#125;<br><span class="hljs-comment">// step3: 修改当前节点状态,并根据状态阻塞</span><br>      <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>        interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (failed)<br>      cancelAcquire(node);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol><li>调用<code>addWaiter</code>进行入队操作, 只不过是共享模式</li><li>判断前置节点是否是头节点<ol><li>是头节点:  再次尝试获取, 如果成功, 调用<code>setHeadAndPropagate</code>方法传播, 反之执行步骤 3</li><li>非头节点:  执行步骤 3</li></ol></li><li>获取失败后, 根据前置节点状态 判断是否应该阻塞当前节点</li></ol><h5 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a><code>setHeadAndPropagate</code></h5><p>我们知道只要当当前节点的前继节点为头节点且再次 <code>tryAcquireShared</code> 成功后再回执行 <code>shp</code> 方法</p><p>注意: shp 是<code>setHeadAndPropagate</code>方法的简称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// propagate 为 tryAcquireShared 的返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>  <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <br>  setHead(node);<br><br>  <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>      (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <span class="hljs-comment">// 获取后继节点</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <span class="hljs-comment">// 如果处于共享模式</span><br>      doReleaseShared();<span class="hljs-comment">// 执行释放操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>setHead</code> 方法后, 此前的 <code>head</code> 已经不在队列中了</p><p>如果 node.next 不为空且处于共享模式, 调用 <code>doReleaseShared()</code> 方法, 此方法在 <code>releaseShared</code> 会一起讲解</p><h3 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h3><h4 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>    doReleaseShared();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在调用了<code>tryReleaseShared</code>方法后,如果成功则会调用<code>doReleaseShared</code>, 这和上面<code>共享获取</code>时<code>setHeadAndPropagate</code>方法中调用的方法是一致的.</p><h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a><code>doReleaseShared</code></h4><p>此时我们知道在 <code>acquireShared</code> 和 <code>releaseShared</code> 中都会调用此方法, 该方法至少会被一个节点调用两次.</p><p>在分析这个方法前, 假设现在有三个节点为别是: <code>A, B, C</code> 且假设入队顺序是 <code>A -&gt; B -&gt; C</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 如果需要信号, 头节点通常将会以这种方式唤醒后继节点, 如果没有则将状态更新为PROPAGATE,以确保传播</span><br>  <span class="hljs-comment">// 此外，在执行此操作时，必须循环以防添加新节点。</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// 该判断只能保证在此时此刻队列中至少有两个节点, 可能在执行下面的代码中,队列从可能就只有一个节点了</span><br>    <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>      <span class="hljs-comment">// 疑问:A.ws为什么是 SIGNAL</span><br>      <span class="hljs-comment">// A 成为头节点, B 获取锁失败在执行 spaf 方法时修改</span><br>      <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>        <span class="hljs-comment">// 疑问: 为什么会更新失败? </span><br>        <span class="hljs-comment">// B 在执行完 spaf 方法可能没阻塞, 再次自旋获取到锁了, 并成为了头节点, 所以造成此时A执行CAS失败</span><br>        <span class="hljs-comment">// 更新成 0 是为了加速后续节点在执行 spaf 后不被阻塞</span><br>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>)) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解锁后继者</span><br>        unparkSuccessor(h);<br>      &#125;<br>      <span class="hljs-comment">// 后继节点不需要信号,则更新状态为PROPAGATE, 失败则自旋</span><br>      <span class="hljs-comment">// 疑问: 什么情况会进入此 else if</span><br>      <span class="hljs-comment">// A刚成为头节点(默认为 0), B执行 spaf 还未将 A.ws修改成 SIGNAL 此时 A 会进入 else if</span><br>      <span class="hljs-comment">// 疑问: compareAndSetWaitStatus(h, 0, Node.PROPAGATE)为什么失败?</span><br>      <span class="hljs-comment">// 当 ws==0 成立时,此时 B 在 spaf 将 A.ws 修改了 SIGNAL, 所以会失败</span><br>      <span class="hljs-comment">// 注意: 这个 else if 主要就是处理并预防有新节点加入</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br><span class="hljs-comment">// 执行此判断的条件, 成功调用unparkSuccessor方法或队列中没有两个节点</span><br>    <span class="hljs-keyword">if</span> (h == head)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a><code>unparkSuccessor</code></h4><p>解锁后继线程, 该方法只有在 CAS 将 head.ws修改成 0 成功时才会执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">     * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>  <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 疑问: 为什么要将 ws 更新成 0</span><br>    <span class="hljs-comment">// 后继线程在执行完 shp 没有被阻塞, 继续执行下次自旋, </span><br>    <span class="hljs-comment">// 下次在执行 shp 时后继节点发现前置节点的 ws改变了, 继续自旋, 避免了阻塞</span><br>    compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);  <br><br>  <span class="hljs-comment">// 跳过取消节点</span><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>  <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>    s = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>      <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>        s = t;<br>  &#125;<br>  <span class="hljs-comment">// 不为空</span><br>  <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>    <span class="hljs-comment">// 解锁线程, 则后继节点继续自旋, 获取锁</span><br>    LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>至此 AQS 中独占和共享模式下的 acquire 和 release 操作的细节都已分析完毕, 了解 AQS 对学习JUC 包下的类非常有帮助, 如果看完本章还有疑惑, 可以查看一下其它博客. </p><p><a href="https://cloud.tencent.com/developer/article/1187386">CLH 锁</a></p><p><a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">同步框架说明文档</a></p><p><a href="https://www.cnblogs.com/micrari/p/6937995.html">AQS讲解</a></p><p><a href="https://segmentfault.com/a/1190000016447307">AQS讲解</a></p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
      <tag>源码分析</tag>
      
      <tag>Aqs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Future及FutureTask的源码分析</title>
    <link href="/2022/05/28/juc/future_source_analysis/"/>
    <url>/2022/05/28/juc/future_source_analysis/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲解在向线程池提交任务时, 返回的Future的源码分析.</p><span id="more"></span><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一个Future代表一个异步计算的结果,  提供了检查计算是否完成, 等待其完成以及检索计算结果的方法.</p><p>在向ThreadPoolExecutor中提交任务时, 会返回一个Future.</p><h3 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br><br>  <span class="hljs-comment">// 取消Future, 当Future已完成或者已经取消, 此方法返回false. </span><br>  <span class="hljs-comment">// 当此方法调用后, isDone方法将始终返回true</span><br>  <span class="hljs-comment">// false: 表示Future取消失败, true: 表示Future取消成功</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br><br>  <span class="hljs-comment">// Future是否取消</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>  <br>  <span class="hljs-comment">// Future 是否完成</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 等待Future完成并获取结果</span><br>  <span class="hljs-comment">// 当Future被取消时,会抛出CancellationException</span><br>  <span class="hljs-comment">// 当Future出现异常时,会抛出ExecutionException</span><br>  V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br>  <span class="hljs-comment">// 超时等待Future完成并获取结果</span><br>  <span class="hljs-comment">// 异常结果如上</span><br>  V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>来看看Future的实现类<code>FutureTask</code>, 该类实现了 <code>RunnableFuture</code> ,而 RunnableFuture 继承了 Future 了.</p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>FutureTask提供了对Future的基础实现. 一个可取消的异步计算. 且可以使用FutureTask包装Runnable和Callable.</p><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123; <br>  <span class="hljs-comment">// 同步状态</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br>  <span class="hljs-comment">// 初始化状态</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>使用state来控制FutureTask的状态变化, 可行的状态变化</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">NEW -&gt; COMPLETING -&gt; NORMAL<br>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL<br>NEW -&gt; CANCELLED<br>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED<br></code></pre></td></tr></table></figure><h4 id="核心变量"><a href="#核心变量" class="headerlink" title="核心变量"></a>核心变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123; <br>  <span class="hljs-comment">// 潜在的callable, 当Future运行结束后清空</span><br>  <span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br>  <span class="hljs-comment">// 返回的结果 或者 执行任务中抛出的异常(调用get方法时)</span><br>  <span class="hljs-keyword">private</span> Object outcome; <br>  <span class="hljs-comment">// 执行callable的线程</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br>  <span class="hljs-comment">// 阻塞队列</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123; <br>  <br>  <span class="hljs-comment">// 初始化状态和赋值callable</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-built_in">this</span>.state = NEW;<br>  &#125;<br><br>  <span class="hljs-comment">// 包装 Runnable</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>    <span class="hljs-built_in">this</span>.state = NEW;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>由于 FutureTask 实现了 Runnable 接口, 所以优先查看<code>run</code>方法</p><h4 id="run方法原理"><a href="#run方法原理" class="headerlink" title="run方法原理"></a>run方法原理</h4><p>run方法继承自Runnable, 当FutureTask执行时会调用其run方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 条件成立的情况: 1. Future已经结束(状态未知) </span><br>  <span class="hljs-comment">// 2. Future处于NEW状态 且 cas修改执行当前FutureTask的线程失败</span><br>  <span class="hljs-keyword">if</span> (state != NEW ||<br>      !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// FutureTask处于NEW状态 且 cas 当前 FutureTask 的执行线程成功.</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 得到要执行的任务</span><br>    Callable&lt;V&gt; c = callable;<br>    <span class="hljs-comment">// 不为空切状态为初始化状态</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>      V result;<br>      <span class="hljs-type">boolean</span> ran;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用call方法执行挼是</span><br>        result = c.call();<br>        ran = <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        result = <span class="hljs-literal">null</span>;<br>        ran = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 设置异常</span><br>        setException(ex);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (ran)<br>        <span class="hljs-comment">// 设置结果</span><br>        set(result);<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 疑问: 问什么不cas更新? 此时线程安全, 只能有一个线程执行此操作</span><br>    runner = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 重新读取状态, 以免错过中断状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>      handlePossibleCancellationInterrupt(s);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;<br><span class="hljs-comment">// 此方法可能被多个方法调用, 所以使用cas  </span><br>  <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>    outcome = t;<br>    UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL); <br>    <span class="hljs-comment">// 完成计算, 主要是释放waiters链表存储的线程</span><br>    finishCompletion();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;<br>  <span class="hljs-comment">// 此方法可能被多个方法调用, 所以使用cas</span><br>  <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>    outcome = v;<br>    UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL);<br>    <span class="hljs-comment">// 完成计算, 主要是释放waiters链表存储的线程</span><br>    finishCompletion();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>setException</code>和<code>set</code>方法中唯一不同的就是修改的状态不同. 大致如下: </p><p><code>setException</code>状态变化: <code>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</code></p><p><code>set状态</code>变化: <code>NEW -&gt; COMPLETING -&gt; NORMAL</code></p><h5 id="finishCompletion方法原理"><a href="#finishCompletion方法原理" class="headerlink" title="finishCompletion方法原理"></a>finishCompletion方法原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// assert state &gt; COMPLETING;</span><br>  <span class="hljs-comment">// 遍历等待节点</span><br>  <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123; <br>    <span class="hljs-comment">// 更新waiters==null</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;<br>      <span class="hljs-comment">// cas成功</span><br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>          q.thread = <span class="hljs-literal">null</span>;<br>          LockSupport.unpark(t);<span class="hljs-comment">// 解锁线程</span><br>        &#125;<br>        <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;<span class="hljs-comment">// 获取下一个节点</span><br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">break</span>;<br>        q.next = <span class="hljs-literal">null</span>;<br>        q = next;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// 钩子函数</span><br>  done();<br><span class="hljs-comment">// 将执行的任务置为空</span><br>  callable = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="handlePossibleCancellationInterrupt方法原理"><a href="#handlePossibleCancellationInterrupt方法原理" class="headerlink" title="handlePossibleCancellationInterrupt方法原理"></a>handlePossibleCancellationInterrupt方法原理</h5><p>该方法只有当FutureTask的状态为<code>INTERRUPTING</code>或<code>INTERRUPTED</code>才会被调用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePossibleCancellationInterrupt</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;<br><br>  <span class="hljs-keyword">if</span> (s == INTERRUPTING)  <span class="hljs-comment">// FutureTask状态为中断中</span><br>    <span class="hljs-keyword">while</span> (state == INTERRUPTING)   <span class="hljs-comment">// 说明此时cancel方法还没结束, 所以让出cpu时间</span><br>      Thread.yield();<br><br>  <span class="hljs-comment">// assert state == INTERRUPTED;</span><br><br>  <span class="hljs-comment">// We want to clear any interrupt we may have received from</span><br>  <span class="hljs-comment">// cancel(true).  However, it is permissible to use interrupts</span><br>  <span class="hljs-comment">// as an independent mechanism for a task to communicate with</span><br>  <span class="hljs-comment">// its caller, and there is no way to clear only the</span><br>  <span class="hljs-comment">// cancellation interrupt.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Thread.interrupted();</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意:</p><p>只有当调用cancel(true)方法并传递true时, FutureTask的状态才会被更改为INTERRUPTING.</p><p>调用此方法的场景:</p><ul><li>FutureTask还未被执行, 调用了cancel方法, 当再次执行run方法时则无法执行.</li><li>FutureTask正在被执行, 调用了cancel方法.<ul><li>如果执行此Future的线程阻塞, 则会响应中断异常, 此方法会被调用</li><li>如果执行此Future的线程未阻塞, 此方法不会被调用</li></ul></li></ul><h4 id="cancel方法原理"><a href="#cancel方法原理" class="headerlink" title="cancel方法原理"></a>cancel方法原理</h4><p>该方法用于取消FutureTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>  <span class="hljs-comment">// 条件成立情况: 状态非NEW 或 状态为NEW但cas状态失败</span><br>  <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;<br>        UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,<br>                                 mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 状态为NEW且cas状态成功</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// true: 标识中断线程</span><br>    <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br>        <span class="hljs-comment">// 当此FutureTask在线程池中排队时, 此时Thread就是空, 此时中断没有意义</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>          <span class="hljs-comment">// 设置中断标志位</span><br>          t.interrupt();<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 更新状态为已中断</span><br>        <span class="hljs-comment">// 当此FutureTask在线程池中获取执行将不会成立.</span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 唤醒状态</span><br>    finishCompletion();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意:</p><p> 该方法只有<code>mayInterruptIfRunning</code>参数为true时,才会设置执行线程的中断标志位,  这就意味着如果执行该FutureTask的线程被阻塞, 就会响应中断. 反之如果不阻塞,则不会响应中断. FutureTask正常执行.</p><h4 id="get方法原理"><a href="#get方法原理" class="headerlink" title="get方法原理"></a>get方法原理</h4><p>此方法用于获取<code>FutureTask</code>异步计算的结果, 当FutureTask未计算完成时, 此方法会阻塞调用线程.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>  <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>    s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>  <span class="hljs-keyword">return</span> report(s);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="awaitDone方法原理"><a href="#awaitDone方法原理" class="headerlink" title="awaitDone方法原理"></a>awaitDone方法原理</h4><p>该方法用于等待任务完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-comment">// 计算超时时间, 纳秒</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>  <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 开启循环</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 线程是否中断过并清除中的标志位</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>      <span class="hljs-comment">// 删除等待节点</span><br>      removeWaiter(q);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-comment">// FutureTask已经完成</span><br>    <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;<br>      <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)<br>        q.thread = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-comment">// 如果FutureTask正在计算中</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING)<br>      Thread.yield();       <span class="hljs-comment">// 让出线程</span><br>    <span class="hljs-comment">// FutureTask处于NEW</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)<br>      <span class="hljs-comment">// 初始化等待节点, 存储当前线程</span><br>      q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>    <span class="hljs-comment">// 等待节点是否入队</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>      <span class="hljs-comment">// 通过cas更新waiters引用</span><br>      queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q.next = waiters, q);<br>    <span class="hljs-comment">// 如果超时获取,则调用parkNanos方法</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>      nanos = deadline - System.nanoTime();<br>      <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>        removeWaiter(q);<br>        <span class="hljs-keyword">return</span> state;<br>      &#125;<br>      LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>    &#125;<br>    <span class="hljs-comment">// 非超时获取,则调用park方法</span><br>    <span class="hljs-keyword">else</span><br>      LockSupport.park(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>FutureTask由于实现了Runnable接口, 让其自身具备了被执行的能力. 且本身缓存了执行当前FutureTask的线程. 同时又实现了Future接口, 具备了操作异步计算的能力.</p><p>其通过一个state变量来控制FutureTask的状态变化.</p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
      <tag>Future</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池源码分析V1.0</title>
    <link href="/2022/05/27/juc/thread_pool_source_analysis/"/>
    <url>/2022/05/27/juc/thread_pool_source_analysis/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲解线程池在执行任务时的相关源码和关闭线程池的源码.</p><span id="more"></span><h2 id="线程池源码分析"><a href="#线程池源码分析" class="headerlink" title="线程池源码分析"></a>线程池源码分析</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><blockquote><p>Executor作为ThreadPoolExecutor的顶级父类接口,仅仅只定义了执行任务的动作.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Executor</span> &#123;<br>  <span class="hljs-comment">// 提交一个Runnable任务执行</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>这里我们可以看出线程池可以执行Runnable及其子类实现的任务</code>.</p><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><blockquote><p>ExecutorService则定义了线程池的状态和一些管理方法, 例如线程池的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span> &#123;<br><br>  <span class="hljs-comment">// 停止线程池, 会等待线程池中的任务完成</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 立刻停止线程池, 返回线程池中为执行的任务, 该方法不会等待任务完成.</span><br>  List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br>  <br>  <span class="hljs-comment">// 线程池是否停止中</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 线程池是否终止</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 等待线程池终止(会处理完所有的任务)</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br>  <span class="hljs-comment">// 提交一个任务,只不过类型为callable</span><br>  &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br><br>  <span class="hljs-comment">// 提交一个任务,返回一个具体的类型Future</span><br>  &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span>;<br><br>  <span class="hljs-comment">// 提交一个任务, 返回一个Future</span><br>  Future&lt;?&gt; submit(Runnable task);<br><br>  <span class="hljs-comment">// 执行所有任务</span><br>  &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 执行所有任务, 具有超时</span><br>  &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                                <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br>  <span class="hljs-comment">// 执行任迎春一个任务即可</span><br>  &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br>  <span class="hljs-comment">// 执行任迎春一个任务即可, 存在超时</span><br>  &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                  <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>该接口定义了反应线程池状态和向线程池提交任务的方法</code></p><p>关于上面代码中的Future, 可以当成其是一个<code>代表任务执行的回调(接收通知)</code></p></blockquote><h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><blockquote><p>此抽象类对ExecutorService中的部分方法进行了简单的实现. </p><p>重点关注<code>submit</code>方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>  <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <span class="hljs-comment">// 将Runnable类型的task封装成了RunnableFuture</span><br>  RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>  <span class="hljs-comment">// 调用execute方法执行任务</span><br>  execute(ftask);<br>  <span class="hljs-comment">// 返回Future</span><br>  <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">// 同上</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>  <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>  execute(ftask);<br>  <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RunnableFuture是一个组合接口, 分别集成了Runnable和Future接口, 所以它包含了Runnable和Future所有的功能</code></p><h3 id="思考-线程池设计"><a href="#思考-线程池设计" class="headerlink" title="思考-线程池设计"></a>思考-线程池设计</h3><p>看了上面的ExecutorService接口中的方法,我们可以知道,线程池中需要有个变量来表明线程池的状态.</p><blockquote><ul><li><code>状态变量</code>,标识线程池的<code>状态</code></li><li><code>任务队列</code>,存储线程池执行的<code>任务</code></li><li><code>线程队列</code>,存储线程池执行任务的<code>线程</code></li></ul></blockquote><h3 id="核心变量"><a href="#核心变量" class="headerlink" title="核心变量"></a>核心变量</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 整形值变量, 高4位控制线程池状态, 低28位控制线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 线程容量就是剩余的28位</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 运行状态, 区别于其他状态, 该值为负数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// 关闭状态, 就是 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// 停止状态</span><br><span class="hljs-comment">// 0010 0000 0000 0000 0000 0000 0000 0000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// 转换状态</span><br><span class="hljs-comment">// 0100 0000 0000 0000 0000 0000 0000 0000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// 终止状态</span><br><span class="hljs-comment">// 0110 0000 0000 0000 0000 0000 0000 0000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// ----------分割线----------</span><br><br><span class="hljs-comment">// 存储任务的队列</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><span class="hljs-comment">// 存储执行任务的线程</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Worker&gt;();<br><span class="hljs-comment">// 线程工厂</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ThreadFactory threadFactory;<br><span class="hljs-comment">// 拒绝策略</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<br><span class="hljs-comment">// 空闲线程的存活时间</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> keepAliveTime;<br><span class="hljs-comment">// 是否允许核心线程超时存活, 默认为false, 即核心线程空闲时也会存活</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> allowCoreThreadTimeOut;<br><span class="hljs-comment">// 线程池核心线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<br><span class="hljs-comment">// 线程池最大线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<br><span class="hljs-comment">// 默认的拒绝策略, 即丢弃策略</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">defaultHandler</span> <span class="hljs-operator">=</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortPolicy</span>();<br></code></pre></td></tr></table></figure><p>通过二进制的可以看出所有的状态都存储在<code>高四位</code>.</p><blockquote><p> <code>使用一个原子性的整形值将线程池的运行状态和线程数量统一管理.</code></p><p><code>整形值一共有32位,有用高四位来存储线程池的运行状态,低28位来存储线程数量</code></p><p><code>RUNNING: 运行状态, 线程池可以接收并处理新的任务; </code></p><p><code>SHUTDOWN:不接受新的任务,但是会处理队列中的任务; </code></p><p><code>STOP: 停止状态, 不接受新任务, 不处理队列中的任务;</code></p><p><code>TERMINATED: 终止状态;</code></p><p><code>TIDYING:过渡状态,中断所有任务</code></p><p>从变量中可以看出, 使用了阻塞队列(<code>BlockingQueue</code>)来存储向线程池中提交的任务. 并且使用了<code>Worker</code>来对执行线程进行了封装. </p></blockquote><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>  <span class="hljs-comment">// 工作线程</span><br>  <span class="hljs-keyword">final</span> Thread thread;<br>  <span class="hljs-comment">// 初始化线程</span><br>  Runnable firstTask;<br>  <span class="hljs-comment">// 完成的任务数量</span><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>  Worker(Runnable firstTask) &#123;<br><span class="hljs-comment">// 疑问: 为什么要设置同步状态?</span><br>    setState(-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 赋值</span><br>    <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>    <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 运行Worker</span><br>    runWorker(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 是否持有独占锁</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>      setExclusiveOwnerThread(Thread.currentThread());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    setState(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 上锁和解锁等操作</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><ul><li><p>为什么在Worker的构造函数中会设置同步状态为-1?</p><ul><li>避免线程还没启动就被中断, 无论是在shutdown或shutdownNow方法中设置中断都需要获取到锁.</li></ul></li><li><p><code>runWorker</code>方法干了什么事?</p><ul><li>大致为开启循环, 不断调用getTask方法获取任务并执行.</li></ul></li></ul><h3 id="核心构造函数"><a href="#核心构造函数" class="headerlink" title="核心构造函数"></a>核心构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, // 核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize, // 最大线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,// 空闲线程存活时间</span><br><span class="hljs-params">                          TimeUnit unit, // 时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 存放任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,// 线程工厂</span><br><span class="hljs-params">                          RejectedExecutionHandler handler // 任务拒绝策略)</span> &#123;                     <br><span class="hljs-comment">// 校验参数                          </span><br>  <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> || maximumPoolSize &lt;= <span class="hljs-number">0</span> || maximumPoolSize &lt; corePoolSize ||<br>      keepAliveTime &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><br>  <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>  <span class="hljs-built_in">this</span>.acc = System.getSecurityManager() == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : AccessController.getContext();<br><span class="hljs-comment">// 简单的变量赋值 </span><br>  <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>  <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>  <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>  <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>  <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>  <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其他构造函数最终都是调用了此函数来初始化线程池.</p></blockquote><h3 id="线程池执行"><a href="#线程池执行" class="headerlink" title="线程池执行"></a>线程池执行</h3><p>在抽象父类<code>AbstractExecutorService</code>中可以通过<code>submit</code>向线程池中提交任务执行. 而在<code>submit</code>方法最终调用了<code>execute</code>方法来执行任务.</p><p>在了解execute方法之前, 先来看几个前置方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CAPACITY 取反就是高四位</span><br><span class="hljs-comment">// 查看线程池运行状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><span class="hljs-comment">// 查看线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><h4 id="execute-方法原理"><a href="#execute-方法原理" class="headerlink" title="execute 方法原理"></a>execute 方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>  <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>  <span class="hljs-comment">// 如果工作线程小于核心线程</span><br>  <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>    <span class="hljs-comment">// 则添加一个工作线程</span><br>    <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>      <span class="hljs-keyword">return</span>;<br>    c = ctl.get();<br>  &#125;<br>  <span class="hljs-comment">// 走到这步说明: 工作线程大于核心线程, 或者添加Worker失败</span><br>  <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;   <span class="hljs-comment">// 线程池处于运行状态且任务入队成功</span><br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>    <br>    <span class="hljs-comment">// 再次检查线程池状态, 因为上面的操作执行完,可能有人调用了shutdown方法</span><br>    <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>      reject(command); <span class="hljs-comment">// 拒绝任务</span><br><br>    <span class="hljs-comment">// 到这里有两种状况: </span><br>    <span class="hljs-comment">// 1. 线程池是运行状态 </span><br>    <span class="hljs-comment">// 2. 线程池非运行状态且remove方法执行失败</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)    <span class="hljs-comment">// 如果工作线程为0</span><br>      addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);       <span class="hljs-comment">// 疑问? 工作线程为0, 为什么还要创建一个线程</span><br>  &#125;<br>  <span class="hljs-comment">// 到此出现的情况: 线程池非运行状态或者任务入队失败</span><br>  <span class="hljs-comment">// 再次尝试入队(此时线程池可能处于shutdown或stop状态或队列满了)</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>    reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据源码分析可得出流程如下:</p><blockquote><ul><li>第一步: 先判断工作线程是否大于核心线程数<ul><li>小于: 则添加一个Worker(<code>核心线程</code>)<ul><li>添加成功, 直接返回</li><li>添加失败, 执行第二步</li></ul></li><li>大于, 执行第二步</li></ul></li><li>第二步: 判断线程池是否处于运行状态<ul><li>运行: 调用队列的<code>offer</code>方法将任务入队<ul><li>入队成功: 再次检查线程池状态(此时线程池可能关闭), 并添加一个Worker(<code>非核心线程</code>)</li><li>入队失败: 执行第三步</li></ul></li><li>其他状态: 执行第三步</li></ul></li><li>第三步: 再次尝试添加Worker, 此时线程池可能处于shutdown或stop状态 或者任务队列满了<ul><li>添加Worker成功: 返回 (<code>非核心线程</code>)</li><li>添加Worker失败: 拒绝任务</li></ul></li></ul></blockquote><h4 id="addWorker方法原理"><a href="#addWorker方法原理" class="headerlink" title="addWorker方法原理"></a>addWorker方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>  retry:<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c); <span class="hljs-comment">// 获取运行状态</span><br><br><span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-comment">// 线程池非运行状态(SHUTDOWN, STOP...)</span><br>    <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; <br>        <span class="hljs-comment">// 注意此条件, 当此条件返回true, 需要注意到任务队列不为空, 这里和processWorkerExit方法最后的</span><br>        <span class="hljs-comment">// addWorker 相呼应</span><br>        ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span> &amp;&amp; ! workQueue.isEmpty()) <br>    )<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 自旋</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c); <span class="hljs-comment">// 获取工作线程数量</span><br>      <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || <span class="hljs-comment">// 工作线程数大于容量</span><br>          wc &gt;= (core ? corePoolSize : maximumPoolSize)) <span class="hljs-comment">// 大于核心线程或最大线程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <br>      <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))  <span class="hljs-comment">// cas增加工作线程数</span><br>        <span class="hljs-keyword">break</span> retry; <span class="hljs-comment">// 结束</span><br><br>      c = ctl.get();   <span class="hljs-comment">// cas失败, 其他现在也在提交任务</span><br><br>      <span class="hljs-keyword">if</span> (runStateOf(c) != rs)  <span class="hljs-comment">// 线程池状态以改变, 重新整个大循环</span><br>        <span class="hljs-keyword">continue</span> retry;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 工作线程数修改成功,但是 Worker 可能新增失败, 怎么办?</span><br><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br><br>    w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask); <span class="hljs-comment">// 创建Worker对象</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock; <br>      mainLock.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>       <br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>        <span class="hljs-comment">// 出现两种情况:</span><br><span class="hljs-comment">// 1. 线程池处于 RUNNING 或 SHUTDOWN 状态</span><br>        <span class="hljs-comment">// 2. 如果线程池处于SHUTDOWN 且 firstTask为空</span><br>        <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||  (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123; <br>          <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// 线程是否存活</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br><br>          workers.add(w); <span class="hljs-comment">// 添加Worker的引用</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>          <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<span class="hljs-comment">// 修改最大线程池数量值</span><br>            largestPoolSize = s;<br>          workerAdded = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (workerAdded) &#123;<span class="hljs-comment">// 添加成功, 启动线程</span><br>        t.start();<br>        workerStarted = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (! workerStarted)<br>      addWorkerFailed(w);<br>  &#125;<br>  <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p>addWorker的代码大致分成了两步骤:</p><ol><li>通过<code>cas+自旋</code>来修改<code>workCount</code>的数值.</li><li>创建Worker对象, 并启动<code>Worker</code>中的<code>thread</code>.</li></ol><p>但是启动线程的代码由一个<code>workerAdded</code>变量控制, 而只有满足<code>if (rs &lt; SHUTDOWN ||  (rs == SHUTDOWN &amp;&amp; firstTask == null))</code>条件才会将其置为<code>true</code>.</p><p>满足此条件只会有两种情况:</p><ol><li>线程池处于运行状态(正常情况)</li><li>线程池处于SHUTDOWN状态, 且<code>firstTask==null</code>, 说明此时线程池正在关闭(异常情况)</li></ol><p>代码如下:</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220525_thread_pool.png" alt="image-20220525111316849" style="zoom:50%;" /><p>前提是线程池状态必须是运行状态.</p><p>Worker自己本身就是一个Runnable, 所以在线程启动时会调用Worker类中的run方法,而在run方法中调用了<code>runWorker</code>方法</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220524154640.png" alt="image-20220524154640310" style="zoom:50%;" /><h4 id="runWorker方法原理"><a href="#runWorker方法原理" class="headerlink" title="runWorker方法原理"></a>runWorker方法原理</h4><p>执行Worker, 注意此时Worker中的线程已经启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>  w.firstTask = <span class="hljs-literal">null</span>;<br>  w.unlock(); <span class="hljs-comment">// 允许中断? 疑问: 中断在哪里体现? 目前来看不知道.(可能在线程池关闭)</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 记录线程执行是否出现异常</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>      w.lock(); <span class="hljs-comment">// 获取锁</span><br>      <span class="hljs-comment">// 线程池状态是否是TERMINATED或TIDYING</span><br>      <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>           <span class="hljs-comment">// 线程是否设置中断标示位</span><br>        (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())<br>        wt.interrupt(); <span class="hljs-comment">// 中断线程, </span><br><br>      <span class="hljs-keyword">try</span> &#123;<br>        <br>        beforeExecute(wt, task); <span class="hljs-comment">// 前置钩子函数</span><br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          task.run();<span class="hljs-comment">// 执行task</span><br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>          thrown = x; <span class="hljs-keyword">throw</span> x;<br>        &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>          thrown = x; <span class="hljs-keyword">throw</span> x;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>          thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          afterExecute(task, thrown); <span class="hljs-comment">// 后置钩子函数</span><br>        &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        task = <span class="hljs-literal">null</span>;<br>        w.completedTasks++;<br>        w.unlock();<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 当从队列中获取的task==null时, 此变量才会被修改. 而当task.run出现异常时, 此变量不会被修改</span><br>    completedAbruptly = <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    processWorkerExit(w, completedAbruptly); <span class="hljs-comment">// 处理工作线程退出</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Worker工作线程内容比较简单, 开启循环不断调用<code>getTask</code>方法从任务队列中获取任务, 如果<code>getTask</code>返回null说明当前无任务执行, 终止循环将调用<code>processWorkerExit</code>方法处理.</p><p>注意<code>completedAbruptly</code>变量, 此变量默认为true, 而只有当while循环正常结束时才会将其改为false, 然而当<code>task.run</code>运行出现异常异常时, 会直接跳过此修改, 直接走到<code>processWorkerExit</code>方法.</p><p><code>所以completedAbruptly变量就是用来标识用户的任务是否会出现异常</code>.</p><h4 id="getTask方法原理"><a href="#getTask方法原理" class="headerlink" title="getTask方法原理"></a>getTask方法原理</h4><p>该方法用于从线程池中获取任务执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>  <span class="hljs-comment">// 启动自旋, 获取到任务结束</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>    <span class="hljs-comment">// 条件成立的情况: 1. 线程池状态处于STOP或TERMINATED状态且任务队列为空</span><br>    <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>      decrementWorkerCount();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 上面条件不成立的情况: 1. 线程池处于RUNNING 2. 线程池处于SHUTDOWN且任务队列不为空</span><br>    <span class="hljs-comment">// 此种情况用于处理当调用shutdown方法后保留线程继续处理任务队列中的任务</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>    <span class="hljs-comment">// 假设allowCoreThreadTimeOut=false, 则此条件有wc变量控制</span><br>    <span class="hljs-comment">// timed=true: 工作线程数大于核心线程数</span><br>    <span class="hljs-comment">// timed=false: 工作线程数小于核心线程数</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>    <span class="hljs-comment">// 条件成立的情况: </span><br>    <span class="hljs-comment">// (工作线程数大于核心线程数 或 非核心线程且此线程获取任务超时过) </span><br>    <span class="hljs-comment">// 且 </span><br>    <span class="hljs-comment">// (任务队列为空或工作线程数大于1)</span><br>    <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>        &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>      <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// timed=true: 说明此时Worker为核心线程且会阻塞在任务队列上, 反之则为非核心线程.</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>      workQueue.take();<br>      <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> r;<br>      <span class="hljs-comment">// 到此表示任务获取超时且任务为空, 此Worker空闲了.</span><br>      timedOut = <span class="hljs-literal">true</span>;<br>    &#125; <br><span class="hljs-comment">// 响应中断异常, shutdown方法或shutdownNow方法, 此时线程必定阻塞在任务队列中</span><br>    <span class="hljs-comment">// 此时任务队列一定为空.则getTask循环将会终止返回null</span><br>    <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;      <br>      timedOut = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getTask返回null</code>的情况有两种:</p><ol><li>任务队列中没有任务</li><li>线程池调用了shutdown方法或shutdownNow方法.</li></ol><p>在最后的代码中捕捉了<code>InterruptedException</code>异常, 这是因为在调用<code>shutdown</code>方法时, 会设置线程的中断标志位.代码会进行下一次循环, 但是此时线程池的状态已经为<code>SHUTDOWN</code>状态, 所以<code>getTask</code>方法会直接返回null, 调用<code>processWorkerExit</code>方法处理worker退出的逻辑.</p><p><code>核心线程会阻塞在阻塞队列中.</code></p><h4 id="processWorkerExit方法原理"><a href="#processWorkerExit方法原理" class="headerlink" title="processWorkerExit方法原理"></a>processWorkerExit方法原理</h4><p>注意此方法由执行Worker的线程调用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>  <span class="hljs-keyword">if</span> (completedAbruptly)<span class="hljs-comment">// 任务执行出现了异常</span><br>    decrementWorkerCount();<span class="hljs-comment">// 减少工作线程数量</span><br><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    completedTaskCount += w.completedTasks;<span class="hljs-comment">// 计算任务数量</span><br>    workers.remove(w);<span class="hljs-comment">// 删除Worker引用</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br><br>  <span class="hljs-comment">// 尝试终止</span><br>  tryTerminate();<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>  <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<span class="hljs-comment">// 线程池处于 SHUTDOWN 或 RUNNING 状态</span><br>    <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<span class="hljs-comment">// 此条件成立, 说明队列中无任务, 此时Worker已经空闲</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>      <span class="hljs-comment">// allowCoreThreadTimeOut=true 此条件才有可能成立</span><br>      <span class="hljs-comment">// 需要保留一个线程来处理队列中的任务.</span><br>      <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>        min = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<span class="hljs-comment">// 工作线程数还充足(最坏的情况是只有一个工作线程)</span><br>        <span class="hljs-keyword">return</span>; <br>    &#125;<br>    <span class="hljs-comment">// 执行任务出现异常(completedAbruptly=true)或者工作线程为0(workerCountOf(c) &gt;= min -&gt; false)</span><br>    <span class="hljs-comment">// 由于上面workers已经删除对其的引用, 所以此时这个Worker会在下次垃圾回收时被回收掉</span><br>    <span class="hljs-comment">// 此时需要添加一个新的工作线程</span><br>    addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此方法处理中, 知道了在开启了<code>所有线程超时(allowCoreThreadTimeOut=true)</code>和<code>关闭线程池(状态为SHUTDOWN)</code>时需要至少保留一个线程来处理队列中的任务.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>线程池中线程执行任务的线程由Worker对象进行封装, 每个线程都会开启一个循环来从任务队列中获取任务执行,</p><p>当执行任务出现异常时, 此时Worker</p><p>可以看出在<code>addWorker.addWorkerFailed</code>和<code>runWorker.processWorkerExit</code>方法中都会调用<code>tryTerminate</code>方法.</p><p>在<code>addWorker</code>方法中会调用<code>addWorkerFailed</code>方法来处理添加Worker失败的情况. 同时在runWorker方法中也会调用<code>processWorkerExit</code>来处理Worker空闲退出线程池的问题.</p><h3 id="线程池终止"><a href="#线程池终止" class="headerlink" title="线程池终止"></a>线程池终止</h3><p>线程池终止的方法有两个, 分别是: <code>shutdown</code> &#x2F; <code>shutdownNow</code>. 它俩的区别是 一个是停止线程池, 但是会继续处理任务队列中的任务, 另一个是停止线程池, 不会处理任务队列中的任务.</p><h4 id="shutdown方法原理"><a href="#shutdown方法原理" class="headerlink" title="shutdown方法原理"></a>shutdown方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    checkShutdownAccess();<span class="hljs-comment">// 检查权限</span><br>    advanceRunState(SHUTDOWN);<span class="hljs-comment">// 修改线程池状态为SHUTDOWN</span><br>    interruptIdleWorkers();<span class="hljs-comment">// 中断Worker中的</span><br>    onShutdown(); <span class="hljs-comment">// 钩子函数</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br>  <span class="hljs-comment">// 尝试终止</span><br>  tryTerminate();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">advanceRunState</span><span class="hljs-params">(<span class="hljs-type">int</span> targetState)</span> &#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-keyword">if</span> (runStateAtLeast(c, targetState) || <span class="hljs-comment">// 线程池非SHUTDOWN, 则cas成SHUTDOWN</span><br>        ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">()</span> &#123;<br>  interruptIdleWorkers(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<span class="hljs-comment">// 遍历所有的Worker</span><br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>      <span class="hljs-comment">// 线程没有中断过且Worker此时未工作(Worker在执行task时会获取锁)</span><br>      <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          t.interrupt(); <span class="hljs-comment">// 设置中断标志位</span><br>        &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          w.unlock();<span class="hljs-comment">// 解锁</span><br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (onlyOne)<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>shutdown</code>方法会修改线程池的状态为SHUTDOWN, 且会中断所有的空闲线程(即没有执行任务的线程). 此时addWorker执行将不会被允许, 即不会添加新的线程. 此时只需要把任务队列中的任务执行完即可.</p><p>此时线程池的状况如下: </p><ol><li>任务队列没有任务, 存在阻塞的线程, 此时这些线程响应中断. 最终getTask会返回null, 最终调用runWorker中的processWorkerExit销毁此Worker</li><li>任务队列中有任务, 不存在阻塞的线程, 此时线程正常获取任务, 下个循环再次调用getTask获取任务, 此时任务队列中就没有任务了, 此时线程会响应中断 抛出异常, 再次循环.getTask返回null</li></ol><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220526_getTask.png" alt="image-20220526110855543" style="zoom:50%;" /><p>详情参考<code>getTask</code>方法.</p><h4 id="shutdownNow方法原理"><a href="#shutdownNow方法原理" class="headerlink" title="shutdownNow方法原理"></a>shutdownNow方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>  List&lt;Runnable&gt; tasks;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<span class="hljs-comment">// 获取锁</span><br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    checkShutdownAccess();<span class="hljs-comment">// 同上</span><br>    advanceRunState(STOP);<span class="hljs-comment">// 修改线程池状态为STOP</span><br>    interruptWorkers();<span class="hljs-comment">// 中断线程</span><br>    tasks = drainQueue();<span class="hljs-comment">// 获取队列中未执行的任务</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br>  tryTerminate();<span class="hljs-comment">// 尝试终止</span><br>  <span class="hljs-keyword">return</span> tasks;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptWorkers</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>  mainLock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (Worker w : workers)<br>      w.interruptIfStarted();<span class="hljs-comment">// 设置中断位, 由Worker内部实现</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>shutdownNow的方法实现和shutdown方法差不多, 只是将线程池的状态改为了STOP状态, 同时该方法会中断正在执行任务的线程,通过Worker内部实现的<code>interruptIfStarted</code>方法设置中断标志位.</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20220526_worker_interrupt.png" alt="image-20220526111455759" style="zoom:50%;" /><p>而被设置中断标志位的线程在执行完当前任务后, 再次调用<code>getTask</code>方法获取任务时将会得到null. 此时Worker的退出流程和上述一致.</p><h4 id="tryTerminate方法原理"><a href="#tryTerminate方法原理" class="headerlink" title="tryTerminate方法原理"></a>tryTerminate方法原理</h4><p>此方法在多个方法中都会被调用,所以会存在线程安全问题.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br>    <span class="hljs-comment">// 条件成立的情况: 1. RUNNING状态 2.TERMINATED状态 3.SHUTDOWN状态队列不为空(队列中的任务需要处理)</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) ||<br>        runStateAtLeast(c, TIDYING) ||<br>        (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>      <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 到这里 线程池状态为STOP或队列为空, 当时还有线程在执行任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123;<br>      interruptIdleWorkers(ONLY_ONE); <span class="hljs-comment">// 中断一个空闲线程</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 到这里说明工作线程已经没有,即wc==0, 此时可以将状态设置为TIDYING</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// cas将线程池状态修改为TIDYING, 标识线程池在向TERMINATED状态转换</span><br>      <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          terminated();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-comment">// 设置线程池状态为终止状态</span><br>          ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>          termination.signalAll();    <span class="hljs-comment">// 唤醒所有等待线程池终止的线程</span><br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      mainLock.unlock();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>关于线程池的关闭一共有两个方法, 分别是shutdown和shutdownNow. 而这两者的区别就是一个会执行任务队列中的任务, 另一个则不会执行. </p><p>两个方法都是通过设置中断标志位来达到关闭Worker的目的. 而对中断异常的捕捉实在<code>getTask</code>方法, 或者是用户自行提交的任务中处理. </p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins Pipeline</title>
    <link href="/2020/10/09/jenkins/01-jenkins-introduction/"/>
    <url>/2020/10/09/jenkins/01-jenkins-introduction/</url>
    
    <content type="html"><![CDATA[<p>该文章主要Jenkins Pipeline的使用</p><span id="more"></span><h2 id="Jenkins-Pipeline"><a href="#Jenkins-Pipeline" class="headerlink" title="Jenkins-Pipeline"></a>Jenkins-Pipeline</h2><h3 id="Pipeline-Block"><a href="#Pipeline-Block" class="headerlink" title="Pipeline Block"></a>Pipeline Block</h3><blockquote><p>所有有效的声明式流水线必须包含在一个 <code>pipeline </code>块中</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>遵循Groovy语法。</p><p>特点：</p><ol><li>流水线顶层必须是一个 <code>pipeline&#123;&#125;</code>。</li><li>没有分号作为语句分隔符，每条语句都必须在自己的行上。</li><li>块只能由<code>节段，指令，步骤或赋值语句</code>组成。 *属性引用语句被视为无参方法调用。例如：input被视为input()。</li></ol></blockquote><h3 id="Agent-Block"><a href="#Agent-Block" class="headerlink" title="Agent Block"></a>Agent Block</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote><p><code>agent</code> 部分指定了整个流水线或特定的部分, 将会在Jenkins环境中执行的位置，这取决于 <code>agent</code> 区域的位置。</p><p>该部分必须在 <code>pipeline</code> 块的顶层被定义, 但是 stage 级别的使用是可选的。</p></blockquote><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><blockquote><p><code>any</code>：在任何可用的代理上执行流水线或阶段。例如: <code>agent any</code></p><p><code>label</code>：在提供了标签的 Jenkins 环境中可用的代理上执行流水线或阶段。 例如: <code>agent &#123; label &#39;node-1&#39; &#125;</code></p><p><code>node</code>： <code>agent &#123; node &#123; label &#39;labelName&#39; &#125; &#125;</code> 和 <code>agent &#123; label &#39;labelName&#39; &#125;</code> 一样, 但是 <code>node</code> 允许额外的选项 (比如 <code>customWorkspace</code> )。</p></blockquote><h3 id="Post-Block"><a href="#Post-Block" class="headerlink" title="Post Block"></a>Post Block</h3><blockquote><p><code>post</code> 部分定义一个或多个<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps">steps</a> ，这些阶段根据流水线或阶段的完成情况而运行(取决于流水线中 <code>post</code> 部分的位置)。</p><p><code>post</code>支持<code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code>, <code>unstable</code>, 和 <code>aborted</code>块中任意一个。</p><p>这些条件块允许在 <code>post</code> 部分的步骤的执行取决于流水线或阶段的完成状态。</p></blockquote><h4 id="块对应的条件"><a href="#块对应的条件" class="headerlink" title="块对应的条件"></a>块对应的条件</h4><blockquote><p><code>always</code>:无论流水线或阶段的完成状态如何，都允许在 <code>post</code> 部分运行该步骤。</p><p><code>changed</code>:当前流水线或阶段的完成状态与它之前的运行不同时，才能执行。</p><p><code>failure</code>:当前流水线或阶段的完成状态为”failure”，才能执行,。</p><p><code>success</code>:当前流水线或阶段的完成状态为”success”，才能执行。</p><p><code>unstable</code>:当前流水线或阶段的完成状态为”unstable”，才能执行, 通常由于测试失败,代码违规等造成。通常web UI是黄色。</p><p><code>aborted</code>:当前流水线或阶段的完成状态为”aborted”，才能执行, 通常由于流水线被手动的aborted。通常web UI是灰色。</p></blockquote><h3 id="Stages-块"><a href="#Stages-块" class="headerlink" title="Stages 块"></a>Stages 块</h3><blockquote><p>包含一系列一个或多个 <a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#stage">stage</a> 指令, <code>stages</code> 部分是流水线描述的大部分”工作” 的位置。</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>    agent any<br>    stages &#123; <br>        stage(<span class="hljs-string">&#x27;Example&#x27;</span>) &#123;<br>            steps &#123;<br>                echo <span class="hljs-string">&#x27;Hello World&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Steps块"><a href="#Steps块" class="headerlink" title="Steps块"></a>Steps块</h3><blockquote><p><code>steps</code> 部分在给定的 <code>stage</code> 指令中执行的定义了一系列的一个或多个<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps">steps</a></p></blockquote><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><blockquote><p><code>environment</code> 指令制定一个 键-值对序列，该序列将被定义为所有步骤的环境变量，或者是特定于阶段的步骤， 这取决于 <code>environment</code> 指令在流水线内的位置。</p><p>该指令支持一个特殊的助手方法 <code>credentials()</code> ，该方法可用于在Jenkins环境中通过标识符访问预定义的凭证。</p></blockquote><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><blockquote><p><code>options</code> 指令允许从流水线内部配置特定于流水线的选项。</p></blockquote><h5 id="可用选项"><a href="#可用选项" class="headerlink" title="可用选项"></a>可用选项</h5><ul><li><p>buildDiscarder</p><p>为最近的流水线运行的特定数量保存组件和控制台输出。例如: <code>options &#123; buildDiscarder(logRotator(numToKeepStr: &#39;1&#39;)) &#125;</code></p></li><li><p>disableConcurrentBuilds</p><p>不允许同时执行流水线。 可被用来防止同时访问共享资源等。 例如: <code>options &#123; disableConcurrentBuilds() &#125;</code></p></li><li><p>overrideIndexTriggers</p><p>允许覆盖分支索引触发器的默认处理。 如果分支索引触发器在多分支或组织标签中禁用, <code>options &#123; overrideIndexTriggers(true) &#125;</code> 将只允许它们用于促工作。否则, <code>options &#123; overrideIndexTriggers(false) &#125;</code> 只会禁用改作业的分支索引触发器。</p></li><li><p>skipDefaultCheckout</p><p>在<code>agent</code> 指令中，跳过从源代码控制中检出代码的默认情况。例如: <code>options &#123; skipDefaultCheckout() &#125;</code></p></li><li><p>skipStagesAfterUnstable</p><p>一旦构建状态变得UNSTABLE，跳过该阶段。例如: <code>options &#123; skipStagesAfterUnstable() &#125;</code></p></li><li><p>checkoutToSubdirectory</p><p>在工作空间的子目录中自动地执行源代码控制检出。例如: <code>options &#123; checkoutToSubdirectory(&#39;foo&#39;) &#125;</code></p></li><li><p>timeout</p><p>设置流水线运行的超时时间, 在此之后，Jenkins将中止流水线。例如: <code>options &#123; timeout(time: 1, unit: &#39;HOURS&#39;) &#125;</code></p></li><li><p>retry</p><p>在失败时, 重新尝试整个流水线的指定次数。 For example: <code>options &#123; retry(3) &#125;</code></p></li><li><p>timestamps</p><p>预谋所有由流水线生成的控制台输出，与该流水线发出的时间一致。 例如: <code>options &#123; timestamps() &#125;</code></p></li></ul><h5 id="可选的阶段选项"><a href="#可选的阶段选项" class="headerlink" title="可选的阶段选项"></a>可选的阶段选项</h5><ul><li><p>skipDefaultCheckout</p><p>在 <code>agent</code> 指令中跳过默认的从源代码控制中检出代码。例如: <code>options &#123; skipDefaultCheckout() &#125;</code></p></li><li><p>timeout</p><p>设置此阶段的超时时间, 在此之后， Jenkins 会终止该阶段。 例如: <code>options &#123; timeout(time: 1, unit: &#39;HOURS&#39;) &#125;</code></p></li><li><p>retry</p><p>在失败时, 重试此阶段指定次数。 例如: <code>options &#123; retry(3) &#125;</code></p></li><li><p>timestamps</p><p>预谋此阶段生成的所有控制台输出以及该行发出的时间一致。例如: <code>options &#123; timestamps() &#125;</code></p></li></ul><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><blockquote><p>定义自动安装和放置 <code>PATH</code> 的工具的一部分。</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>    agent any<br>    tools &#123;<br>        maven <span class="hljs-string">&#x27;apache-maven-3.0.1&#x27;</span> <br>    &#125;<br>    stages &#123;<br>        stage(<span class="hljs-string">&#x27;Example&#x27;</span>) &#123;<br>            steps &#123;<br>                sh <span class="hljs-string">&#x27;mvn --version&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">when &#123;<br>branch <span class="hljs-string">&#x27;development&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>when 用于判断</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>  agent any<br><br>  stages &#123;<br>    stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>      steps &#123;<br>        <span class="hljs-comment">/* `make check` 在测试失败后返回非零的退出码；</span><br><span class="hljs-comment">         * 使用 `true` 允许流水线继续进行</span><br><span class="hljs-comment">         */</span><br>        sh <span class="hljs-string">&#x27;make check || true&#x27;</span> <br>        junit <span class="hljs-string">&#x27;**/target/*.xml&#x27;</span> <br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">choice(<br>  <span class="hljs-symbol">description:</span> <span class="hljs-string">&#x27;Run flyway database migration using latest master branch from prices in what environment?&#x27;</span>,<br>  <span class="hljs-symbol">name:</span> <span class="hljs-string">&#x27;environment&#x27;</span>,<br>  <span class="hljs-symbol">choices:</span> [<span class="hljs-string">&#x27;PRE&#x27;</span>, <span class="hljs-string">&#x27;PRO&#x27;</span>]<br>)<br></code></pre></td></tr></table></figure><p>input</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">input &#123;<br>  message <span class="hljs-string">&quot;是否继续?&quot;</span><br>  ok <span class="hljs-string">&quot;发布 &quot;</span><br>  submitter <span class="hljs-string">&quot;alice,bob&quot;</span><br>  parameters &#123;<br>    string(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;IP&#x27;</span>, <span class="hljs-attr">defaultValue:</span> <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;线上节点 1&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> java -jar -Dspring.profiles.active=prod /data/jars/admin-io-better-cn-api/master/admin-io-better-cn-api-master.jar &gt;/data/nohup.out 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps -ef |grep java|grep admin-io-better-cn-api-master.jar|grep prod|grep -v grep|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><blockquote><p>BUILD_ID</p><p>当前构建的 ID，与 Jenkins 版本 1.597+ 中创建的构建号 BUILD_NUMBER 是完全相同的。</p><p>BUILD_NUMBER</p><p>当前构建号，比如 “153”。</p><p>BUILD_TAG</p><p>字符串 <code>jenkins-$&#123;JOB_NAME&#125;-$&#123;BUILD_NUMBER&#125;</code>。可以放到源代码、jar 等文件中便于识别。</p><p>BUILD_URL</p><p>可以定位此次构建结果的 URL（比如 <a href="http://buildserver/jenkins/job/MyJobName/17/">http://buildserver/jenkins/job/MyJobName/17/</a> ）</p><p>EXECUTOR_NUMBER</p><p>用于识别执行当前构建的执行者的唯一编号（在同一台机器的所有执行者中）。这个就是你在“构建执行状态”中看到的编号，只不过编号从 0 开始，而不是 1。</p><p>JAVA_HOME</p><p>如果你的任务配置了使用特定的一个 JDK，那么这个变量就被设置为此 JDK 的 JAVA_HOME。当设置了此变量时，PATH 也将包括 JAVA_HOME 的 bin 子目录。</p><p>JENKINS_URL</p><p>Jenkins 服务器的完整 URL，比如 <a href="https://example.com:port/jenkins/">https://example.com:port/jenkins/</a> （注意：只有在“系统设置”中设置了 Jenkins URL 才可用）。</p><p>JOB_NAME</p><p>本次构建的项目名称，如 “foo” 或 “foo&#x2F;bar”。</p><p>NODE_NAME</p><p>运行本次构建的节点名称。对于 master 节点则为 “master”。</p><p>WORKSPACE</p><p>workspace 的绝对路径。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI</tag>
      
      <tag>Jenkins</tag>
      
      <tag>Pipeline</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-Bean定义</title>
    <link href="/2020/05/09/spring/03-spring-bean-definition/"/>
    <url>/2020/05/09/spring/03-spring-bean-definition/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-BeanDefinition"><a href="#Ioc-BeanDefinition" class="headerlink" title="Ioc-BeanDefinition"></a>Ioc-BeanDefinition</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><p>本文主要讲述BeanDefinition的作用，以及BeanDefinition子接口或实现类的使用和介绍。</p><p>不会涉及BeanDefinitionReader（读取生成BeanDefinition）和BeanDefinitionRegistry（注册BeanDefinition）相关的东西，只关注BeanDefinition本身的东西。</p></blockquote><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>BeanDefinition描述了一个bean实例，该实例具有属性值，构造函数参数值以及具体实现所提供的更多信息。</p><p>BeanDefinition主要是用来描述Bean，里面存放Bean元数据：比如<code>Bean类名、scope、属性、构造函数参数列表、依赖的Bean、是否是单例类、是否是懒加载</code>等一些列信息。</p><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180454.png" alt="image-20200513192525817" style="zoom:50%;" /><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AttributeAccessor</span>, BeanMetadataElement &#123;<br><span class="hljs-comment">// 设置Bean实例在Ioc中的名称</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String beanClassName)</span>;<br>  String <span class="hljs-title function_">getBeanClassName</span><span class="hljs-params">()</span>;<br>  <br><span class="hljs-comment">// 设置是否单例</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScope</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String scope)</span>;<br>  String <span class="hljs-title function_">getScope</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 设置是否懒加载</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLazyInit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> lazyInit)</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLazyInit</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 设置当前Bean依赖的Bean</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDependsOn</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String... dependsOn)</span>;<br>  String[] getDependsOn();<br><br>  <span class="hljs-comment">// 当前Bean是否是唯一</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrimary</span><span class="hljs-params">(<span class="hljs-type">boolean</span> primary)</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrimary</span><span class="hljs-params">()</span>;<br>  <br>  <span class="hljs-comment">// 返回此bean的构造函数参数值。</span><br>  <span class="hljs-comment">// ConstructorArgumentValues包装了当前Bean的构造函数参数值</span><br>  ConstructorArgumentValues <span class="hljs-title function_">getConstructorArgumentValues</span><span class="hljs-params">()</span>;<br>  <br>  <span class="hljs-comment">// 返回要应用到Bean的新实例的属性值。</span><br>  <span class="hljs-comment">// MutablePropertyValues包装了当前Bean的属性值</span><br>  MutablePropertyValues <span class="hljs-title function_">getPropertyValues</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 设置自定义初始化方法</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInitMethodName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String initMethodName)</span>;<br>  String <span class="hljs-title function_">getInitMethodName</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 设置自定义销毁方法</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDestroyMethodName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String destroyMethodName)</span>;<br>  String <span class="hljs-title function_">getDestroyMethodName</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 是否单例</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">// 是否多例</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrototype</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">// 是否抽象</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAbstract</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 返回原始的BeanDefinition；如果没有，则返回null。 允许获取修饰的bean定义（如果有）。</span><br>  <span class="hljs-comment">// 请注意，此方法返回直接发起者。 遍历发起者链以找到用户定义的原始BeanDefinition。</span><br>  BeanDefinition <span class="hljs-title function_">getOriginatingBeanDefinition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中BeanDefinition继承了<code>AttributeAccessor</code>, <code>BeanMetadataElement</code>两接口，让我们来看一下这两个接口。</p><h3 id="BeanMetadataElement"><a href="#BeanMetadataElement" class="headerlink" title="BeanMetadataElement"></a><code>BeanMetadataElement</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanMetadataElement</span> &#123;<br>  <span class="hljs-comment">// 返回此元数据元素的配置源Object（可以为null）。</span><br>  <span class="hljs-keyword">default</span> Object <span class="hljs-title function_">getSource</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AttributeAccessor"><a href="#AttributeAccessor" class="headerlink" title="AttributeAccessor"></a><code>AttributeAccessor</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义用于将元数据附加到任意对象或从任意对象访问元数据的通用协定的接口。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AttributeAccessor</span> &#123;<br><br>  <span class="hljs-comment">// 将名称定义的属性设置为提供的值。 如果value为null，则删除该属性。</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAttribute</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Object value)</span>;<br><span class="hljs-comment">// 获取由名称标识的属性的值。 如果属性不存在，则返回null。</span><br>  Object <span class="hljs-title function_">getAttribute</span><span class="hljs-params">(String name)</span>;<br>  <span class="hljs-comment">// 删除由名称标识的属性的值。 如果属性不存在，则返回null。</span><br>  Object <span class="hljs-title function_">removeAttribute</span><span class="hljs-params">(String name)</span>;<br>  <span class="hljs-comment">// 存在由名称标识的属性的值返回true，否则返回false</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasAttribute</span><span class="hljs-params">(String name)</span>;<br><span class="hljs-comment">// 返回所有属性的名称。</span><br>  String[] attributeNames();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a><code>AbstractBeanDefinition</code></h3><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>AbstractBeanDefinition是BeanDefinition最完整的实现，内部提供了大量的的属性字段来封装Bean的元数据信息。</p><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanMetadataAttributeAccessor</span><br>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinition</span>, Cloneable &#123;<br><span class="hljs-comment">// 忽略部分常量</span><br><br><span class="hljs-comment">// 属性字段</span><br>  <span class="hljs-comment">// BeanDefinition对应的Class</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Object beanClass;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> SCOPE_DEFAULT;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">abstractFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">private</span> Boolean lazyInit; <span class="hljs-comment">// 是否懒加载</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">autowireMode</span> <span class="hljs-operator">=</span> AUTOWIRE_NO;   <span class="hljs-comment">// 自动注入模式</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">dependencyCheck</span> <span class="hljs-operator">=</span> DEPENDENCY_CHECK_NONE;  <span class="hljs-comment">// 依赖检查</span><br>  <span class="hljs-keyword">private</span> String[] dependsOn;<span class="hljs-comment">// 依赖</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">autowireCandidate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">primary</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, AutowireCandidateQualifier&gt; qualifiers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> Supplier&lt;?&gt; instanceSupplier;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">nonPublicAccessAllowed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lenientConstructorResolution</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">private</span> String factoryBeanName;<br>  <span class="hljs-keyword">private</span> String factoryMethodName;<br>  <span class="hljs-keyword">private</span> ConstructorArgumentValues constructorArgumentValues;  <span class="hljs-comment">// 构造函数参数</span><br>  <span class="hljs-keyword">private</span> MutablePropertyValues propertyValues;<span class="hljs-comment">// 属性参数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">MethodOverrides</span> <span class="hljs-variable">methodOverrides</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodOverrides</span>();<br>  <span class="hljs-keyword">private</span> String initMethodName;<br>  <span class="hljs-keyword">private</span> String destroyMethodName;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">enforceInitMethod</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">enforceDestroyMethod</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">synthetic</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">role</span> <span class="hljs-operator">=</span> BeanDefinition.ROLE_APPLICATION;<br>  <span class="hljs-keyword">private</span> String description;<br>  <span class="hljs-keyword">private</span> Resource resource;<br>  <br>  <span class="hljs-comment">// 忽略属性get/set方法</span><br>  <br>  <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> cloneBeanDefinition();<br>&#125;<br><span class="hljs-comment">// 克隆BeanDefinition</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractBeanDefinition <span class="hljs-title function_">cloneBeanDefinition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="GenericBeanDefinition"><a href="#GenericBeanDefinition" class="headerlink" title="GenericBeanDefinition"></a><code>GenericBeanDefinition</code></h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>GenericBeanDefinition是一站式的用于标准bean定义。 像任何bean定义一样，它允许指定一个类以及可选的构造函数参数值和属性值。通过其<code>parentName</code>属性灵活的指定父BeanDefinition。</p><h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractBeanDefinition</span> &#123;<br><br>  <span class="hljs-meta">@Nullable</span><br>  <span class="hljs-keyword">private</span> String parentName;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">GenericBeanDefinition</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">GenericBeanDefinition</span><span class="hljs-params">(BeanDefinition original)</span> &#123;<br>    <span class="hljs-built_in">super</span>(original);<br>  &#125;<br><br>  <span class="hljs-comment">// 实现克隆BeanDefinition</span><br>  <span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title function_">cloneBeanDefinition</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericBeanDefinition</span>(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object other)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == other) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(other <span class="hljs-keyword">instanceof</span> GenericBeanDefinition)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">GenericBeanDefinition</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (GenericBeanDefinition) other;<br>    <span class="hljs-keyword">return</span> (ObjectUtils.nullSafeEquals(<span class="hljs-built_in">this</span>.parentName, that.parentName) &amp;&amp; <span class="hljs-built_in">super</span>.equals(other));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出GenericBeanDefinition继承了AbstractBeanDefinition类，新增了一个<code>parentName</code>属性。GenericBeanDefinition因为这个属性可以动态定义父依赖项，而不是将角色“硬编码”为根bean定义。</p><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGenericBeanDefinition</span><span class="hljs-params">()</span> &#123;<br><br>  <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br><br>  <span class="hljs-type">GenericBeanDefinition</span> <span class="hljs-variable">parentBeanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericBeanDefinition</span>();<br>  parentBeanDefinition.setBeanClass(IocParentBean.class);<br>  parentBeanDefinition.setBeanClassName(IocParentBean.class.getName());<br>  parentBeanDefinition.setInitMethodName(<span class="hljs-string">&quot;init&quot;</span>);<br><br>  applicationContext.registerBeanDefinition(<span class="hljs-string">&quot;iocParentBean&quot;</span>, parentBeanDefinition);<br><br>  <span class="hljs-type">GenericBeanDefinition</span> <span class="hljs-variable">childBeanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericBeanDefinition</span>();<br>  childBeanDefinition.setBeanClass(IocBean.class);<br>  childBeanDefinition.setParentName(parentBeanDefinition.getBeanClassName());<br><br>  applicationContext.registerBeanDefinition(<span class="hljs-string">&quot;iocBean&quot;</span>, childBeanDefinition);<br><br>  System.out.println(applicationContext.getBeanDefinition(<span class="hljs-string">&quot;iocParentBean&quot;</span>));<br>  System.out.println(applicationContext.getBeanDefinition(<span class="hljs-string">&quot;iocBean&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">Generic bean: class [io.better.spring.ioc.IocParentBean]; scope=; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=init; destroyMethodName=null<br> <br>Generic bean with parent &#x27;io.better.spring.ioc.IocParentBean&#x27;: class [io.better.spring.ioc.IocBean]; scope=; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null<br></code></pre></td></tr></table></figure><h4 id="RootBeanDefinition"><a href="#RootBeanDefinition" class="headerlink" title="RootBeanDefinition"></a><code>RootBeanDefinition</code></h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p>一个RooBeanDefinition表示合并的BeanDefinition，该定义在运行时支持Spring BeanFactory中的特定bean。它可能是由多个相互继承的原始bean定义创建的，通常定义为GenericBeanDefinitions。<code>RootBeanDefinition</code>本质上是运行时的 “统一” BeanDefinition 视图。</p><p>但是，从Spring 2.5开始，以编程方式注册bean定义的首选方法是GenericBeanDefinition类。</p><h5 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RootBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractBeanDefinition</span> &#123;<br><br><span class="hljs-comment">// BeanDefinitionHolder存储有Bean的名称、别名、BeanDefinition</span><br>  <span class="hljs-keyword">private</span> BeanDefinitionHolder decoratedDefinition;<br>  <span class="hljs-comment">// AnnotatedElement表示此VM中当前正在运行的程序的带注释元素。方便使用反射读取注释信息</span><br>  <span class="hljs-keyword">private</span> AnnotatedElement qualifiedElement;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> stale; <span class="hljs-comment">// 确定是否需要重新合并定义</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">allowCaching</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isFactoryMethodUnique</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">volatile</span> ResolvableType targetType;<br>  <span class="hljs-keyword">volatile</span> Class&lt;?&gt; resolvedTargetType; <span class="hljs-comment">// 缓存给定BeanDefinition的对应的Class。</span><br>  <span class="hljs-keyword">volatile</span> Boolean isFactoryBean; <span class="hljs-comment">// 如果该bean是工厂bean，则进行缓存。</span><br>  <span class="hljs-keyword">volatile</span> ResolvableType factoryMethodReturnType;<span class="hljs-comment">// 缓存通用类型的工厂方法的返回类型。</span><br>  <span class="hljs-keyword">volatile</span> Method factoryMethodToIntrospect;  <span class="hljs-comment">// 缓存用于自省的唯一工厂方法候选。</span><br>  <br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">constructorArgumentLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 以下四个构造函数字段的通用锁。</span><br>  Executable resolvedConstructorOrFactoryMethod; <span class="hljs-comment">// 缓存已解析的构造函数或工厂方法</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">constructorArgumentsResolved</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 将构造函数参数标记为已解析。</span><br>  Object[] resolvedConstructorArguments; <span class="hljs-comment">// 构造函数解析的参数数组</span><br>  Object[] preparedConstructorArguments;  <span class="hljs-comment">// 缓存部分准备好的构造函数参数。</span><br><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">postProcessingLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 以下两个后处理字段的通用锁</span><br><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">postProcessed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 指示是否应用MergedBeanDefinitionPostProcessor</span><br>  <span class="hljs-keyword">volatile</span> Boolean beforeInstantiationResolved;  <span class="hljs-comment">// 表示实例化之前的后处理器已启动</span><br><br>  <span class="hljs-keyword">private</span> Set&lt;Member&gt; externallyManagedConfigMembers;<br>  <span class="hljs-keyword">private</span> Set&lt;String&gt; externallyManagedInitMethods;<br>  <span class="hljs-keyword">private</span> Set&lt;String&gt; externallyManagedDestroyMethods;<br>&#125;<br></code></pre></td></tr></table></figure><p>RootBeanDefiniiton保存了以下信息：</p><ol><li>持有的BeanDefinitionHolder定义了id、别名与Bean的对应关系。</li><li>AnnotatedElement获取Bean的注解信息。</li><li>具体的工厂方法（Class类型），包括工厂方法的返回类型，工厂方法的Method对象</li><li>缓存了构造函数、构造函数参数。</li></ol><h4 id="ChildBeanDefinition"><a href="#ChildBeanDefinition" class="headerlink" title="ChildBeanDefinition"></a><code>ChildBeanDefinition</code></h4><p>从其父级继承设置的Bean的BeanDefinition。ChildBeanDefinition对父beanDefinition有固定的依赖性。ChildBeanDefinition将从父对象继承构造函数参数值，属性值和方法替代，并可以选择添加新值。如果指定了init方法，destroy方法和&#x2F;或静态工厂方法，则它们将覆盖相应的父设置。其余设置将始终从子定义中获取：取决于，自动装配模式，依赖项检查，单例，懒加载。</p><p>从Spring 2.5开始，以编程方式注册Bean定义的首选方法是GenericBeanDefinition类。</p><hr><h3 id="AnnotatedBeanDefinition"><a href="#AnnotatedBeanDefinition" class="headerlink" title="AnnotatedBeanDefinition"></a><code>AnnotatedBeanDefinition</code></h3><p>AnnotatedBeanDefinition扩展了BeanDefinition，可向外暴露Bean的<code>AnnotationMetadata</code>信息，无需加载Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AnnotatedBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanDefinition</span> &#123;<br><span class="hljs-comment">// 返回Bean的注解元数据信息</span><br>  AnnotationMetadata <span class="hljs-title function_">getMetadata</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 获取此bean定义的factory方法的元数据（如果有）</span><br>  MethodMetadata <span class="hljs-title function_">getFactoryMethodMetadata</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ScannedGenericBeanDefinition"><a href="#ScannedGenericBeanDefinition" class="headerlink" title="ScannedGenericBeanDefinition"></a><code>ScannedGenericBeanDefinition</code></h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>基于ASM ClassReader的GenericBeanDefinition类的扩展，支持通过AnnotatedBeanDefinition接口公开的注解元数据。此类不会尽早加载Bean类。而是从ASM ClassReader解析的“ .class”文件本身中检索所有相关的元数据。</p><p>它在功能上等效于AnnotatedGenericBeanDefinition.AnnotatedGenericBeanDefinition（AnnotationMetadata），但按类型区分已扫描的bean和已通过其他方式注册或检测的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannedGenericBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericBeanDefinition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AnnotatedBeanDefinition</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotationMetadata metadata;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScannedGenericBeanDefinition</span><span class="hljs-params">(MetadataReader metadataReader)</span> &#123;<br>    Assert.notNull(metadataReader, <span class="hljs-string">&quot;MetadataReader must not be null&quot;</span>);<br>    <span class="hljs-comment">// 获取到注解元数据信息</span><br>    <span class="hljs-built_in">this</span>.metadata = metadataReader.getAnnotationMetadata();<br>    setBeanClassName(<span class="hljs-built_in">this</span>.metadata.getClassName());<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AnnotationMetadata <span class="hljs-title function_">getMetadata</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.metadata;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MetadataReader</code>：用于访问类元数据的简单入口，由<code>ASM org.springframework.asm.ClassReader</code>读取。</p><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;iocBean1&quot;)</span><br><span class="hljs-meta">@Order(1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IocBean</span> &#123;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testScannedGenericBeanDefinition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-type">SimpleMetadataReaderFactory</span> <span class="hljs-variable">simpleMetadataReaderFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleMetadataReaderFactory</span>();<br>  <span class="hljs-type">MetadataReader</span> <span class="hljs-variable">metadataReader</span> <span class="hljs-operator">=</span> <br>    simpleMetadataReaderFactory.getMetadataReader(<span class="hljs-string">&quot;io.better.spring.ioc.IocBean&quot;</span>);<br><br>  <span class="hljs-type">ScannedGenericBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScannedGenericBeanDefinition</span>(metadataReader);<br><br>  <span class="hljs-type">AnnotationMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> beanDefinition.getMetadata();<br>  Set&lt;String&gt; annotationTypes = metadata.getAnnotationTypes();<br><br>  System.out.println(annotationTypes);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例结果-1"><a href="#示例结果-1" class="headerlink" title="示例结果"></a>示例结果</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">[org.springframework.stereotype.Component, org.springframework.core.annotation.Order]<br></code></pre></td></tr></table></figure><h4 id="AnnotatedGenericBeanDefinition"><a href="#AnnotatedGenericBeanDefinition" class="headerlink" title="AnnotatedGenericBeanDefinition"></a>AnnotatedGenericBeanDefinition</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>AnnotatedGenericBeanDefinition</p><p>这个GenericBeanDefinition变体主要用于测试希望在AnnotatedBeanDefinition上运行的代码，例如Spring组件扫描支持中的策略实现（默认定义类是org.springframework.context.annotation.ScannedGenericBeanDefinition，它也实现了AnnotatedBeanDefinition接口） 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotatedGenericBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericBeanDefinition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AnnotatedBeanDefinition</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotationMetadata metadata;<br><br>  <span class="hljs-keyword">private</span> MethodMetadata factoryMethodMetadata;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotatedGenericBeanDefinition</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> &#123;<br>    setBeanClass(beanClass);<br>    <span class="hljs-built_in">this</span>.metadata = AnnotationMetadata.introspect(beanClass);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AnnotationMetadata <span class="hljs-title function_">getMetadata</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.metadata;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-meta">@Nullable</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> MethodMetadata <span class="hljs-title function_">getFactoryMethodMetadata</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.factoryMethodMetadata;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnnotatedGenericBeanDefinition</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">AnnotatedGenericBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedGenericBeanDefinition</span>(IocBean.class);<br>  <br>  System.out.println(beanDefinition.getMetadata().getAnnotationTypes());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例结果-2"><a href="#示例结果-2" class="headerlink" title="示例结果"></a>示例结果</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">[org.springframework.stereotype.Component]<br></code></pre></td></tr></table></figure><h4 id="ConfigurationClassBeanDefinition"><a href="#ConfigurationClassBeanDefinition" class="headerlink" title="ConfigurationClassBeanDefinition"></a><code>ConfigurationClassBeanDefinition</code></h4><h5 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h5><p>该类是<code>ConfigurationClassBeanDefinitionReader</code>中的私有静态内部类。</p><p>而<code>ConfigurationClassBeanDefinitionReader</code>作用是将<code>@Configuration</code>注解标识的类生成<code>ConfigurationClass</code>实例，在通过<code>ConfigurationClassBeanDefinition</code>将其转换成BeanDefinition并注册到<code>BeanDefinitionRegistry</code>中。</p><p>而<code>ConfigurationClassBeanDefinition</code>的作用就是将<code>@Configuration</code>标识的类生成BeanDefinition（XML等其他配置源无效）。</p><h5 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigurationClassBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RootBeanDefinition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AnnotatedBeanDefinition</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotationMetadata annotationMetadata;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodMetadata factoryMethodMetadata;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConfigurationClassBeanDefinition</span><span class="hljs-params">(ConfigurationClass configClass, MethodMetadata beanMethodMetadata)</span> <br>  &#123;<br>    <span class="hljs-built_in">this</span>.annotationMetadata = configClass.getMetadata();<br>    <span class="hljs-built_in">this</span>.factoryMethodMetadata = beanMethodMetadata;<br>    setLenientConstructorResolution(<span class="hljs-literal">false</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> AnnotationMetadata <span class="hljs-title function_">getMetadata</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.annotationMetadata;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ConfigurationClassBeanDefinition构造函数中我们看到ConfigurationClass类，一个ConfigurationClass代表着一个用户定义的@Configuration类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>AbstractBeanDefinition</strong>：<ul><li>AbstractBeanDefinition是完善且具体的BeanDefinition类的基类，其中排除了GenericBeanDefinition，RootBeanDefinition和ChildBeanDefinition的常用属性。自动装配常数与AutowireCapableBeanFactory接口中定义的常数匹配。</li></ul></li><li><strong>GenericBeanDefinition</strong>：<ul><li>GenericBeanDefinition是一站式的用于标准bean定义。 像任何bean定义一样，它允许指定一个类以及可选的构造函数参数值和属性值。</li></ul></li><li><strong>AnnotatedBeanDefinition</strong>：<ul><li>表示注解类型的BeanDefinition，有两个重要的属性，AnnotationMetadata，MethodMetadata分别表示BeanDefinition的注解元信息和方法元信息。</li></ul></li><li><strong>RootBeanDefinition</strong>：<ul><li>代表一个<code>Xml，Java Config</code>来的BeanDefinition</li></ul></li><li><strong>ChildBeanDefinition</strong>:<ul><li>可以让子Bean定义拥有从父Bean定义哪里继承配置的能力</li></ul></li><li><strong>AnnotatedGenericBeanDefinition</strong>：<ul><li>表示<code>@Configuration</code>注解注释的Bean</li></ul></li><li><strong>ScannedGenericBeanDefinition</strong>：<ul><li>表示<code>@Component、@Service、@Controller、@Repository</code>等注解注释的Bean</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Proxy-代理</title>
    <link href="/2020/04/06/java/proxy/"/>
    <url>/2020/04/06/java/proxy/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲述代模式以及其实现方式，主要是 <code>静态代理</code> , <code>动态代理</code>, <code>Cglib代理</code>.</p><span id="more"></span><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式</a>是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><p>在<code>Java</code>中实现代理主要有三种方式：</p><ul><li>静态代码</li><li>动态代理</li><li>Cglib代理</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在静态代理中，需要为每一个被代理对象创建一个代理类，并实现同一个接口。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IConsumer</span> &#123;<br>  <span class="hljs-comment">// 消费</span><br>  String <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 代理对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConsumer</span> &#123;<br>  <span class="hljs-keyword">private</span> Consumer consumer;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConsumerProxy</span><span class="hljs-params">(Consumer consumer)</span> &#123;<br>    <span class="hljs-built_in">this</span>.consumer = consumer;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;代理对象执行前的代码&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.consumer.consumer();<br>    System.out.println(<span class="hljs-string">&quot;代理对象执行后的代码&quot;</span>);<br>    <span class="hljs-keyword">return</span> consumer;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 被代理对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConsumer</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费方法被调用了&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中看出，<code>ConsumerProxy</code>代理对象持有了<code>Consumer</code>被代理对象的引用，并在<code>consumer方法</code>中调用了<code>被代理对象的consumer方法</code>。来看看实际测试代码：</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStaticProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>();<br>    <span class="hljs-type">IConsumer</span> <span class="hljs-variable">consumerProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsumerProxy</span>(consumer);<br>    System.out.println(consumerProxy.consumer());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">代理对象执行前的代码<br>消费方法被调用了<br>代理对象执行后的代码<br>Success<br></code></pre></td></tr></table></figure><p><strong>优点：可以最大程度扩展被代理对象的功能。</strong></p><p><strong>缺点：被代理对象会随着代理对象的增加而增加，代码冗余。如果接口新增方法，代理对象和被代理对象都需要实现。</strong></p><p>基于静态代理的缺点，有没有一种代理能够动态的生成代理对象呢？</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>动态代理利用了<a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/">JDK API</a>，动态的在内存中构建代理对象，从而实现对目标对象的代理功能。</p><p>动态代理又被称为JDK代理或接口代理。</p><p>相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。</p><p>先来看一个示例，了解一下动态代理的基本使用。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ①</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IDynamic</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dynamicProxy</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// ②</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dynamic</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IDynamic</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dynamicProxy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;目标方法执行了&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ③</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyInvocation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object proxyTarget;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicProxyInvocation</span><span class="hljs-params">(Object proxyTarget)</span> &#123;<br>        <span class="hljs-built_in">this</span>.proxyTarget = proxyTarget;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;代理执行前&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">invokeResult</span> <span class="hljs-operator">=</span> method.invoke(proxyTarget, args);<br>        System.out.println(<span class="hljs-string">&quot;代理执行后&quot;</span>);<br>        <span class="hljs-keyword">return</span> invokeResult;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDynamicProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Dynamic</span> <span class="hljs-variable">proxyTarget</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dynamic</span>();<br>    <span class="hljs-type">IDynamic</span> <span class="hljs-variable">dynamicProxy</span> <span class="hljs-operator">=</span> (IDynamic) Proxy.newProxyInstance(proxyTarget.getClass().getClassLoader(),<br>            proxyTarget.getClass().getInterfaces(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxyInvocation</span>(proxyTarget));<br>    dynamicProxy.dynamicProxy();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">代理执行前<br>目标方法执行了<br>代理执行后<br></code></pre></td></tr></table></figure><p>在上面的代码中，看到了很多未知的接口和类，主要是<code>Proxy类</code>，<code>InvocationHandler接口</code>。</p><h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a><code>Proxy</code></h3><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p><code>Proxy.newProxyInstance()</code>方法返回的<code>代理类是如何生成</code>？为什么Jdk 的动态代理<code>被代理类必须实现接口</code>？</p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Proxy提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的<code>超类</code>。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>从上面的示例代码可以看出代理类的实例是由<code>Proxy.newProxyInstance</code>返回的，那么我们重点关注<code>Proxy.newProxyInstance</code>这个方法。</p><h5 id="创建代理实例"><a href="#创建代理实例" class="headerlink" title="创建代理实例"></a>创建代理实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> InvocationHandler h;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(InvocationHandler h)</span> &#123;<br>  Objects.requireNonNull(h);<br>  <span class="hljs-built_in">this</span>.h = h;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> &#123;<br>  <span class="hljs-comment">// 忽略部分代码</span><br>  <br>  <span class="hljs-comment">// 步骤①</span><br>  Class&lt;?&gt; cl = getProxyClass0(loader, intfs);<br><br>  <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>    checkNewProxyPermission(Reflection.getCallerClass(), cl);<br>  &#125;<br><span class="hljs-comment">// 步骤②</span><br>  <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">ih</span> <span class="hljs-operator">=</span> h;<br>  <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;<br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>      <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        cons.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;h&#125;);<br>  <span class="hljs-comment">// 忽略部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>newProxyInstance</code>方法中有两个比较核心的步骤，分别如下：</p><p>步骤①：获取代理类的<code>Class</code>实例。</p><p>步骤②：获取代理类带有<code>InvocationHandler</code>参数的构造方法。</p><p>除了上面两个比较重要的步骤，还需要关注<code>InvocationHandler h</code>和<code>Proxy(InvocationHandler h)</code>，后面会进行讲解。</p><h5 id="获取代理类字节码"><a href="#获取代理类字节码" class="headerlink" title="获取代理类字节码"></a>获取代理类字节码</h5><p><code>getProxyClass0</code>最终会调用到<code>ProxyClassFactory.apply()</code>方法中，具体操作细节，可自行Debug查看调用链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyClassFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BiFunction</span>&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">proxyClassNamePrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;$Proxy&quot;</span>;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;<br><br>    <span class="hljs-comment">// 忽略部分代码</span><br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nextUniqueNumber.getAndIncrement();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">proxyName</span> <span class="hljs-operator">=</span> proxyPkg + proxyClassNamePrefix + num;<br><span class="hljs-comment">// 步骤①</span><br>    <span class="hljs-type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(<br>      proxyName, interfaces, accessFlags);<br>    <span class="hljs-keyword">try</span> &#123;<br>   <span class="hljs-comment">// 步骤② 定义Class，native方法</span><br>      <span class="hljs-keyword">return</span> defineClass0(loader, proxyName,<br>                          proxyClassFile, <span class="hljs-number">0</span>, proxyClassFile.length);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassFormatError e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤①：调用<code>ProxyGenerator.generateProxyClass</code>生成代理类.class的字节数组。</p><p>步骤②：调用<code>defineClass0</code>生成.class文件，并加载到Jvm中。</p><h4 id="手动生成Class"><a href="#手动生成Class" class="headerlink" title="手动生成Class"></a>手动生成Class</h4><p>从上面我们得知了Proxy类在最后调用了<code>ProxyGenerator.generateProxyClass</code>方法生成了代理类的<code>.class</code>字节数组。那么生成的<code>.class</code>结构是怎样的呢？让我们来手动触发调用一下。</p><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyGeneratorTest</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">byte</span>[] dynamicObj = ProxyGenerator.generateProxyClass(<br>      <span class="hljs-string">&quot;ManualGeneratorDynamicClass&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;IDynamic.class&#125;, <span class="hljs-number">17</span>);<br><br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;ManualGeneratorDynamicClass.class&quot;</span>));<br>    out.write(dynamicObj);<br>    out.flush();<br>    out.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="代理类-class文件"><a href="#代理类-class文件" class="headerlink" title="代理类.class文件"></a>代理类<code>.class</code>文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManualGeneratorDynamicClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IDynamic</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br><br>  <span class="hljs-comment">// 调用父类Proxy的构造器对父类中InvocationHandler属性进行了赋值</span><br>  <span class="hljs-comment">// 而这个构造器是在Proxy.newProxyInstance()方法中被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ManualGeneratorDynamicClass</span><span class="hljs-params">(InvocationHandler var1)</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-built_in">super</span>(var1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;var1&#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) &#123;<br>            <span class="hljs-keyword">throw</span> var3;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var4);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m2, (Object[])<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dynamicProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 调用了父类的InvocationHandler实例的invoke方法</span><br>            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, (Object[])<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m0, (Object[])<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>          <span class="hljs-comment">// 获取到被代理类实现的接口中的方法</span><br>            m3 = Class.forName(<span class="hljs-string">&quot;io.better.jdk.proxy.dynamicproxy.IDynamic&quot;</span>).getMethod(<span class="hljs-string">&quot;dynamicProxy&quot;</span>);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchMethodError</span>(var2.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoClassDefFoundError</span>(var3.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看出<code>ManualGeneratorDynamicClass</code>类不仅继承了<code>Proxy</code>类（解释了Porxy为什么是所有代理类的超类），还实现了<code>被代理类</code>实现的接口（解释了为什么被代理类必须实现接口？）。</p><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a><code>InvocationHandler</code></h3><p>通过上面对Proxy的了解，我们知道了代理类的方法调用最终会调用到InvocationHandler实例的invoke方法。</p><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>InvocationHandler是代理实例的调用处理程序（InvocationHandler实例）实现的接口。<br><code>每个代理实例都有一个关联的调用处理程序</code>。 当一个方法是在代理实例调用，方法调用进行编码，并分发给invoke的调用处理程序的方法。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>  <span class="hljs-comment">// 处理代理实例的方法调用并返回结果。</span><br>  <span class="hljs-comment">// 该方法将在调用处理程序时的方法是在一个代理实例，它与相关的调用来调用。</span><br>  <span class="hljs-comment">// proxy: 类型为Proxy</span><br>  <span class="hljs-comment">// method: 目标执行的方法</span><br>  <span class="hljs-comment">// args: 方法执行所需的参数</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span><br>    <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>运行时动态生成代理类，和被代理类解耦。</li></ul><p>缺点：</p><ul><li>被代理类必须实现接口，否则不能使用动态代理。</li></ul><h4 id="代理机制"><a href="#代理机制" class="headerlink" title="代理机制"></a>代理机制</h4><p>动态代理类（以下简称为代理类）是一种类，该类实现<code>创建类时(调用newProxyInstance方法时)</code>在运行时指定的<code>接口列表(interfaces参数)</code>，代理接口是由代理类实现的接口。代理实例是代理类的实例。<code>每个代理实例都有一个关联的调用处理程序对象，该对象实现接口InvocationHandler</code>。</p><p>通过其代理接口之一对代理实例进行的方法调用将分派给该实例的调用处理程序的invoke方法，并传递该<code>代理实例（proxy参数）</code>，一个标识所调用方法的<code>java.lang.reflect.Method对象（method参数）</code>以及一个数组包含参数的Object类型<code>（args参数）</code>。</p><h2 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上面我使用了动态代理，知道了动态代理一些优缺点，为了弥补Jdk动态代理的缺点，Cglib诞生了，被代理类无需实现接口也能被代理。</p><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><code>cglib</code>-字节码生成库是用于生成和转换Java字节码的高级API。AOP，测试，数据访问框架使用它来生成动态代理对象并拦截字段访问。</p><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> io.better.jdk.proxy.cglibproxy;<br><br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> better create in 2020/5/8 5:56 下午</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibBean</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">proxy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;proxy execute ....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object proxyTarget;<br><br>    <span class="hljs-keyword">public</span> CglibProxyFactory <span class="hljs-title function_">setProxyTarget</span><span class="hljs-params">(Object proxyTarget)</span> &#123;<br>        <span class="hljs-built_in">this</span>.proxyTarget = proxyTarget;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;cglib 执行前&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(proxyTarget, objects);<br>        System.out.println(<span class="hljs-string">&quot;cglib 执行后&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Objects.isNull(proxyTarget)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;被代理对象不能为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(proxyTarget.getClass());<br>        enhancer.setCallback(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCglib</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">CglibBean</span> <span class="hljs-variable">proxyTarget</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibBean</span>();<br>    <span class="hljs-type">CglibBean</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (CglibBean) <span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibProxyFactory</span>().setProxyTarget(proxyTarget).getProxyInstance();<br>    proxyInstance.proxy();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">cglib 执行前<br>proxy execute ....<br>cglib 执行后<br></code></pre></td></tr></table></figure><h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><p>从示例代码可以看出<code>Enhancer</code>类是创建代理对象的核心，那么Enhancer是如何创建代理类的呢？创建的代理类结构是如何呢？</p><p>在代码中一共操作了四部：</p><ol><li><p>创建Enhancer对象。</p></li><li><p>调用setSuperclass设置父类。</p></li><li><p>调用setCallback设置回调。</p></li><li><p>调用create创建代理实例。</p></li></ol><h4 id="创建Enhancer对象"><a href="#创建Enhancer对象" class="headerlink" title="创建Enhancer对象"></a>创建Enhancer对象</h4><h5 id="构造器描述"><a href="#构造器描述" class="headerlink" title="构造器描述"></a>构造器描述</h5><p>创建一个新的增强器。每个生成的对象都应使用一个新的Enhancer对象，并且不应在线程之间共享。要创建生成的类的其他实例，请使用Factory接口。</p><h5 id="继承图"><a href="#继承图" class="headerlink" title="继承图"></a>继承图</h5><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200509172422.png" alt="image-20200509104246223" style="zoom:50%;" /><h5 id="Enhancer构造器"><a href="#Enhancer构造器" class="headerlink" title="Enhancer构造器"></a>Enhancer构造器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Source</span> <span class="hljs-variable">SOURCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Source</span>(Enhancer.class.getName());<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Enhancer</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>(SOURCE);<br>&#125;<br><br><span class="hljs-comment">// 父类AbstractClassGenerator构造器</span><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractClassGenerator</span><span class="hljs-params">(Source source)</span> &#123;<br>  <span class="hljs-built_in">this</span>.source = source;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中将Enhancer的名称封装到了Source实例中，并调用父类AbstractClassGenerator构造器进行赋值 。</p><h4 id="设置父类"><a href="#设置父类" class="headerlink" title="设置父类"></a>设置父类</h4><h5 id="方法描述"><a href="#方法描述" class="headerlink" title="方法描述"></a>方法描述</h5><p>设置生成的类将继承的类。 为了方便起见，如果提供的超类实际上是接口，则将使用适当的参数来调用setInterfaces。 非接口参数不能声明为final，并且必须具有可访问的构造函数。</p><h5 id="方法setSuperclass"><a href="#方法setSuperclass" class="headerlink" title="方法setSuperclass"></a>方法<code>setSuperclass</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class superclass;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuperclass</span><span class="hljs-params">(Class superclass)</span> &#123;<br><span class="hljs-comment">// 如果为接口，则获取并调用setInterfaces方法</span><br>  <span class="hljs-keyword">if</span> (superclass != <span class="hljs-literal">null</span> &amp;&amp; superclass.isInterface()) &#123;<br>    setInterfaces(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123; superclass &#125;);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (superclass != <span class="hljs-literal">null</span> &amp;&amp; superclass.equals(Object.class)) &#123;<br>    <span class="hljs-comment">// affects choice of ClassLoader</span><br>    <span class="hljs-built_in">this</span>.superclass = <span class="hljs-literal">null</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 给superclass字段赋值</span><br>    <span class="hljs-built_in">this</span>.superclass = superclass;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Class[] interfaces;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInterfaces</span><span class="hljs-params">(Class[] interfaces)</span> &#123;<br>  <span class="hljs-built_in">this</span>.interfaces = interfaces;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法逻辑比较简单就是给Enhancer实例中的字段进行赋值。</p><h4 id="设置回调"><a href="#设置回调" class="headerlink" title="设置回调"></a>设置回调</h4><h5 id="方法描述-1"><a href="#方法描述-1" class="headerlink" title="方法描述"></a>方法描述</h5><p>设置要使用的单个回调。 如果使用createClass则被忽略。</p><h5 id="方法setCallback"><a href="#方法setCallback" class="headerlink" title="方法setCallback"></a>方法<code>setCallback</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Callback[] callbacks;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCallback</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback callback)</span> &#123;<br>    setCallbacks(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>[]&#123; callback &#125;);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCallbacks</span><span class="hljs-params">(Callback[] callbacks)</span> &#123;<br>  <span class="hljs-keyword">if</span> (callbacks != <span class="hljs-literal">null</span> &amp;&amp; callbacks.length == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Array cannot be empty&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">this</span>.callbacks = callbacks;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法也是给Enhancer实例中的<code>callbacks</code>字段进行赋值</p><h4 id="创建代理实例-1"><a href="#创建代理实例-1" class="headerlink" title="创建代理实例"></a>创建代理实例</h4><h5 id="方法描述-2"><a href="#方法描述-2" class="headerlink" title="方法描述"></a>方法描述</h5><p>如有必要，生成一个新类，并使用指定的回调（如果有）来创建一个新的对象实例。 使用超类的no-arg构造函数。</p><h5 id="入口-Enhancer-create"><a href="#入口-Enhancer-create" class="headerlink" title="入口-Enhancer.create"></a>入口-<code>Enhancer.create</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>    classOnly = <span class="hljs-literal">false</span>;<br>    argumentTypes = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> createHelper();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>createHelper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createHelper</span><span class="hljs-params">()</span> &#123;<br>  preValidate();<br>  <span class="hljs-type">Object</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> KEY_FACTORY.newInstance((superclass != <span class="hljs-literal">null</span>) ? superclass.getName() : <span class="hljs-literal">null</span>,<br>                                       ReflectUtils.getNames(interfaces),<br>                                       filter == ALL_ZERO ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakCacheKey</span>&lt;CallbackFilter&gt;(filter),<br>                                       callbackTypes,<br>                                       useFactory,<br>                                       interceptDuringConstruction,<br>                                       serialVersionUID);<br>  <span class="hljs-built_in">this</span>.currentKey = key;<br>  <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.create(key);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>KEY_FACTORY.newInstance</code>生成的<code>key</code>需要特别注意，后面在<code>生成代理类Class时会用此key与Class一对一绑定</code>。</p><p>继续查看父类的<code>create</code>方法。</p><h4 id="AbstractClassGenerator-create"><a href="#AbstractClassGenerator-create" class="headerlink" title="AbstractClassGenerator.create"></a><code>AbstractClassGenerator.create</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(Object key)</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> getClassLoader();<br>    Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;<br>    <span class="hljs-type">ClassLoaderData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> cache.get(loader);<br>    <span class="hljs-comment">// 忽略部分代码</span><br>    <span class="hljs-built_in">this</span>.key = key;<br>    <span class="hljs-comment">// 步骤①，创建代理类字节码核心入口</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> data.get(<span class="hljs-built_in">this</span>, getUseCache());<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Class) &#123;<br>      <span class="hljs-keyword">return</span> firstInstance((Class) obj);<br>    &#125;<br>    <span class="hljs-comment">// 步骤②，根据创建代理类实例</span><br>    <span class="hljs-keyword">return</span> nextInstance(obj);<br>  &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上诉代码中忽略了部分代码，重点关注<code>步骤①</code> 和<code>步骤②</code>对应的两个方法。</p><p>步骤①：调用<code>ClassLoaderData.get()</code>获取代理类Class对象。</p><p>步骤②：使用代理类Class对象创建代理实例。</p><h5 id="步骤①"><a href="#步骤①" class="headerlink" title="步骤①"></a>步骤①</h5><p>知道了代理对象是通过<code>ClassLoaderData.get</code>方法获取的，那么必须了解<code>ClassLoaderData</code>的作用及其结构。</p><h6 id="ClassLoaderData"><a href="#ClassLoaderData" class="headerlink" title="ClassLoaderData"></a><code>ClassLoaderData</code></h6><p>那么<code>ClassLoaderData</code>类有什么作用呢？通过Debug来看看ClassLoaderData内部结构。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200509172428.png" alt="image-20200509150401851"></p><p>类结构图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200509172432.png" alt="image-20200509150935264" style="zoom:50%;" /><p><code>generatedClasses</code>：用于存储已经生成的Class对象。</p><p><code>reservedClassNames</code>：用于存储已经解析的Class名称（全路径）。</p><p><code>classLoader</code>：加载生成Class对象的加载器。</p><p>可以看出ClassLoaderData内部管理生成的Class类和加载Class所需的ClassLoader，可以简单<code>理解为生成Class并存储Class的容器</code>。</p><h6 id="init"><a href="#init" class="headerlink" title="init"></a><code>init</code></h6><p>那么<code>ClassLoaderData</code>是如何初始化的呢 ？我们进入ClassLoaderData的构造器看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassLoaderData</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>  <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;classLoader == null is not yet supported&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 设置加载类使用的ClassLoader</span><br>  <span class="hljs-built_in">this</span>.classLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;ClassLoader&gt;(classLoader);<br>  <span class="hljs-comment">// 声明了load函数</span><br>  Function&lt;AbstractClassGenerator, Object&gt; load =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;AbstractClassGenerator, Object&gt;() &#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">apply</span><span class="hljs-params">(AbstractClassGenerator gen)</span> &#123;<br>      <span class="hljs-type">Class</span> <span class="hljs-variable">klass</span> <span class="hljs-operator">=</span> gen.generate(ClassLoaderData.<span class="hljs-built_in">this</span>);<br>      <span class="hljs-keyword">return</span> gen.wrapCachedClass(klass);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 在这里对generatedClasses做了初始化</span><br>  generatedClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadingCache</span>&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出<code>classLoader，generatedClasses</code>两个对象被进行了初始化，在这里重点注意<code>load</code>这个函数 ，<code>这个函数就是创建代理类Class的关键</code>。</p><h6 id="ClassLoaderData-get"><a href="#ClassLoaderData-get" class="headerlink" title="ClassLoaderData.get"></a><code>ClassLoaderData.get</code></h6><p>了解了<code>ClassLoaderData</code>后，我们进入 <code>get()</code>方法一探究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(AbstractClassGenerator gen, <span class="hljs-type">boolean</span> useCache)</span> &#123;<br><span class="hljs-comment">// useCache默认值为true</span><br>  <span class="hljs-keyword">if</span> (!useCache) &#123;<br>    <span class="hljs-keyword">return</span> gen.generate(ClassLoaderData.<span class="hljs-built_in">this</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 从缓存中获取缓存的对象</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cachedValue</span> <span class="hljs-operator">=</span> generatedClasses.get(gen);<br>    <span class="hljs-keyword">return</span> gen.unwrapCachedValue(cachedValue);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不修改useCache的值，代码最终会调用<code>generatedClasses.get</code>方法。到这里是不是感觉<code>generatedClasses</code>这个对象是不是非常眼熟，没错他就是<code>ClassLoaderData中存放生成过Class的对象</code>。</p><p>接着进入generatedClasses对象一探究竟。</p><h6 id="LoadingCache"><a href="#LoadingCache" class="headerlink" title="LoadingCache"></a><code>LoadingCache</code></h6><p>在如何<code>LoadingCache.get</code>方法前，我们先来看看<code>LoadingCache</code>的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上面ClassLoaderData构造器中最后一步会调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LoadingCache</span><span class="hljs-params">(Function&lt;K, KK&gt; keyMapper, Function&lt;K, V&gt; loader)</span> &#123;<br>    <span class="hljs-built_in">this</span>.keyMapper = keyMapper;  <span class="hljs-comment">// 用于获取 KEY_FACTORY.newInstance 创建的key的函数</span><br>    <span class="hljs-built_in">this</span>.loader = loader;   <span class="hljs-comment">// 用于生成代理类的Class函数</span><br>    <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;KK, Object&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>LoadingCache构造函数主要是在对<code>自身变量进行赋值</code>操作。</p><p><code>loader</code>：类型为函数，用于创建代理类Class</p><p><code>keyMapper</code>：类型为函数，用于获取前面<code>Enhancer.create</code>方法中通过<code>KEY_FACTORY.newInstance</code>创建的<code>key</code></p><p><code>map</code>：key&#x3D;<code>keyMapper函数获取到的key</code>，value&#x3D;<code>loader函数生成的代理Class数据</code>。</p><h6 id="LoadingCache-get"><a href="#LoadingCache-get" class="headerlink" title="LoadingCache.get"></a><code>LoadingCache.get</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>  <span class="hljs-comment">// 获取到 KEY_FACTORY.newInstance 创建的key</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">KK</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> keyMapper.apply(key);<br>  <span class="hljs-comment">// 查看是否已经存在</span><br>  <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> map.get(cacheKey);<br>  <span class="hljs-keyword">if</span> (v != <span class="hljs-literal">null</span> &amp;&amp; !(v <span class="hljs-keyword">instanceof</span> FutureTask)) &#123;<br>    <span class="hljs-keyword">return</span> (V) v;<br>  &#125;<br>  <span class="hljs-comment">// 不存在，则创建</span><br>  <span class="hljs-keyword">return</span> createEntry(key, cacheKey, v);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="LoadingCache-createEntry"><a href="#LoadingCache-createEntry" class="headerlink" title="LoadingCache.createEntry"></a><code>LoadingCache.createEntry</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> V <span class="hljs-title function_">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">final</span> K key, KK cacheKey, Object v)</span> &#123;<br>  <span class="hljs-comment">// key = AbstractClassGenerator</span><br>  <span class="hljs-comment">// cacheKey = Enhancer.EnhancerKey</span><br>  <br>  FutureTask&lt;V&gt; task;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">creator</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <br>  <span class="hljs-keyword">if</span> (v != <span class="hljs-literal">null</span>) &#123;<br>    task = (FutureTask&lt;V&gt;) v;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 创建一个Task</span><br>    task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;V&gt;() &#123;<br>      <span class="hljs-keyword">public</span> V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 到这来我们终于看到了ClassLoaderData构造器中声明的load函数被执行了</span><br>        <span class="hljs-comment">// (最后一步调用LoadingCache构造器，传递给LoadingCache.loader属性)</span><br>        <span class="hljs-keyword">return</span> loader.apply(key);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 缓存Key和Task放入到map中缓存</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">prevTask</span> <span class="hljs-operator">=</span> map.putIfAbsent(cacheKey, task);<br>    <span class="hljs-keyword">if</span> (prevTask == <span class="hljs-literal">null</span>) &#123;<br>      creator = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 执行Task</span><br>      task.run();<br>    &#125;<br>  &#125;<br><br>  V result;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取结果</span><br>    result = task.get();<br>  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br><br>  <span class="hljs-keyword">if</span> (creator) &#123;<br>    <span class="hljs-comment">// 将缓存Key和生成Class对象放入到map中</span><br>    map.put(cacheKey, result);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法主要是创建FutureTask用于异步创建Class对象，并对其结果进行了缓存，提高性能。</p><p>接下来调用<code>load.apply</code>执行函数，最终调用至<code>AbstractClassGenerator.generate</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;AbstractClassGenerator, Object&gt; load = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;AbstractClassGenerator, Object&gt;() &#123;<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">apply</span><span class="hljs-params">(AbstractClassGenerator gen)</span> &#123;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">klass</span> <span class="hljs-operator">=</span> gen.generate(ClassLoaderData.<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> gen.wrapCachedClass(klass);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="AbstractClassGenerator-generate"><a href="#AbstractClassGenerator-generate" class="headerlink" title="AbstractClassGenerator.generate"></a><code>AbstractClassGenerator.generate</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class <span class="hljs-title function_">generate</span><span class="hljs-params">(ClassLoaderData data)</span> &#123;<br>  Class gen;<br>  <span class="hljs-comment">// 从ThreadLocal获取对象，默认应该为null</span><br>  <span class="hljs-type">Object</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> CURRENT.get();<br>  <span class="hljs-comment">// 设置ThreadLocal，保证此AbstractClassGenerator不被线程共享</span><br>  CURRENT.set(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取到加载Class字节码使用的ClassLoader</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> data.getClassLoader();<br><br><span class="hljs-comment">// 步骤①</span><br>    <span class="hljs-type">byte</span>[] b = strategy.generate(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> ClassNameReader.getClassName(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(b));<br>    <span class="hljs-type">ProtectionDomain</span> <span class="hljs-variable">protectionDomain</span> <span class="hljs-operator">=</span> getProtectionDomain();<br>    <span class="hljs-keyword">synchronized</span> (classLoader) &#123; <span class="hljs-comment">// just in case</span><br>      <span class="hljs-keyword">if</span> (protectionDomain == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 步骤②</span><br>        gen = ReflectUtils.defineClass(className, b, classLoader);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 步骤②</span><br>        gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> gen;<br>  &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 置为null</span><br>    CURRENT.set(save);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤①：</p><p>调用<code>strategy.generate</code>方法生成代理类字节码数组。</p><p>其默认实例为<code>GeneratorStrategy strategy = DefaultGeneratorStrategy.INSTANCE;</code>。</p><p><code>strategy.generate</code>方法最终会调用到<code>Enhancer.generateClass(ClassVisitor v)</code>方法，这里面包含了生成代理类字节码具体步骤（这里了不做讲解，有兴趣的可自行查看）。</p><p>步骤②：</p><p>调用<code>ReflectUtils.defineClass</code>方法使用传入的ClassLoader加载生成的代理类字节码数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class <span class="hljs-title function_">defineClass</span><span class="hljs-params">(String className, <span class="hljs-type">byte</span>[] b, ClassLoader loader, ProtectionDomain protectionDomain)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  Class c;<br>  <span class="hljs-keyword">if</span> (DEFINE_CLASS != <span class="hljs-literal">null</span>) &#123;<br>    Object[] args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;className, b, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(b.length), protectionDomain &#125;;<br>    <span class="hljs-comment">// 步骤①，使用ClassLoader加载字节码信息 </span><br>    c = (Class)DEFINE_CLASS.invoke(loader, args);<br>  &#125; <br>  <span class="hljs-comment">// 忽略部分代码</span><br>  <br>  Class.forName(className, <span class="hljs-literal">true</span>, loader);<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method DEFINE_CLASS, DEFINE_CLASS_UNSAFE;<br></code></pre></td></tr></table></figure><p><code>DEFINE_CLASS</code>其实是<code>java.lang.ClassLoader.defineClass</code>对应的Method对象。</p><h5 id="步骤②"><a href="#步骤②" class="headerlink" title="步骤②"></a>步骤②</h5><p>走完步骤①代理类的Class对象已生成，接下来就是通过该Class对象生成代理实例。</p><p>我们进入<code>nextInstance(obj);</code>方法查看实例化流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">nextInstance</span><span class="hljs-params">(Object instance)</span> &#123;<br>  <span class="hljs-type">EnhancerFactoryData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (EnhancerFactoryData) instance;<br><br>  <span class="hljs-keyword">if</span> (classOnly) &#123;<br>    <span class="hljs-keyword">return</span> data.generatedClass;<br>  &#125;<br><br>  Class[] argumentTypes = <span class="hljs-built_in">this</span>.argumentTypes;<br>  Object[] arguments = <span class="hljs-built_in">this</span>.arguments;<br>  <span class="hljs-keyword">if</span> (argumentTypes == <span class="hljs-literal">null</span>) &#123;<br>    argumentTypes = Constants.EMPTY_CLASS_ARRAY;<br>    arguments = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-comment">// 步骤①</span><br>  <span class="hljs-keyword">return</span> data.newInstance(argumentTypes, arguments, callbacks);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法在调用代理类Class构造函数前，处理好对应的构造函数参数类型和参数。</p><p>重点关注步骤①：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Class[] argumentTypes, Object[] arguments, Callback[] callbacks)</span> &#123;<br>  setThreadCallbacks(callbacks);<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// Explicit reference equality is added here just in case Arrays.equals does not have one</span><br>    <span class="hljs-keyword">if</span> (primaryConstructorArgTypes == argumentTypes ||<br>        Arrays.equals(primaryConstructorArgTypes, argumentTypes)) &#123;<br><span class="hljs-comment">// 创建代理实例</span><br>      <span class="hljs-keyword">return</span> ReflectUtils.newInstance(primaryConstructor, arguments);<br>    &#125;<br>    <span class="hljs-comment">// 创建代理实例</span><br>    <span class="hljs-keyword">return</span> ReflectUtils.newInstance(generatedClass, argumentTypes, arguments);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    setThreadCallbacks(<span class="hljs-literal">null</span>);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>至此Cglib创建代理对象流程分析完毕。</p><h4 id="使用Cglib手动生成Class文件"><a href="#使用Cglib手动生成Class文件" class="headerlink" title="使用Cglib手动生成Class文件"></a>使用Cglib手动生成Class文件</h4><p>分析完Cglib整个创建流程，我还不能像Jdk动态代理一样了解到生成的代理类字节码到底是怎样的？接下来我们使用Cglib手动生成一个代理类的Class文件。</p><p>由于<code>strategy.generate</code>方法所需参数较为复杂，可<code>Debug</code>至<code>byte[] b = strategy.generate(this);</code>这行代码利用IDEA的<code>Evaluate Expression</code>功能手动输入以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;ManualGeneratorProxyCglibProxy.class&quot;</span>));<br>out.write(b);<br>out.flush();<br>out.close();<br></code></pre></td></tr></table></figure><p>生成文件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibBean$$EnhancerByCGLIB$$70184645</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CglibBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> CGLIB$BOUND;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object CGLIB$FACTORY_DATA;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;<br>  <span class="hljs-keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0; <span class="hljs-comment">// 我们自定义的MethodInterceptor</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object CGLIB$CALLBACK_FILTER;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method CGLIB$proxy$<span class="hljs-number">0</span>$Method;  <span class="hljs-comment">// CglibBean.proxy调用方法</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MethodProxy CGLIB$proxy$<span class="hljs-number">0</span>$Proxy;  <span class="hljs-comment">// CglibBean.proxy代理方法</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] CGLIB$emptyArgs;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$STATICHOOK1() &#123;<br>    CGLIB$THREAD_CALLBACKS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br>    CGLIB$emptyArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 通过反射得到代理类的Class对象</span><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;io.better.jdk.proxy.cglibproxy.CglibBean$$EnhancerByCGLIB$$70184645&quot;</span>);<br>    Class var1;<br>    <span class="hljs-comment">// 获取到被代理类所有的方法，找到proxy，返回类型为void的方法对应的Method对象</span><br>    CGLIB$proxy$<span class="hljs-number">0</span>$Method = ReflectUtils.findMethods(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;proxy&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>&#125;, (var1 = Class.forName(<span class="hljs-string">&quot;io.better.jdk.proxy.cglibproxy.CglibBean&quot;</span>)).getDeclaredMethods())[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 为proxy方法生成MethodProxy对象</span><br>    <span class="hljs-comment">// var1=被代理类的Class对象</span><br>    <span class="hljs-comment">// var2=代理类的Class对象</span><br>    CGLIB$proxy$<span class="hljs-number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-string">&quot;proxy&quot;</span>, <span class="hljs-string">&quot;CGLIB$proxy$0&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> CGLIB$proxy$<span class="hljs-number">0</span>() &#123;<br>    <span class="hljs-built_in">super</span>.proxy();<br>  &#125;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">proxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取到我们自定义的MethodInterceptor实例</span><br>    <span class="hljs-type">MethodInterceptor</span> <span class="hljs-variable">var10000</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.CGLIB$CALLBACK_0;<br>    <span class="hljs-keyword">if</span> (var10000 == <span class="hljs-literal">null</span>) &#123;<br>      CGLIB$BIND_CALLBACKS(<span class="hljs-built_in">this</span>);<br>      var10000 = <span class="hljs-built_in">this</span>.CGLIB$CALLBACK_0;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (var10000 != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 调用MethodInterceptor.intercept</span><br>      var10000.intercept(<span class="hljs-built_in">this</span>, CGLIB$proxy$<span class="hljs-number">0</span>$Method, CGLIB$emptyArgs, CGLIB$proxy$<span class="hljs-number">0</span>$Proxy);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">super</span>.proxy();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    CGLIB$STATICHOOK1();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上诉代码中忽略了<code>equals，hashCode，toString</code>等方法。感兴趣的同学可以自己操作一下。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li><li>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</li><li>动态代理生成的类为 lass com.sun.proxy.$Proxy4，cglib代理生成的类为class com.cglib.UserDao$$EnhancerByCGLIB$$552188b6。</li><li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li><li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li><li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类</li></ol>]]></content>
    
    
    <categories>
      
      <category>Proxy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-BeanDefinition读取</title>
    <link href="/2020/03/09/spring/04-spring-bean-definition-reader/"/>
    <url>/2020/03/09/spring/04-spring-bean-definition-reader/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-BeanDefinition的读取与注册"><a href="#Ioc-BeanDefinition的读取与注册" class="headerlink" title="Ioc-BeanDefinition的读取与注册"></a>Ioc-BeanDefinition的读取与注册</h1><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><blockquote><p> 本文主要讲述BeanDefinition的读取与注册，主要涉及到的接口是BeanDefinitionReader和BeanDefinitionRegistry。</p><p> 本文会从这两个接口出发，分析其实现类，不同环境的不同实现，及其优缺点。</p></blockquote><h2 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BeanDefinitionReader接口是个一个BeanDefinition的读取规范定义接口，定义了 “资源” 和 “字符串” 位置参数指定加载方法。</p><p>当然，具体的BeanDefinitionReader可以为BeanDefinition添加特定于其BeanDefinition格式的其他加载和注册方法。</p><p>具体的BeanDefinitionReader不必实现此接口。它仅对希望遵循标准命名约定的bean定义读者提供建议。</p><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180030.png" alt="image-20200516101622162"></p><p>老版本中经常使用的是<code>XMLBeanDefinitionReader</code>，注解驱动版本中经常使用<code>AnnotatedBeanDefinitionReader</code>。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionReader</span> &#123;<br><br>  <span class="hljs-comment">// 返回一个BeanFactory注册BeanDefinition，其实现了BeanDefinitionRegistry接口</span><br>  <span class="hljs-comment">// 封装了与BeanDefinition处理相关的方法。</span><br>  BeanDefinitionRegistry <span class="hljs-title function_">getRegistry</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 返回资源加载器以用于资源位置</span><br>  <span class="hljs-comment">// 可以检查ResourcePatternResolver接口并进行相应的转换，以针对给定的资源模式加载多个资源。</span><br>  <span class="hljs-comment">// 返回值为null表示此BeanDefinitionReader无法使用绝对资源加载</span><br>  ResourceLoader <span class="hljs-title function_">getResourceLoader</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 返回用于加载Bean的类加载器</span><br>  <span class="hljs-comment">// null建议不要急于加载Bean类，而只是用类名注册Bean定义，并在以后（或永不解析）相应的类。</span><br>  ClassLoader <span class="hljs-title function_">getBeanClassLoader</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 返回BeanNameGenerator用于匿名Bean名称（未指定显式Bean名称）。</span><br>  BeanNameGenerator <span class="hljs-title function_">getBeanNameGenerator</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 使用指定的Resource加载BeanDefinition</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>  <span class="hljs-comment">// 使用指定的Resource数组加载BeanDefinition</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>  <span class="hljs-comment">// 使用指定的location加载BeanDefinition</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>  <span class="hljs-comment">// 使用指定的location数组加载BeanDefinition</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br>&#125;<br></code></pre></td></tr></table></figure><p>BeanDefinitionReader重载了不同参数的<code>loadBeanDefinitions</code>方法用于加载BeanDefinition。</p><h3 id="AbstractBeanDefinitionReader"><a href="#AbstractBeanDefinitionReader" class="headerlink" title="AbstractBeanDefinitionReader"></a><code>AbstractBeanDefinitionReader</code></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>AbstractBeanDefinitionReader是实现了BeanDefinitionReader接口抽象基类。提供常见的属性，例如要处理的BeanFactory以及用于加载bean类的类加载器。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBeanDefinitionReader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionReader</span>, EnvironmentCapable &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanDefinitionRegistry registry;  <span class="hljs-comment">// BeanDefinition注册器</span><br>  <span class="hljs-keyword">private</span> ResourceLoader resourceLoader; <span class="hljs-comment">// 资源加载器</span><br>  <span class="hljs-keyword">private</span> ClassLoader beanClassLoader;<span class="hljs-comment">// 类加载器</span><br>  <span class="hljs-keyword">private</span> Environment environment;<span class="hljs-comment">// 环境变量</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">BeanNameGenerator</span> <span class="hljs-variable">beanNameGenerator</span> <span class="hljs-operator">=</span> DefaultBeanNameGenerator.INSTANCE;  <span class="hljs-comment">// Bean名称生成器</span><br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>    Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.registry = registry;<br><br>    <span class="hljs-comment">// 如果实现了资源加载器接口</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.registry <span class="hljs-keyword">instanceof</span> ResourceLoader) &#123;<br>      <span class="hljs-built_in">this</span>.resourceLoader = (ResourceLoader) <span class="hljs-built_in">this</span>.registry;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 创建默认资源加载器</span><br>      <span class="hljs-built_in">this</span>.resourceLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMatchingResourcePatternResolver</span>();<br>    &#125;<br>    <span class="hljs-comment">// 判断拥有环境变量信息</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.registry <span class="hljs-keyword">instanceof</span> EnvironmentCapable) &#123;<br>      <span class="hljs-built_in">this</span>.environment = ((EnvironmentCapable) <span class="hljs-built_in">this</span>.registry).getEnvironment();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 创建一个标准的环境变量对象</span><br>      <span class="hljs-built_in">this</span>.environment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEnvironment</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    Assert.notNull(resources, <span class="hljs-string">&quot;Resource array must not be null&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Resource resource : resources) &#123;<br>      <span class="hljs-comment">// 最终会调用子类实现的loadBeanDefinitions方法</span><br>      count += loadBeanDefinitions(resource);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractBeanDefinitionReader</code>对<code>BeanDefinitionReader</code>进行了简单的实现，声明<code>registry</code>，<code>resourceLoader</code>，<code>beanClassLoader</code>，<code>environment</code>，<code>beanNameGenerator</code>等属性。</p><h3 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a><code>XmlBeanDefinitionReader</code></h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>XmlBeanDefinitionReader用于读取XML，将实际的XML文档读取委托给<code>BeanDefinitionDocumentReader</code>接口的实现。</p><p>此类加载DOM Document 并将BeanDefinitionDocumentReader应用于该Document。</p><h4 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractBeanDefinitionReader</span> &#123;<br>    <span class="hljs-comment">// BeanDefinitionDocumentReader读取解析Document并转换成BeanDefinition</span><br>    <span class="hljs-keyword">private</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanDefinitionDocumentReader</span>&gt; documentReaderClass =<br>      DefaultBeanDefinitionDocumentReader.class;<br>    <span class="hljs-comment">// 命名空间解析器</span><br>    <span class="hljs-keyword">private</span> NamespaceHandlerResolver namespaceHandlerResolver;<br>    <span class="hljs-comment">// 将XML文件加载成Document对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DocumentLoader</span> <span class="hljs-variable">documentLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultDocumentLoader</span>();<br>    <span class="hljs-comment">// 用于解析XML中的DTD文件</span><br>    <span class="hljs-keyword">private</span> EntityResolver entityResolver;<br>    <span class="hljs-comment">// 绑定当前线程正在处理的XML文件集合 </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded =<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;XML bean definition resources currently being loaded&quot;</span>);<br><br>    <span class="hljs-comment">// 构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">XmlBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>      <span class="hljs-built_in">super</span>(registry);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现BeanDefinitionReader定义的接口</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>      <span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodedResource</span>(resource));<br>    &#125;<br><br>    <span class="hljs-comment">// 重载的loadBeanDefinitions方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>      <span class="hljs-comment">// 获取当前线程正在处理的XML集合</span><br>      Set&lt;EncodedResource&gt; currentResources = <span class="hljs-built_in">this</span>.resourcesCurrentlyBeingLoaded.get();<br>      <span class="hljs-keyword">if</span> (currentResources == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 为空则初始化</span><br>        currentResources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 默认大小为4</span><br>        <span class="hljs-built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!currentResources.add(encodedResource)) &#123;   <span class="hljs-comment">// 将当前正在处理的encodedResource添加到Set集合中</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<span class="hljs-comment">// 添加失败报错</span><br>          <span class="hljs-string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="hljs-string">&quot; - check your import definitions!&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 获取到XMl文件的输入流</span><br>      <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> encodedResource.getResource().getInputStream();<br>      <span class="hljs-comment">// 一个InputSource代表一个XML实体</span><br>      <span class="hljs-type">InputSource</span> <span class="hljs-variable">inputSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(inputStream);<br>      <span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 为InputSource设置编码</span><br>        inputSource.setEncoding(encodedResource.getEncoding());<br>      &#125;<br>      <span class="hljs-comment">// 调用doLoadBeanDefinitions方法(真正的执行操作)</span><br>      <span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>    &#125;<br>    <span class="hljs-comment">// 忽略部分代码</span><br>  &#125;<br><br>  <span class="hljs-comment">// 根据指定的XML文件加载BeanDefinition</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 使用documentLoader将XML转换成Document</span><br>      <span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> doLoadDocument(inputSource, resource);<br>      <span class="hljs-comment">// 注册BeanDefinition</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> registerBeanDefinitions(doc, resource);<br>      <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;&#125;<br>    <span class="hljs-keyword">catch</span> (SAXParseException ex) &#123;&#125;<br>    <span class="hljs-keyword">catch</span> (SAXException ex) &#123;&#125;<br>    <span class="hljs-keyword">catch</span> (ParserConfigurationException ex) &#123;&#125;<br>    <span class="hljs-keyword">catch</span> (IOException ex) &#123;&#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;&#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 将XML转换成Docment</span><br>  <span class="hljs-keyword">protected</span> Document <span class="hljs-title function_">doLoadDocument</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="hljs-built_in">this</span>.errorHandler,<br>                                            getValidationModeForResource(resource), isNamespaceAware());<br>  &#125;<br><br>  <span class="hljs-comment">// 注册BeanDefinition</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-comment">// 创建BeanDefinition文档读取器，</span><br>    <span class="hljs-type">BeanDefinitionDocumentReader</span> <span class="hljs-variable">documentReader</span> <span class="hljs-operator">=</span> createBeanDefinitionDocumentReader();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">countBefore</span> <span class="hljs-operator">=</span> getRegistry().getBeanDefinitionCount();<br>    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>    <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建BeanDefinitionDocumentReader对象，用于将Document解析成BeanDefinition</span><br>  <span class="hljs-keyword">protected</span> BeanDefinitionDocumentReader <span class="hljs-title function_">createBeanDefinitionDocumentReader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(<span class="hljs-built_in">this</span>.documentReaderClass);<br>  &#125;<br><br>  <span class="hljs-comment">// XmlReaderContext是ReaderContext的扩展，提供对XmlBeanDefinitionReader中配置的NamespaceHandlerResolver的访问。</span><br>  <span class="hljs-keyword">public</span> XmlReaderContext <span class="hljs-title function_">createReaderContext</span><span class="hljs-params">(Resource resource)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlReaderContext</span>(resource, <span class="hljs-built_in">this</span>.problemReporter, <span class="hljs-built_in">this</span>.eventListener,<br>                                <span class="hljs-built_in">this</span>.sourceExtractor, <span class="hljs-built_in">this</span>, getNamespaceHandlerResolver());<br>  &#125;<br><br>  <span class="hljs-comment">// 命名空间解析器</span><br>  <span class="hljs-keyword">public</span> NamespaceHandlerResolver <span class="hljs-title function_">getNamespaceHandlerResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.namespaceHandlerResolver == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-built_in">this</span>.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.namespaceHandlerResolver;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>XMLBeanDefinitionReader</code>实际上只做了<code>Document</code>文档的解析操作，真正的解析BeanDefinition操作交给了<code>BeanDefinitionDocumentReader</code>（接口）实例（默认为<code>DefaultBeanDefinitionDocumentReader</code>）来解析。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>Xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;iocBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.better.spring.ioc.IocBean&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test-xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testXmlBeanDefinitionReader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br><br>    <span class="hljs-type">BeanDefinitionReader</span> <span class="hljs-variable">definitionReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(applicationContext);<br>    definitionReader.loadBeanDefinitions(<span class="hljs-string">&quot;Ioc.xml&quot;</span>);<br><br>    applicationContext.refresh();<br><br>    <span class="hljs-type">IocBean</span> <span class="hljs-variable">iocBean</span> <span class="hljs-operator">=</span> (IocBean) applicationContext.getBean(<span class="hljs-string">&quot;iocBean&quot;</span>);<br>    System.out.println(iocBean);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">IocBean Constructor<br>IocBean custom init<br>IocBean&#123;name=&#x27;test-xml&#x27;&#125;<br></code></pre></td></tr></table></figure><h4 id="BeanDefinitionDocumentReader"><a href="#BeanDefinitionDocumentReader" class="headerlink" title="BeanDefinitionDocumentReader"></a>BeanDefinitionDocumentReader</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>SPI，<code>BeanDefinitionDocumentReader</code>用于解析带有BeanDefinition的Xml Document。</p><h5 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionDocumentReader</span> &#123;<br><br>  <span class="hljs-comment">//注册BeanDefinition，doc：当前Xml对应的Document对象，readerContext：当前BeanDefinitionReader的长下文</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DefaultBeanDefinitionDocumentReader"><a href="#DefaultBeanDefinitionDocumentReader" class="headerlink" title="DefaultBeanDefinitionDocumentReader"></a>DefaultBeanDefinitionDocumentReader</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>BeanDefinitionDocumentReader的唯一实现类，封装了解析并组装BeanDefinition的具体操作。</p><h5 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultBeanDefinitionDocumentReader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionDocumentReader</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BEAN_ELEMENT</span> <span class="hljs-operator">=</span> BeanDefinitionParserDelegate.BEAN_ELEMENT;<br><br><span class="hljs-comment">// 常量，标识一些标签</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NESTED_BEANS_ELEMENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;beans&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ALIAS_ELEMENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alias&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME_ATTRIBUTE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;name&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ALIAS_ATTRIBUTE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alias&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">IMPORT_ELEMENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;import&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">RESOURCE_ATTRIBUTE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;resource&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PROFILE_ATTRIBUTE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;profile&quot;</span>;<br><br>  <span class="hljs-comment">// 当前BeanDefinitionReader的上下文</span><br>  <span class="hljs-keyword">private</span> XmlReaderContext readerContext;<br><span class="hljs-comment">// 解析Document中的值并赋值给BeanDefinition</span><br>  <span class="hljs-keyword">private</span> BeanDefinitionParserDelegate delegate;<br><br>  <span class="hljs-comment">// 核心入口</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> &#123;<br>    <span class="hljs-built_in">this</span>.readerContext = readerContext;<br>    doRegisterBeanDefinitions(doc.getDocumentElement());<br>  &#125;<br><br>  <span class="hljs-comment">// 核心方法</span><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> &#123;<br><br>    <span class="hljs-type">BeanDefinitionParserDelegate</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.delegate;<br>    <span class="hljs-built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<br><br><span class="hljs-comment">// 处理Xml前置操作</span><br>    preProcessXml(root);<br>    <span class="hljs-comment">// 解析BeanDefinition</span><br>    parseBeanDefinitions(root, <span class="hljs-built_in">this</span>.delegate);<br>    <span class="hljs-comment">// 处理Xml后置操作</span><br>    postProcessXml(root);<br><br>    <span class="hljs-built_in">this</span>.delegate = parent;<br>  &#125;<br><br>  <span class="hljs-comment">// 解析BeanDefinition核心方法</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;<br>      <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> root.getChildNodes();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>        <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123; <span class="hljs-comment">// 是否是元素标签</span><br>          <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) node;<br>          <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;<br>            <span class="hljs-comment">// 处理默认元素</span><br>            parseDefaultElement(ele, delegate);<br>          &#125;<br>          <span class="hljs-keyword">else</span> &#123;<br>            delegate.parseCustomElement(ele);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      delegate.parseCustomElement(root);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 解析默认元素</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-comment">// import标签</span><br>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;<br>      importBeanDefinitionResource(ele);<br>    &#125;<br>    <span class="hljs-comment">// alias标签</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;<br>      processAliasRegistration(ele);<br>    &#125;<br>    <span class="hljs-comment">// beans标签</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;<br>      processBeanDefinition(ele, delegate);<br>    &#125;<br>    <span class="hljs-comment">// 内嵌bean标签</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;<br>      <span class="hljs-comment">// recurse</span><br>      doRegisterBeanDefinitions(ele);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 解析beans标签，并调用registry进行注册</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-comment">// BeanDefinitionHolder内部包装了一个BeanDefinition</span><br>    <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">bdHolder</span> <span class="hljs-operator">=</span> delegate.parseBeanDefinitionElement(ele);<br>    <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-literal">null</span>) &#123;<br>      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>      <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 注册BeanDefinition</span><br>        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;&#125;<br>      <span class="hljs-comment">// 发布注册完成事件</span><br>      getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComponentDefinition</span>(bdHolder));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>DefaultBeanDefinitionDocumentReader</code>中处理<code>Bean标签</code>的逻辑交给了<code>BeanDefinitionParserDelegate</code>对象来进行操作，并通过<code>XmlReaderContext</code>获取到<code>Registry</code>，最后将解析好的BeanDefinition注册进容器。</p><p>伴随着Xml方法的繁琐，笨重，Spring在4.2版本后提供了注解配置的方式来替换Xml配置的方法，那么注解是怎样读取 BeanDefinition的呢？</p><h3 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a><code>AnnotatedBeanDefinitionReader</code></h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>AnnotatedBeanDefinitionReader是个方便的适配器，用于以编程方式注册Bean类。这是<code>ClassPathBeanDefinitionScanner</code>的替代方法，它应用注解的相同解析，但仅适用于显式注册的类。</p><p><strong>该类不仅仅读取BeanDefinition，同时会注册BeanDefinition。</strong></p><h4 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotatedBeanDefinitionReader</span> &#123;<br><span class="hljs-comment">// BeanDefinition注册器</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanDefinitionRegistry registry;<br><span class="hljs-comment">// Bean名称生成器</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">BeanNameGenerator</span> <span class="hljs-variable">beanNameGenerator</span> <span class="hljs-operator">=</span> AnnotationBeanNameGenerator.INSTANCE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">ScopeMetadataResolver</span> <span class="hljs-variable">scopeMetadataResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationScopeMetadataResolver</span>();<br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">private</span> ConditionEvaluator conditionEvaluator;<br><br>  <span class="hljs-comment">// 构造函数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotatedBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-built_in">this</span>(registry, getOrCreateEnvironment(registry));<br>  &#125;<br><br>  <span class="hljs-comment">// 使用指定的Class数组注册Bean</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;<br>      registerBean(componentClass);<br>    &#125;<br>  &#125;<br><br><span class="hljs-comment">// 使用执行的Class注册Bean</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> &#123;<br>    doRegisterBean(beanClass, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>  &#125;<br><br> <span class="hljs-comment">// 使用指定的Class和名称注册Bean</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-meta">@Nullable</span> String name)</span> &#123;<br>    doRegisterBean(beanClass, name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>  &#125;<br>  <br><span class="hljs-comment">// 使用指定的Class和Annotation Class数组注册Bean</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass, Class&lt;? extends Annotation&gt;... qualifiers)</span> &#123;<br>    doRegisterBean(beanClass, <span class="hljs-literal">null</span>, qualifiers, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 忽略部分重载的registerBean方法</span><br><br>  <span class="hljs-comment">// 真正执行注册BeanDefinition的地方</span><br>  <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass, String name,</span><br><span class="hljs-params">                                  Class&lt;? extends Annotation&gt;[] qualifiers, Supplier&lt;T&gt; supplier,</span><br><span class="hljs-params">                                  BeanDefinitionCustomizer[] customizers)</span> &#123;<br><span class="hljs-comment">// 创建BeanDefinition</span><br>    <span class="hljs-type">AnnotatedGenericBeanDefinition</span> <span class="hljs-variable">abd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedGenericBeanDefinition</span>(beanClass);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    abd.setInstanceSupplier(supplier);<br>    <span class="hljs-comment">// 解析BeanDefinition的作用域</span><br>    <span class="hljs-type">ScopeMetadata</span> <span class="hljs-variable">scopeMetadata</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);<br>    abd.setScope(scopeMetadata.getScopeName());<br>    <span class="hljs-comment">// 生成Bean名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> (name != <span class="hljs-literal">null</span> ? name : <span class="hljs-built_in">this</span>.beanNameGenerator.generateBeanName(abd, <span class="hljs-built_in">this</span>.registry));<br><br>    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);<br>    <span class="hljs-comment">// 处理Bean上声明的注解信息</span><br>    <span class="hljs-keyword">if</span> (qualifiers != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">for</span> (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; qualifier : qualifiers) &#123;<br>        <span class="hljs-keyword">if</span> (Primary.class == qualifier) &#123;<br>          abd.setPrimary(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 唯一</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Lazy.class == qualifier) &#123;<br>          abd.setLazyInit(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 懒加载</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          abd.addQualifier(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AutowireCandidateQualifier</span>(qualifier));<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 定制BeanDefinition，与BeanDefinitionBuilder.applyCustomizers 用法一致</span><br>    <span class="hljs-keyword">if</span> (customizers != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;<br>        customizer.customize(abd);<br>      &#125;<br>    &#125;<br><span class="hljs-comment">// 生成BeanDefinitionHolder</span><br>    <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">definitionHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(abd, beanName);<br>    <span class="hljs-comment">// 创建作用域代理</span><br>    definitionHolder = <br>      AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>    <span class="hljs-comment">// 向容器中注册Bean</span><br>    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出AnnotatedBeanDefinitionReader注册Bean的方法明显比XmlBeanDefinitionReader的处理方式简单了很多，</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnnotatedBeanDefinitionReader</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 创建ApplicationContext</span><br>  <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(IocBean.class);<br><span class="hljs-comment">// 获取Bean</span><br>  <span class="hljs-type">IocBean</span> <span class="hljs-variable">iocBean</span> <span class="hljs-operator">=</span> applicationContext.getBean(IocBean.class);<br>  System.out.println(iocBean);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AnnotationConfigApplicationContext</code>类中声明了<code>AnnotatedBeanDefinitionReader</code>，<code>ClassPathBeanDefinitionScanner</code>对象，并在构造函数中做了初始化。</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180020.png" alt="image-20200517154640954" style="zoom:50%;" /><p><code>ClassPathBeanDefinitionScanner</code>用于扫描<code>ClassPath</code>下带<code>@Component，@Repository，@Service，@Controller</code>注解的类。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此BeanDefinitionReader的分析完成，我们一共分析了两个BeanDefinitionReader规范实现，分别对应<code>Xml读取（XmlBeanDefinitionReader）</code>和<code>注解读取（AnnotatedBeanDefinitionReader）</code>。</p><p><code>XmlBeanDefinitionReader</code>：内部将BeanDefinition的读取交给了BeanDefinitionDocumentReader来进行操作。</p><p><code>AnnotatedBeanDefinitionReader</code>：不仅能读取BeanDefinition，并且还能注册BeanDefinition。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reflection-反射</title>
    <link href="/2020/02/06/java/reflection/"/>
    <url>/2020/02/06/java/reflection/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲述Java中Reflection反射相关的API使用，以及一些常见问题。</p><span id="more"></span><h1 id="Jdk-Reflection"><a href="#Jdk-Reflection" class="headerlink" title="Jdk-Reflection"></a>Jdk-Reflection</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以让我们在运行期实例化对象，调用方法，通过调用get&#x2F;set方法获取变量的值。</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>Class的实例表示正在运行的Java应用程序的类和接口</code>。 枚举是一种类和注释是一种接口。</p><p>每个数组都属于一个被映射成Class对象的类，该对象由具有相同元素类型和大小的所有数组共享。 </p><p>原始类型<code>(boolean， byte， char， short， int， long， float，double)</code>，以及关键字<code>void</code>也表示为Class对象。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><strong>Class没有公共构造函数。 相反， Class对象由Java虚拟机的类加载并通过调用自动构造defineClass的类加载器方法</strong>。</p><h3 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h3><p>获取Class对象的方式一共有三种：通过<code>Class.forName(&quot;全路径包名&quot;)，类.class，类实例.getClass()</code>。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; stringClass = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>Class&lt;?&gt; integerClass = String.class;<br>Class&lt;?&gt; stringObjClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>).getClass();<br><br>System.out.println(stringClass == integerClass);<br>System.out.println(stringObjClass == integerClass);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">true<br>true<br></code></pre></td></tr></table></figure><p>输出的结果证实了相同元素类型的Class实例是相同且共享的。</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>在这个阶段会讲述Class类中常用方法的使用</p><p><code>ReflectionBean</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassBean</span> &#123;<br><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> Integer age;<br>  String phone;<br>  <span class="hljs-keyword">protected</span> String address;<br>  <span class="hljs-keyword">public</span> Boolean sex;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reflection</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reflection</span><span class="hljs-params">(String name)</span> &#123;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validInfo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name != <span class="hljs-literal">null</span> &amp;&amp; name.length() &gt; <span class="hljs-number">0</span> &amp;&amp; Objects.nonNull(age);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReflectionBean</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">ReflectionBean</span><span class="hljs-params">(String name, Integer age)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReflectionBean</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReflectionBean <span class="hljs-title function_">instance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionBean</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ClassBean</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassBean</span> &#123;<br>    <span class="hljs-keyword">private</span> String className;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validClassName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> className != <span class="hljs-literal">null</span> &amp;&amp; className.length() &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassBean</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassBean</span><span class="hljs-params">(String className)</span> &#123;<br>        <span class="hljs-built_in">this</span>.className = className;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Construtor"><a href="#Construtor" class="headerlink" title="Construtor"></a><code>Construtor</code></h4><p>一个<code>Constructor</code>对应着类中的一个构造函数，可以使用<code>Class.getConstructors()</code>获取指定类所有的构造函数(私有无法获取)。也可以使用<code>Class.getConstructor(Class&lt;?&gt; ... paramType)</code>获取指定参数的构造方法。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br><br>    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br>    Constructor&lt;ReflectionBean&gt; specificConstructor = reflectionBeanClass.getConstructor(String.class);<br><br>    System.out.println(specificConstructor.getName());<br>    System.out.println(Arrays.toString(specificConstructor.getParameterAnnotations()));<br>    System.out.println(specificConstructor.getParameterCount());<br>    System.out.println(Arrays.toString(specificConstructor.getParameterTypes()));<br><br>    Constructor&lt;?&gt;[] constructors = reflectionBeanClass.getConstructors();<br>    System.out.println(Arrays.toString(constructors));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">io.better.jdk.reflection.ReflectionBean<br>[[Ljava.lang.annotation.Annotation;@1b701da1]<br>1<br>[class java.lang.String]<br>[public io.better.jdk.reflection.ReflectionBean(java.lang.String), public io.better.jdk.reflection.ReflectionBean()]<br></code></pre></td></tr></table></figure><p>上面代码中演示了<code>Class.getConstructors</code>和<code>Class.getConstructor(Class&lt;?&gt; ..params)</code>获取构造方法。</p><p>通过Constructor对象我们可以获取到构造方法中的<code>注解，参数，参数类型，参数数量</code>等信息，但这两种方式都不能获取私有构造方法。那如何获取私有的构造器呢？</p><p>使用<code>getDeclaredConstructors()</code>和<code>getDeclaredConstructor(Class&lt;?&gt; ..params)</code>可以获取到类中所有的构造方法，包括私有的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetDeclaredConstructors</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br><br>  <span class="hljs-comment">// 获取所有构造方法，包括私有</span><br>  Constructor&lt;?&gt;[] declaredConstructors = reflectionBeanClass.getDeclaredConstructors();<br>  <span class="hljs-comment">// 获取指定构造方法</span><br>  Constructor&lt;ReflectionBean&gt; specificDeclaredConstructor = reflectionBeanClass.getDeclaredConstructor(String.class, Integer.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>介绍完<code>Constructor</code>对象的获取方式后，接下来通过<code>Constructor</code>对象来实例化目标对象。</p><p>我们可以通过<code>Constructor.newInstance(Object ...params)</code>方法传入实际的参数来创建目标对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConstructorInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br>  <span class="hljs-comment">// 获取指定参数的公共构造方法</span><br>  Constructor&lt;ReflectionBean&gt; stringConstructor = reflectionBeanClass.getConstructor(String.class);<br>  <span class="hljs-comment">// 实例化</span><br>  <span class="hljs-type">ReflectionBean</span> <span class="hljs-variable">reflectionBean</span> <span class="hljs-operator">=</span> stringConstructor.newInstance(<span class="hljs-string">&quot;Constructor&quot;</span>);<br>  <br>  System.out.println(reflectionBean);<br>  <span class="hljs-comment">// 获取指定参数的私有构造方法</span><br>  Constructor&lt;ReflectionBean&gt; declaredConstructor = reflectionBeanClass.getDeclaredConstructor(String.class, Integer.class);<br>  <span class="hljs-comment">// 设置成可访问，不设置，会出现访问私有构造方法</span><br>  declaredConstructor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 实例化</span><br>  reflectionBean = declaredConstructor.newInstance(<span class="hljs-string">&quot;DeclaredConstructor&quot;</span>, <span class="hljs-number">1</span>);<br>  System.out.println(reflectionBean);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a><code>Method</code></h4><p>讲完<code>Constructor</code>的使用，已经能通过其创建对象了，那如何调用目标对象中的方法呢？</p><p>与Constructor类似，Class提供了<code>getMethods，getMethod(String methodName, Class&lt;?&gt; ...paramType)</code>方法分别获取执行类的<code>所有方法(包括静态方法，父类继承下来的方法)</code>和<code>指定方法</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br><br>    Method[] methods = reflectionBeanClass.getMethods();<br><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> reflectionBeanClass.getMethod(<span class="hljs-string">&quot;reflection&quot;</span>, String.class);<br>    System.out.println(<span class="hljs-string">&quot;指定方法: &quot;</span> + method.getName());<br><br>    <span class="hljs-keyword">for</span> (Method item : methods) &#123;<br>        System.out.println(item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200506163345.png" alt="image-20200506141809485"></p><p>从结果可以看出，私有方法未被获取到，和Constructor类似这两个方法不能获取私有方法，要想获取私有方法必须使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetDeclaredMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br><span class="hljs-comment">// 获取所有方法，包括私有方法</span><br>    Method[] methods = reflectionBeanClass.getDeclaredMethods();<br><span class="hljs-comment">// 获取指定私有方法</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> reflectionBeanClass.getDeclaredMethod(<span class="hljs-string">&quot;validInfo&quot;</span>);<br>    System.out.println(method.getName());<br><span class="hljs-comment">// 获取到所有方法的方法名</span><br>    List&lt;String&gt; methodName = Stream.of(methods).map(Method::getName).collect(Collectors.toList());<br>    System.out.println(methodName);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">validInfo<br>[equals, toString, hashCode, getName, setName, instance, reflection, reflection, validInfo, canEqual, getAge, setAge]<br></code></pre></td></tr></table></figure><p>获取类中方法已经了解，接下一来尝试调用执行一下方法。</p><p>与Constructor不太一样，要想执行方法需要调用<code>invoke(Object obj, Object... args)</code>。该方法接受两个参数，第一个为目标对象(即拥有此方法的类对象)，第二为方法所需的参数。当调用私有方法时做法与Constructor一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInvokedMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br>  Constructor&lt;ReflectionBean&gt; constructor = reflectionBeanClass.getDeclaredConstructor(String.class, Integer.class);<br>  constructor.setAccessible(<span class="hljs-literal">true</span>);<br>  <span class="hljs-type">ReflectionBean</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;TEST&quot;</span>, <span class="hljs-number">1</span>);<br><br>  <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> reflectionBeanClass.getDeclaredMethod(<span class="hljs-string">&quot;validInfo&quot;</span>);<br>  method.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 执行方法，获取结果</span><br>  <span class="hljs-type">Object</span> <span class="hljs-variable">methodResult</span> <span class="hljs-operator">=</span> method.invoke(object);<br>  System.out.println(methodResult);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a><code>Field</code></h4><p>与Method类似，我们可以使用<code>getFields，getField(String name)</code>两个方法来获取类中所有非私有的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br><br>    Field[] fields = reflectionBeanClass.getFields();<br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        System.out.println(field);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 结果：public java.lang.Boolean io.better.jdk.reflection.ReflectionBean.sex</span><br></code></pre></td></tr></table></figure><p>这两个方法只能获取<code>公共字段(public修饰)</code>，<code>private，default，protected</code>都获取不到。</p><p>我们可以使用<code>getDeclaredFields</code>，<code>getDeclaredField</code>两个方法来获取所有的字段和指定字段，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetDeclaredField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br><br>    Field[] fields = reflectionBeanClass.getDeclaredFields();<br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        System.out.println(field);<br>    &#125;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> reflectionBeanClass.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>    System.out.println(age);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200506163353.png" alt="image-20200506150309477" style="zoom:50%;" /><p>如果想要获取某个字段对应的值，则需要调用<code>get(Object obj)</code>方法，传入包含此字段的目标类对象，私有字段需要调用<code>setAccessible()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFieldMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br><br>    Constructor&lt;ReflectionBean&gt; constructor = reflectionBeanClass.getDeclaredConstructor(String.class, Integer.class);<br>    constructor.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ReflectionBean</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;TEST&quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> reflectionBeanClass.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>    age.setAccessible(<span class="hljs-literal">true</span>);<br>    System.out.println(age.getDeclaringClass());<br>    System.out.println(age.get(object));<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br><span class="hljs-comment">// class io.better.jdk.reflection.ReflectionBean</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Constructor，Method，Field</code>三个类分别 对应类中 的<code>构造方法、方法、字段</code>，分别提供了<code>getDeclared</code>开头的方法来获取对应所有的信息。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance()"></a><code>newInstance()</code></h4><p>在获取到类的Class对象时，可以通过调用此方法来创建目标类对象，该方法会默认调用类的<code>无参构造方法</code>来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNewInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<br>  <span class="hljs-type">ReflectionBean</span> <span class="hljs-variable">reflectionBean</span> <span class="hljs-operator">=</span> reflectionBeanClass.newInstance();<br>  System.out.println(reflectionBean);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="isInstance-Object-obj"><a href="#isInstance-Object-obj" class="headerlink" title="isInstance(Object obj)"></a><code>isInstance(Object obj)</code></h4><p>该方法用于断定指定Object是赋值兼容与此表示的对象Class ，等效<code>instanceof</code>运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;String&gt; stringClass = String.class;<br><br>stringClass.isInstance(<span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// 结果=true，类型匹配</span><br>stringClass.isInstance(<span class="hljs-number">123456</span>); <span class="hljs-comment">// 结果=false，类型不匹配</span><br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="反射进行数组扩容"><a href="#反射进行数组扩容" class="headerlink" title="反射进行数组扩容"></a>反射进行数组扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testArrayExtension</span><span class="hljs-params">()</span> &#123;<br>  String[] stringArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>&#125;;<br>  System.out.println(<span class="hljs-string">&quot;原始数组长度: &quot;</span> + stringArray.length);<br><br>  <span class="hljs-type">Object</span> <span class="hljs-variable">newStringArray</span> <span class="hljs-operator">=</span> ArrayExtension(stringArray, stringArray.length * <span class="hljs-number">2</span>);<br>  System.out.println(<span class="hljs-string">&quot;扩容后数组长度: &quot;</span> + Array.getLength(newStringArray));<br>&#125;<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">ArrayExtension</span><span class="hljs-params">(Object sourceArray, <span class="hljs-type">int</span> extensionLength)</span> &#123;<br>  <span class="hljs-keyword">if</span> (extensionLength &lt; Array.getLength(sourceArray))<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;扩展长度不合法&quot;</span>);<br><br>  Class&lt;?&gt; componentType = sourceArray.getClass().getComponentType();<br>  <span class="hljs-type">Object</span> <span class="hljs-variable">newStringArray</span> <span class="hljs-operator">=</span> Array.newInstance(componentType, extensionLength);<br>  System.arraycopy(sourceArray, <span class="hljs-number">0</span>, newStringArray, <span class="hljs-number">0</span>, Array.getLength(sourceArray));<br><br>  <span class="hljs-keyword">return</span> newStringArray;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射跳过泛型检查"><a href="#反射跳过泛型检查" class="headerlink" title="反射跳过泛型检查"></a>反射跳过泛型检查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testJumpTypeCheck</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  stringList.add(<span class="hljs-string">&quot;a&quot;</span>);<br>  stringList.add(<span class="hljs-string">&quot;b&quot;</span>);<br>  stringList.add(<span class="hljs-string">&quot;c&quot;</span>);<br><br>  Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">List</span>&gt; listClass = stringList.getClass();<br><br>  <span class="hljs-type">Method</span> <span class="hljs-variable">addMethod</span> <span class="hljs-operator">=</span> listClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>  <span class="hljs-comment">// 向集合中添加了一个int类型的值</span><br>  addMethod.invoke(stringList, <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 结果为4</span><br>  System.out.println(stringList.size());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reflection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Reflection</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-BeanDefinition注册</title>
    <link href="/2020/01/09/spring/05-spring-bean-definition-registry/"/>
    <url>/2020/01/09/spring/05-spring-bean-definition-registry/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-Bean注册"><a href="#Ioc-Bean注册" class="headerlink" title="Ioc-Bean注册"></a>Ioc-Bean注册</h1><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><blockquote><p>本文主要讲述BeanDefinitionRegistry接口是如何注册BeanDefinition？</p><p>主要讲解DefaultListableBeanFactory，AnnotationConfigApplicationContext，GenericApplicationContext三个上下文是如何对BeanDefinition进行注册的。</p></blockquote><h2 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上面讲到了BeanDefinition的读取方式，拿到BeanDefinition后需要将其注册到容器中，Spring是用什么将其注册到容器中的呢？</p><p>没错就是上面源代码中频繁提到的BeanDefinitionRegistry对象。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BeanDefinitionRegistry是包含BeanDefinition的注册的接口，这是Spring Bean工厂软件包中唯一封装Bean定义注册的接口。</p><p>标准BeanFactory接口仅涵盖对完全配置的工厂实例的访问。Spring的<code>BeanDefinitionReader</code>希望可以使用此接口的实现。</p><p>Spring核心中的已知实现者是<code>DefaultListableBeanFactory</code>和<code>GenericApplicationContext</code>。</p><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180016.png" alt="image-20200517161204618" style="zoom:50%;" /><p>我们看到了<code>DefaultListableBeanFactory</code>、<code>GenericApplicationContext</code>、<code>AnnotationConfigApplicationContext</code>等类。</p><p>重点关注上面几个类的实现。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AliasRegistry</span> &#123;<br>  <span class="hljs-comment">// 注册BeanDefinition</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>  <span class="hljs-comment">// 根据指定的Bean名称删除BeanDefinition</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>  <span class="hljs-comment">// 根据指定的Bean名称获取BeanDefinition</span><br>  BeanDefinition <span class="hljs-title function_">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>  <span class="hljs-comment">// 是否包含指定的Bean名称</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span>;<br><br>  <span class="hljs-comment">// 返回注册器中所有的BeanDefinition名称</span><br>  String[] getBeanDefinitionNames();<br><br> <span class="hljs-comment">// 获取BeanDefinition的数量</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">getBeanDefinitionCount</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 指定的Bean名称是否被使用</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBeanNameInUse</span><span class="hljs-params">(String beanName)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口中定义了BeanDefinition增删改查的接口，并继承了AliasRegistry接口。</p><h3 id="AliasRegistry"><a href="#AliasRegistry" class="headerlink" title="AliasRegistry"></a><code>AliasRegistry</code></h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>顾名思义AliasRegistry是一个别名注册器，用于注册别名。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AnnotationConfigRegistry</span> &#123;<br><br>  <span class="hljs-comment">// 注册指定的Class数组</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span>;<br><br>  <span class="hljs-comment">// 注册指定包路径下的Bean</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(String... basePackages)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="GenericApplicationContext"><a href="#GenericApplicationContext" class="headerlink" title="GenericApplicationContext"></a><code>GenericApplicationContext</code></h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>GenericApplicationContext是通用ApplicationContext实现，其内部引用了<code>DefaultListableBeanFactory</code>实例，实现BeanDefinitionRegistry接口，以便允许将任何Bean定义读取器应用于该接口。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>通用做法是通过BeanDefinitionRegistry接口注册各种Bean定义，然后调用<code>refresh()</code>以使用应用程序上下文语义来初始化这些Bean（处理org.springframework.context.ApplicationContextAware，自动检测BeanFactoryPostProcessors等）。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>与为每次刷新创建一个新的内部BeanFactory实例的其他ApplicationContext实现相反，此上下文的内部BeanFactory从一开始就可用，以便能够在其上注册BeanDefinition。<code>refresh()只能被调用一次</code>。</p><p>对于应该以可刷新方式读取特殊bean定义格式的自定义应用程序上下文实现，请考虑从<strong>AbstractRefreshableApplicationContext</strong>基类派生。</p><h4 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistry</span> &#123;<br><span class="hljs-comment">// BeanFactory，此对象也实现了BeanDefinitionRegistry接口</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DefaultListableBeanFactory beanFactory;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">GenericApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.beanFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 注册BeanDefinition</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><br>    <span class="hljs-built_in">this</span>.beanFactory.registerBeanDefinition(beanName, beanDefinition);<br>  &#125;<br><span class="hljs-comment">// 删除BeanDefinition</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException &#123;<br>    <span class="hljs-built_in">this</span>.beanFactory.removeBeanDefinition(beanName);<br>  &#125;<br><br>  <span class="hljs-comment">// 获取BeanDefinition</span><br>  <span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanFactory.getBeanDefinition(beanName);<br>  &#125;<br><br><span class="hljs-comment">// Bean是否被使用</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBeanNameInUse</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanFactory.isBeanNameInUse(beanName);<br>  &#125;<br><br>  <span class="hljs-comment">// 注册bean别名</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerAlias</span><span class="hljs-params">(String beanName, String alias)</span> &#123;<br>    <span class="hljs-built_in">this</span>.beanFactory.registerAlias(beanName, alias);<br>  &#125;<br><br><span class="hljs-comment">// 删除bean别名</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAlias</span><span class="hljs-params">(String alias)</span> &#123;<br>    <span class="hljs-built_in">this</span>.beanFactory.removeAlias(alias);<br>  &#125;<br><br>  <span class="hljs-comment">// 是否存在别名</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlias</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanFactory.isAlias(beanName);<br>  &#125;<br><br>  <span class="hljs-comment">// 注册Bean</span><br>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String beanName, Class&lt;T&gt; beanClass,</span><br><span class="hljs-params">                               <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> &#123;<br><br>    <span class="hljs-type">ClassDerivedBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassDerivedBeanDefinition</span>(beanClass);<br>    <span class="hljs-keyword">if</span> (supplier != <span class="hljs-literal">null</span>) &#123;<br>      beanDefinition.setInstanceSupplier(supplier);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;<br>      customizer.customize(beanDefinition);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">nameToUse</span> <span class="hljs-operator">=</span> (beanName != <span class="hljs-literal">null</span> ? beanName : beanClass.getName());<br>    registerBeanDefinition(nameToUse, beanDefinition);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>GenericApplicationContext</code>内部持有了<code>DefaultListableBeanFactory</code>引用，并简单的实现了<strong>BeanDefinitionRegistry</strong>的接口，不过最终操作还是交给了<code>DefaultListableBeanFactory</code>对象来进行完成。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGenericApplicationContext</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">GenericApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericApplicationContext</span>();<br><br>  <span class="hljs-type">AnnotatedBeanDefinitionReader</span> <span class="hljs-variable">definitionReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedBeanDefinitionReader</span>(applicationContext);<br>  definitionReader.registerBean(IocBean.class);<br><br>  applicationContext.refresh();<br><br>  <span class="hljs-type">IocBean</span> <span class="hljs-variable">iocBean</span> <span class="hljs-operator">=</span> applicationContext.getBean(IocBean.class);<br>  System.out.println(iocBean);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a><code>DefaultListableBeanFactory</code></h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>DefaultListableBeanFactory是Spring的ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现，基于BeanDefinition元数据的成熟bean工厂，可通过后处理器进行扩展。</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>典型的用法是在访问bean之前先注册所有bean定义（可能是从bean定义文件中读取）。因此，按名称查找Bean是对本地Bean定义表进行的廉价操作，该操作对预先解析的Bean定义元数据对象进行操作。对于<code>ListableBeanFactory</code>接口的替代实现，请看一下<code>StaticListableBeanFactory</code>，它管理现有的bean实例，而不是根据bean定义创建新的bean实例。</p><h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><p>代码中删除了无关的代码，因为我们关注的是<code>BeanDefinitionRegistry</code>相关的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAutowireCapableBeanFactory</span><br>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConfigurableListableBeanFactory</span>, BeanDefinitionRegistry, Serializable &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">allowBeanDefinitionOverriding</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 管理所有的BeanDefinition</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br>  <span class="hljs-comment">// 管理所有的单例Bean或非单例名称，key=依赖的Class</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">64</span>);<br>  <span class="hljs-comment">// 管理所有的单例Bean名称，key=依赖的Class</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">64</span>);<br>  <span class="hljs-comment">// 根据注册的顺序，管理所有的BeanDefinition名称</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">256</span>);<br>  <span class="hljs-comment">// 管理手动注册的单示例Bean</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Set&lt;String&gt; manualSingletonNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">// 构造函数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultListableBeanFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>  &#125;<br><br><span class="hljs-comment">// 注册BeanDefinition</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><br><span class="hljs-comment">// 判断次BeanDefinition是否被加载过</span><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">existingDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.get(beanName);<br>    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 被加载过</span><br>      <span class="hljs-comment">// 是否允许BeanDefinition重写</span><br>      <span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);<br>      &#125;<br>      <span class="hljs-comment">// 新的BeanDefinition会覆盖就的BeanDefinition</span><br>      <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>    &#125;<br>    <span class="hljs-comment">// 未被加载过</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;<span class="hljs-comment">// 是否已经开始创建Bean</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.beanDefinitionMap) &#123;<br>          <span class="hljs-comment">// 将BeanDefinition放入到beanDefinitionMap中</span><br>          <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>          List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);<br>          updatedDefinitions.addAll(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br>          updatedDefinitions.add(beanName);<br>          <span class="hljs-built_in">this</span>.beanDefinitionNames = updatedDefinitions;<br>          removeManualSingletonName(beanName);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 将BeanDefinition放入到beanDefinitionMap中</span><br>        <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>        <span class="hljs-built_in">this</span>.beanDefinitionNames.add(beanName);<br>        <span class="hljs-comment">// 删除</span><br>        removeManualSingletonName(beanName);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.frozenBeanDefinitionNames = <span class="hljs-literal">null</span>;<br>    &#125;<br><span class="hljs-comment">// 已经存在此BeanDefinition或者此beanName已经存在</span><br>    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-literal">null</span> || containsSingleton(beanName)) &#123;<br>      <span class="hljs-comment">// 重置此BeanDefinition</span><br>      resetBeanDefinition(beanName);<br>    &#125;<br>  &#125;<br><br><span class="hljs-comment">// 删除BeanDefinition</span><br>  <span class="hljs-comment">// ①：删除beanDefinitionNames中name，②：调用resetBeanDefinition从beanDefinitionMap中删除</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException &#123;<br><span class="hljs-comment">// 从Map中删除BeanDefinition</span><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.remove(beanName);<br>    <span class="hljs-keyword">if</span> (bd == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 删除失败（不存在此BeanDefinition），抛出异常</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchBeanDefinitionException</span>(beanName);<br>    &#125;<br><span class="hljs-comment">// 是否有Bean已经被创建</span><br>    <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;<br>      <span class="hljs-comment">// 加锁</span><br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.beanDefinitionMap) &#123;<br>        List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br>       <span class="hljs-comment">// 删除</span><br>        updatedDefinitions.remove(beanName);<br>        <span class="hljs-built_in">this</span>.beanDefinitionNames = updatedDefinitions;  <span class="hljs-comment">// 重新赋值</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 直接删除</span><br>      <span class="hljs-built_in">this</span>.beanDefinitionNames.remove(beanName);<br>    &#125;<br><span class="hljs-comment">// 重置BeanDefinition</span><br>    resetBeanDefinition(beanName);<br>  &#125;<br><br><span class="hljs-comment">// 重置BeanDefinition</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetBeanDefinition</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-comment">// 如果存在则删除指定Bean名称对应的合并的BeanDefinition</span><br>    clearMergedBeanDefinition(beanName);<br><br>    destroySingleton(beanName);<br><span class="hljs-comment">// 执行过滤出的MergedBeanDefinitionPostProcessor</span><br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>      <span class="hljs-keyword">if</span> (processor <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>        ((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);<br>      &#125;<br>    &#125;<br><span class="hljs-comment">// 遍历BeanDefinition名称Map</span><br>    <span class="hljs-keyword">for</span> (String bdName : <span class="hljs-built_in">this</span>.beanDefinitionNames) &#123;<br>      <span class="hljs-keyword">if</span> (!beanName.equals(bdName)) &#123;<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.get(bdName);<br>        <span class="hljs-keyword">if</span> (bd != <span class="hljs-literal">null</span> &amp;&amp; beanName.equals(bd.getParentName())) &#123;<br>          <span class="hljs-comment">// 重置BeanDefinition</span><br>          resetBeanDefinition(bdName);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br><span class="hljs-comment">// 获取BeanDefinition</span><br><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException &#123;<br>    <span class="hljs-comment">// 调用beanDefinitionMap.get()</span><br><span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.get(beanName);<br><span class="hljs-keyword">if</span> (bd == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 没有抛出异常</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchBeanDefinitionException</span>(beanName);<br>&#125;<br><span class="hljs-keyword">return</span> bd;<br>&#125;<br>  <br><span class="hljs-comment">// 是否存在BeanDefinition</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span> &#123;<br>Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);<br>    <span class="hljs-comment">// 操作成员变量beanDefinitionMap</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.containsKey(beanName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DefaultListableBeanFactory</code>声明了多个<code>beanDefinitionNames（List类型）</code>，<code>beanDefinitionMap（Map类型）</code>等属性，它们分别用于存储<code>BeanDefinition名称</code>和<code>BeanDefinition</code>。</p><p>在对<code>BeanDefinitionRegistry</code>接口方法的实现中底层操作的都是这两个<code>beanDefinitionNames</code>，<code>beanDefinitionMap</code>属性。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDefaultListableBeanFactory</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedGenericBeanDefinition</span>(IocBean.class);<br>    beanFactory.registerBeanDefinition(IocBean.class.getName(), beanDefinition);<br><br>    System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><code>AnnotationConfigApplicationContext</code>是一个独立的应用程序上下文，接受组件类作为输入-特别是使用@Configuration注释的类，还可以使用javax.inject注释使用普通的@Component类型和符合JSR-330的类。</p><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>允许使用<code>register（Class ...）</code>方法一对一注册类，以及使用<code>scan（String ...）方法</code>进行类路径扫描，这两个方法定义在<code>AnnotationConfigRegistry</code>接口中。</p><p>如果有多个<code>@Configuration</code>类，则在<code>以后的类中定义的@Bean方法将覆盖在先前的类中定义的方法</code>。可以利用此属性通过额外的@Configuration类有意覆盖某些bean定义。</p><h4 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AnnotationConfigRegistry</span> &#123;<br><span class="hljs-comment">// 注解BeanDefinition的读取器和注册器</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotatedBeanDefinitionReader reader;<br><span class="hljs-comment">// ClassPath下BeanDefinition扫描器，扫描Component，Service，Controller，Repository等注解标识的类 </span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassPathBeanDefinitionScanner scanner;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedBeanDefinitionReader</span>(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathBeanDefinitionScanner</span>(<span class="hljs-built_in">this</span>);<br>  &#125;<br><span class="hljs-comment">// 使用指定类的Class数组进行初始化</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    register(componentClasses);<br>    refresh();<br>  &#125;<br>  <span class="hljs-comment">// 使用指定包路径数组进行初始化</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">(String... basePackages)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    scan(basePackages);<br>    refresh();<br>  &#125;<br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> &#123;<br>    Assert.notEmpty(componentClasses, <span class="hljs-string">&quot;At least one component class must be specified&quot;</span>);<br>    <span class="hljs-comment">// 调用AnnotatedBeanDefinitionReader注册Bean</span><br>    <span class="hljs-built_in">this</span>.reader.register(componentClasses);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(String... basePackages)</span> &#123;<br>    Assert.notEmpty(basePackages, <span class="hljs-string">&quot;At least one base package must be specified&quot;</span>);<br>    <span class="hljs-built_in">this</span>.scanner.scan(basePackages);<br>  &#125;<br><br><span class="hljs-comment">// 重写父类的registerBean方法，因为reader拥有注册Bean的功能</span><br>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBean</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String beanName, Class&lt;T&gt; beanClass,</span><br><span class="hljs-params">                               <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> &#123;<br><br>    <span class="hljs-built_in">this</span>.reader.registerBean(beanClass, beanName, supplier, customizers);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AnnotationConfigApplicationContext引用了<code>ClassPathBeanDefinitionScanner</code>，<code>AnnotatedBeanDefinitionReader</code>属性。</p><p>并将最终的Bean注册交予了<code>AnnotatedBeanDefinitionReader</code>来处理，而<code>ClassPathBeanDefinitionScanner</code>则用于扫描类路径下所有带<code>Component，Service，Controller，Repository</code>注解的类。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnnotationConfigApplicationContext</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(IocBean.class);<br><br>  <span class="hljs-type">IocBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> applicationContext.getBean(IocBean.class);<br>  System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出AnnotationConfigApplicationContext的使用非常的简单，只需简单传递一个要初始化的Bean的Class即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>GenericApplicationContext</code>：对BeanDefinitionRegistry做了通用的实现，内部引用了DefaultListableBeanFactory，将操作转发给了DefaultListableBeanFactory。</p><p><code>DefaultListableBeanFactory</code>：该类封装了处理BeanDefinition的逻辑，底层操作了许多Map。</p><p><code>AnnotationConfigApplicationContext</code>：该类虽然继承了<code>GenericApplicationContext</code>类，但却每调用父类的方法，而是将注册Bean的操作转发给了内部的AnnotatedBeanDefinitionReader对象。</p><p><code>SimpleBeanDefinitionRegistry</code>：简单的BeanDefinitionRegistry，未内置工厂，可用作测试BeanDefinition 注册。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis Sql执行</title>
    <link href="/2019/12/09/mybatis/02-mybatis-sql-execute/"/>
    <url>/2019/12/09/mybatis/02-mybatis-sql-execute/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-语句执行"><a href="#Mybatis-语句执行" class="headerlink" title="Mybatis-语句执行"></a>Mybatis-语句执行</h1><h2 id="本章讲述的内容"><a href="#本章讲述的内容" class="headerlink" title="本章讲述的内容"></a>本章讲述的内容</h2><p>本章主要讲解Mybatis在启动后是如何执行Mapper文件中对应SQL语句的。带着下面几个问题我们正式进入Mybatis语句执行分析。</p><blockquote><p>1、Mybatis是如何实现一级缓存的？</p><p>2、Mybatis是如何执行SQL的？有几种执行器？</p><p>3、Mybatis是如何处理查询结果的？</p></blockquote><p>想知道如何使用Mybatis请参考<a href="https://mybatis.org/mybatis-3/zh/">Mybatis官方文档</a>。</p><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="配置XML"><a href="#配置XML" class="headerlink" title="配置XML"></a>配置XML</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;io.better.mybatis.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;io.better.mybatis.model.User&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--@mbg.generated--&gt;</span><br>        <span class="hljs-comment">&lt;!--@Table tbl_user--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;phone&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Name_Column&quot;</span>&gt;</span><br>            username<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--@mbg.generated--&gt;</span><br>        id,<br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Name_Column&quot;</span>/&gt;</span>,<br>        phone,<br>        address<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByPrimaryKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--@mbg.generated--&gt;</span><br>        select<br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span>/&gt;</span><br>        from tbl_user<br>        where id = #&#123;id,jdbcType=BIGINT&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="全局配置XML"><a href="#全局配置XML" class="headerlink" title="全局配置XML"></a>全局配置XML</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SLF4J&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BATCH&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.better.mybatis.model&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/source-code-analysis&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;package name=&quot;io.better.mybatis.mapper&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mybatis/mappers/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> better create in 2020/4/19 10:30 上午</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisTest</span> &#123;<br><br>    SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis/mybatis-config.xml&quot;</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>        sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-number">1L</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看出一共执行了三个操作：</p><p>1、调用<code>SqlSessionFactory</code>创建<code>SqlSession</code>对象。</p><p>2、调用SqlSession获取Mapper代理对象。</p><p>3、调用Mapper代理对象执行目标方法获取结果。</p><h2 id="获取SqlSession"><a href="#获取SqlSession" class="headerlink" title="获取SqlSession"></a>获取SqlSession</h2><h3 id="调用openSession-创建SqlSession"><a href="#调用openSession-创建SqlSession" class="headerlink" title="调用openSession()创建SqlSession"></a>调用<code>openSession()</code>创建SqlSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> SqlSession <span class="hljs-title function_">openSessionFromDataSource</span><span class="hljs-params">(ExecutorType execType, TransactionIsolationLevel level, <span class="hljs-type">boolean</span> autoCommit)</span> &#123;<br>  <span class="hljs-type">Transaction</span> <span class="hljs-variable">tx</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取环境配置</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Environment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> configuration.getEnvironment();<br>    <span class="hljs-comment">// 步骤①</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">TransactionFactory</span> <span class="hljs-variable">transactionFactory</span> <span class="hljs-operator">=</span> getTransactionFactoryFromEnvironment(environment);<br>    <span class="hljs-comment">// 步骤②</span><br>    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);<br>    <span class="hljs-comment">// 步骤③</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> configuration.newExecutor(tx, execType);<br>    <span class="hljs-comment">// 步骤④</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// 忽略部分代码</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上诉代码中我们需要重点关注一个点：1、<code>configuration.getDefaultExecutorType()：</code>它用于指定Executor的类型，默认即<code>ExecutorType.SIMPLE</code>。</p><p>在<code>openSessionFromDataSource</code>方法中，Mybatis做了下面几个操作：</p><ul><li>步骤①：创建TransactionFactory，类型为：<code>JdbcTransactionFactory</code>。<ul><li>对应Mybatis配置中 <transactionManager type="JDBC"/>标签。</li></ul></li><li>步骤②：创建Transaction事务对象，并对<code>autoCommit，IsolationLevel</code> 属性赋值。</li><li>步骤③：根据<code>execType</code>创建执行类型的<code>Executor</code>执行器。</li><li>步骤④：创建<code>DefaultSqlSession</code>对象。</li></ul><h4 id="创建Transaction"><a href="#创建Transaction" class="headerlink" title="创建Transaction"></a>创建<code>Transaction</code></h4><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Transaction <span class="hljs-title function_">newTransaction</span><span class="hljs-params">(DataSource ds, TransactionIsolationLevel level, <span class="hljs-type">boolean</span> autoCommit)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTransaction</span>(ds, level, autoCommit);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中直接调用<code>JdbcTransaction</code>构造器进行Transaction创建。那么JdbcTransaction将就能干什么事情呢？让我们来看看JdbcTransaction的类结构图。</p><p><img src="https://raw.githubusercontent.com/io-better-chen/better.io.images/master/images/image-20200428162608413.png" alt="image-20200428162608413"></p><p>从类图可以看出JdbcTransaction主要是负责<code>提交、回滚、关闭Transaction</code>，<code>打开、获取Connection</code>等操作。</p><h4 id="创建Executor"><a href="#创建Executor" class="headerlink" title="创建Executor"></a>创建<code>Executor</code></h4><p><code>Configuration#newExecutor(Transaction, ExecutorType)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">newExecutor</span><span class="hljs-params">(Transaction transaction, ExecutorType executorType)</span> &#123;<br>  <span class="hljs-comment">// 判断 executorType </span><br>  executorType = executorType == <span class="hljs-literal">null</span> ? defaultExecutorType : executorType;<br>  executorType = executorType == <span class="hljs-literal">null</span> ? ExecutorType.SIMPLE : executorType;<br>  Executor executor;<br>  <span class="hljs-keyword">if</span> (ExecutorType.BATCH == executorType) &#123;<br>    <span class="hljs-comment">// 批量执行器</span><br>    executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchExecutor</span>(<span class="hljs-built_in">this</span>, transaction);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ExecutorType.REUSE == executorType) &#123;<br>    <span class="hljs-comment">// 可重用执行器</span><br>    executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReuseExecutor</span>(<span class="hljs-built_in">this</span>, transaction);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 默认执行器</span><br>    executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleExecutor</span>(<span class="hljs-built_in">this</span>, transaction);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (cacheEnabled) &#123;<br>    <span class="hljs-comment">// 缓存执行器，类似于一个装饰器</span><br>    executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingExecutor</span>(executor);<br>  &#125;<br>  <span class="hljs-comment">// 将执行器传递给每个插件拦截器</span><br>  executor = (Executor) interceptorChain.pluginAll(executor);<br>  <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中可以看出，执行器的类型一共有三种：<code>批量-&gt;BatchExecutor，可重用-&gt;ReuseExecutor，简单-&gt;SimpleExecutor</code>。</p><p>而<code>CachingExecutor</code>是一个装饰类，包装了具体的Executor，主要用于做一些缓存操作。</p><p>默认为<code>SimpleExecutor</code>执行器，我们这里使用是<code>BatchExecutor</code>执行器。可以通过下面的配置修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BATCH&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>最后将创建好的执行器交给<code>interceptorChain</code>，此处代码是为了扩展。</p><p>因为代码最终会走向<code>Plugin.wrap</code>方法中，并为其创建 <code>Plugin</code>这个代理对象（<code>如果有拦截器处理则创建，没有则无</code>）。</p><p><img src="https://raw.githubusercontent.com/io-better-chen/better.io.images/master/images/20200429161400.png" alt="image-20200429161316723"></p><h4 id="创建DefaultSqlSession"><a href="#创建DefaultSqlSession" class="headerlink" title="创建DefaultSqlSession"></a>创建<code>DefaultSqlSession</code></h4><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSqlSession</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SqlSession</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration configuration;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor executor;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> autoCommit;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> dirty;<br>  <span class="hljs-keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultSqlSession</span><span class="hljs-params">(Configuration configuration, Executor executor, <span class="hljs-type">boolean</span> autoCommit)</span> &#123;<br>    <span class="hljs-built_in">this</span>.configuration = configuration;<br>    <span class="hljs-built_in">this</span>.executor = executor;<br>    <span class="hljs-built_in">this</span>.dirty = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>.autoCommit = autoCommit;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DefaultSqlSession的构造比较简单，仅仅是对类中部分属性进行赋值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在获取SqlSession阶段主要是初始化了<code>Transaction，Executor，SqlSession</code>三个对象。</p><h2 id="获取指定Mapper"><a href="#获取指定Mapper" class="headerlink" title="获取指定Mapper"></a>获取指定Mapper</h2><h3 id="调用getMapper-获取Mapper"><a href="#调用getMapper-获取Mapper" class="headerlink" title="调用getMapper()获取Mapper"></a>调用<code>getMapper()</code>获取Mapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSqlSession.getMapper</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>  <span class="hljs-keyword">return</span> configuration.getMapper(type, <span class="hljs-built_in">this</span>);<br>&#125;<br><span class="hljs-comment">// Configuration.getMapper</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;<br>  <span class="hljs-keyword">return</span> mapperRegistry.getMapper(type, sqlSession);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码最终调用到了Configuration对象中。</p><p>因为Mybatis在启动加载阶段将所有的Mapper接口都注册到了<code>Configuration.mapperRegistry</code>对象中。</p><h3 id="创建MapperProxy"><a href="#创建MapperProxy" class="headerlink" title="创建MapperProxy"></a>创建MapperProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;<br>  <span class="hljs-comment">// 获取到MapperProxy工厂</span><br>  <span class="hljs-keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 创建MapperProxy对象</span><br>    <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// MapperProxyFactory</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> &#123;<br>  <span class="hljs-comment">// 创建MapperProxy对象</span><br>  <span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface, methodCache);<br>  <span class="hljs-comment">// 调用JDK的Proxy.newProxyInstance() 创建实例</span><br>  <span class="hljs-keyword">return</span> newInstance(mapperProxy);<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看出Mybatis在获取每一个Mapper接口时都为其创建了一个MapperProxy代理对象。最终调用JDK创建代理。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>**<code>在获取Mapper接口阶段主要是操作是：为指定Mapper接口创建代理对象MapperProxy</code>**。</p><h2 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h2><h3 id="调用MapperProxy-invoke"><a href="#调用MapperProxy-invoke" class="headerlink" title="调用MapperProxy.invoke"></a>调用<code>MapperProxy.invoke</code></h3><p>当调用SqlSession返回Mapper接口中的方法时，会调用到MapperProxy对象的<code>invoke</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>  <span class="hljs-keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;<br>    <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// cachedInvoker会生成MapperMethodInvoker对象，并将其缓存</span><br>    <span class="hljs-comment">// 调用invoke执行方法</span><br>    <span class="hljs-keyword">return</span> cachedInvoker(method).invoke(proxy, method, args, sqlSession);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// cachedInvoker方法</span><br><span class="hljs-keyword">private</span> MapperMethodInvoker <span class="hljs-title function_">cachedInvoker</span><span class="hljs-params">(Method method)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>  <span class="hljs-comment">// 被调用过的方法会被缓存起来，避免重复创建</span><br>  <span class="hljs-keyword">return</span> methodCache.computeIfAbsent(method, m -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (m.isDefault()) &#123;<br>      <span class="hljs-keyword">if</span> (privateLookupInMethod == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMethodInvoker</span>(getMethodHandleJava8(method));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMethodInvoker</span>(getMethodHandleJava9(method));<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 默认第一次都会创建PlainMethodInvoker。</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PlainMethodInvoker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperMethod</span>(mapperInterface, method, sqlSession.getConfiguration()));<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>Mybatis会先调用<code>cachedInvoker</code>方法，判断当前执行的方法是否已经创建过<code>MethodInvoker</code>：</p><p>1、如果没有则创建<code>MapperMethod</code>封装当前执行的方法：</p><p>​1、如果执行的方法不是Default方法，则创建<code>PlainMethodInvoker</code> 并赋值。</p><p>​    2、如果执行的是Default方法，则创建<code>DefaultMethodInvoker</code>并赋值。</p><p>2、如果已经创建，则直接从<code>methodCache</code>中获取。</p><h3 id="调用MapperMethodInvoker-invoke"><a href="#调用MapperMethodInvoker-invoke" class="headerlink" title="调用MapperMethodInvoker.invoke"></a>调用<code>MapperMethodInvoker.invoke</code></h3><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>  <span class="hljs-comment">// 调用上面cachedInvoker方法创建的MapperMethod对象，执行SQL</span><br>  <span class="hljs-keyword">return</span> mapperMethod.execute(sqlSession, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用上一步创建的<code>MapperMethod</code>对象执行目标Mapper方法。</p><h3 id="调用MapperMethod-execute"><a href="#调用MapperMethod-execute" class="headerlink" title="调用MapperMethod.execute"></a>调用<code>MapperMethod.execute</code></h3><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(SqlSession sqlSession, Object[] args)</span> &#123;<br>  Object result;<br>  <span class="hljs-comment">// 判断sql指令类型：insert，select，update，delete</span><br>  <span class="hljs-keyword">switch</span> (command.getType()) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> method.convertArgsToSqlCommandParam(args);<br>    <span class="hljs-comment">// 插入指令</span><br>    <span class="hljs-keyword">case</span> INSERT: &#123;<br>      result = rowCountResult(sqlSession.insert(command.getName(), param));<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 更新指令</span><br>    <span class="hljs-keyword">case</span> UPDATE: &#123;<br>      result = rowCountResult(sqlSession.update(command.getName(), param));<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 删除指令</span><br>    <span class="hljs-keyword">case</span> DELETE: &#123;<br>      result = rowCountResult(sqlSession.delete(command.getName(), param));<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查询指令</span><br>    <span class="hljs-keyword">case</span> SELECT:<br>      <span class="hljs-comment">// </span><br>      <span class="hljs-keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;<br>        executeWithResultHandler(sqlSession, args);<br>        result = <span class="hljs-literal">null</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMany()) &#123;<br><span class="hljs-comment">// List结果集</span><br>        result = executeForMany(sqlSession, args);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMap()) &#123;<br>        <span class="hljs-comment">// Map结果集</span><br>        result = executeForMap(sqlSession, args);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsCursor()) &#123;<br>        <span class="hljs-comment">// Cursor结果集</span><br>        result = executeForCursor(sqlSession, args);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 单个结果集</span><br>        result = sqlSession.selectOne(command.getName(), param);<span class="hljs-comment">// 忽略部分代码</span><br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> FLUSH:<br>      result = sqlSession.flushStatements();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Unknown execution method for: &quot;</span> + command.getName());<br>  &#125;<span class="hljs-comment">// 忽略部分代码</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看出<code>MapperMethod</code>类是执行Mapper方法的核心类。</p><p>在这个方法中我们分别看到了Mybatis对新增，更新，删除，查询所执行的操作。</p><p>通过判断<code>command</code>指令类型来断定SQL语句的类型。改对象(<code>command</code>)是在MapperMethod构造器中被初始化。</p><p><code>新增，更新，删除，查询</code>四个操作最终都调用了<code>sqlSession</code>中对应的方法。</p><p>而<code>executeForMany，executeForMap，executeForCursor</code>三个方法最终分别调用了<code>SqlSession</code>的<code>selectList，selectMap，selectCursor</code>方法。</p><p>**<code>可以看出Mybatis的SQL执行最终是在SqlSession中完成的</code>**。</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><h4 id="获取单个结果-selectList"><a href="#获取单个结果-selectList" class="headerlink" title="获取单个结果-selectList"></a>获取单个结果-<code>selectList</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(String statement, Object parameter)</span> &#123;<br><span class="hljs-comment">// 调用同类的selectList方法</span><br>  List&lt;T&gt; list = <span class="hljs-built_in">this</span>.selectList(statement, parameter);<br>  <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 返回第一个</span><br>    <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list.size() &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 抛出异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TooManyResultsException</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> configuration.getMappedStatement(statement);<br>    <span class="hljs-comment">// 调用执行器执行查询</span><br>    <span class="hljs-keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>selectOne</code>方法中调用了<code>selectList</code>方法。并对结果集进行了判断，超过一个抛出异常。</p><p>在<code>selectList</code>方法中<code>Mybatis</code>获取到了解析<code>Mapper</code>文件时生成的<code>MappedStatement</code>对象。并将其传递给了<code>Executor</code>。</p><p><strong>而上面的<code>executeForMany，executeForMap，executeForCursor</code>三个方法查询时最终都调用的是<code>selectList</code>方法</strong>。</p><h4 id="执行查询-Executor"><a href="#执行查询-Executor" class="headerlink" title="执行查询-Executor"></a>执行查询-<code>Executor</code></h4><p><code>CachingExecutor.query</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>  <span class="hljs-type">BoundSql</span> <span class="hljs-variable">boundSql</span> <span class="hljs-operator">=</span> ms.getBoundSql(parameterObject);<br>  <span class="hljs-comment">// 调用包装的执行器创建缓存Key</span><br>  <span class="hljs-type">CacheKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> createCacheKey(ms, parameterObject, rowBounds, boundSql);<br>  <span class="hljs-comment">// 继续调用同类Query方法</span><br>  <span class="hljs-keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CachingExecutor.query</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span><br>  <span class="hljs-keyword">throws</span> SQLException &#123;<br>  <span class="hljs-comment">// 获取缓存</span><br>  <span class="hljs-type">Cache</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> ms.getCache();<br>  <span class="hljs-comment">// 默认第一次为空</span><br>  <span class="hljs-keyword">if</span> (cache != <span class="hljs-literal">null</span>) &#123;<br>    flushCacheIfRequired(ms);<br>    <span class="hljs-keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="hljs-literal">null</span>) &#123;<br>      ensureNoOutParams(ms, boundSql);<br><span class="hljs-comment">// private final TransactionalCacheManager tcm = new TransactionalCacheManager();</span><br>      <span class="hljs-comment">// 从事务缓存管理器中获取，并判断是否已经存在执行过</span><br>      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);<br>      <span class="hljs-comment">// 如果为空，说明没执行过</span><br>      <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 调用包装执行器执行</span><br>        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);<br>        <span class="hljs-comment">// 将执行的结果放入缓存中</span><br>        tcm.putObject(cache, key, list); <span class="hljs-comment">// issue #578 and #116</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> list;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 调用包装执行器执行query</span><br>  <span class="hljs-keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BaseExecutor.query</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类BaseExecutor.query</span><br><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>  List&lt;E&gt; list;<br>  <span class="hljs-keyword">try</span> &#123;<br>    queryStack++;<br>    list = resultHandler == <span class="hljs-literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// </span><br>      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 执行查询,最终执行的结果会放入localCache对象中。</span><br>      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    queryStack--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出三个方法中都是做了很多缓存操作，提高效率，</p><h4 id="核心查询-doQuery"><a href="#核心查询-doQuery" class="headerlink" title="核心查询-doQuery"></a>核心查询-<code>doQuery</code></h4><h5 id="BatchExecutor-doQuery-Core"><a href="#BatchExecutor-doQuery-Core" class="headerlink" title="BatchExecutor.doQuery (Core)"></a><code>BatchExecutor.doQuery (Core)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>  <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    flushStatements();<br>    <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> ms.getConfiguration();<br>    <span class="hljs-comment">// 创建StatementHandler</span><br>    <span class="hljs-type">StatementHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> configuration.newStatementHandler(wrapper, ms, parameterObject, rowBounds, resultHandler, boundSql);<br>    <span class="hljs-comment">// 获取Connection，如果没有则使用DataSource进行创建</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> getConnection(ms.getStatementLog());<br>    <span class="hljs-comment">// 创建Statement对象，并设置timeOut和fetchSize属性</span><br>    stmt = handler.prepare(connection, transaction.getTimeout());<br>    <span class="hljs-comment">// 进行参数替换</span><br>    handler.parameterize(stmt);<br>    <span class="hljs-comment">// 执行SQL查询，获取到结果集，调用ResultSetHandler.handleResultSets进行结果集处理。</span><br>    <span class="hljs-keyword">return</span> handler.query(stmt, resultHandler);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    closeStatement(stmt);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法主要的作用是操作<code>Statement</code>对象。<code>1、创建StatementHandler处理对象。2、获取Connection连接。3、初始化Statement对象。4、进行参数替换。5、执行SQL完成查询</code>。</p><h4 id="处理查询结果"><a href="#处理查询结果" class="headerlink" title="处理查询结果"></a>处理查询结果</h4><h5 id="ResultSetHandler-handleResultSets"><a href="#ResultSetHandler-handleResultSets" class="headerlink" title="ResultSetHandler.handleResultSets"></a><code>ResultSetHandler.handleResultSets</code></h5><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">handleResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>  <span class="hljs-keyword">final</span> List&lt;Object&gt; multipleResults = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">resultSetCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">ResultSetWrapper</span> <span class="hljs-variable">rsw</span> <span class="hljs-operator">=</span> getFirstResultSet(stmt);<br><span class="hljs-comment">// 获取当前Mapper的ResultMap</span><br>  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">resultMapCount</span> <span class="hljs-operator">=</span> resultMaps.size();<br><span class="hljs-comment">// 遍历resultMaps</span><br>  <span class="hljs-keyword">while</span> (rsw != <span class="hljs-literal">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;<br>    <span class="hljs-comment">// 获取resultMap</span><br>    <span class="hljs-type">ResultMap</span> <span class="hljs-variable">resultMap</span> <span class="hljs-operator">=</span> resultMaps.get(resultSetCount);<br>    <span class="hljs-comment">// 处理ResultSet</span><br>    handleResultSet(rsw, resultMap, multipleResults, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 获取下一个ResultSet</span><br>    rsw = getNextResultSet(stmt);<br>    cleanUpAfterHandlingResultSet();<br>    resultSetCount++;<br>  &#125;<br><span class="hljs-comment">// 处理ResultSet</span><br>  String[] resultSets = mappedStatement.getResultSets();<br>  <span class="hljs-keyword">if</span> (resultSets != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">while</span> (rsw != <span class="hljs-literal">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;<br>      <span class="hljs-comment">// 获取ResultMapping</span><br>      <span class="hljs-type">ResultMapping</span> <span class="hljs-variable">parentMapping</span> <span class="hljs-operator">=</span> nextResultMaps.get(resultSets[resultSetCount]);<br>      <span class="hljs-keyword">if</span> (parentMapping != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">nestedResultMapId</span> <span class="hljs-operator">=</span> parentMapping.getNestedResultMapId();<br>        <span class="hljs-type">ResultMap</span> <span class="hljs-variable">resultMap</span> <span class="hljs-operator">=</span> configuration.getResultMap(nestedResultMapId);<br>        handleResultSet(rsw, resultMap, <span class="hljs-literal">null</span>, parentMapping);<br>      &#125;<br>      rsw = getNextResultSet(stmt);<br>      cleanUpAfterHandlingResultSet();<br>      resultSetCount++;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> collapseSingleResultList(multipleResults);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Orm</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-核心接口</title>
    <link href="/2019/11/09/spring/02-spring-core-interface/"/>
    <url>/2019/11/09/spring/02-spring-core-interface/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-Spring核心接口"><a href="#Ioc-Spring核心接口" class="headerlink" title="Ioc-Spring核心接口"></a>Ioc-Spring核心接口</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><ol><li>本章主要讲述Spring Ioc中几个比较重要的接口<ol><li>BeanFactory的含义及其使用</li><li>BeanFactoryPostProcessor的作用以及使用</li><li>BeanPostProcessor的作用以及使用</li><li>BeanDefinitionReader的作用以及使用</li><li>FactoryBean的作用以及使用</li></ol></li></ol></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们一般配置Bean的方式有两种：1、使用Xml进行Bean的配置，2、使用@Component，@Bean等注解进行Bean的配置。</p><p>当然Spring为了处理这些不同的配置定义了一个接口（<code>BeanDefinitionReader</code>）来统一将这些配置加载并生成BeanDefinition。</p><p>当BeanDefinition被加载后，我们出于某些因素需要修改BeanDefinition，Spring向我们提供了<code>BeanFactoryPostProcessor</code>回调接口来修改BeanDefinition（在BeanDefinition被加载进BeanFactory时进行回调）。</p><p>接着实例化具体的Bean并放入到BeanFactory中，实例化后我们可能需要对实例进行一些包装，比如 AOP。Spring向我们提供了BeanPostProcessor回调接口来对Bean实例进行包装（在Bean实例被创建后进行回调）。</p><p>此时Ioc容器已经加载完毕了，但是上面的步骤都是在Bean实例化这个步骤前后进行操作，那我们怎么在操作实例化这个步骤呢？</p><p>Spring为提供了FactoryBean这个接口，让开发人员自己实现创建Bean实例的步骤。</p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>Gradle 坐标</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">testCompile <span class="hljs-string">&#x27;junit:junit:4.13&#x27;</span><br><br>compile <span class="hljs-string">&#x27;org.aspectj:aspectjweaver:1.9.5&#x27;</span><br><br>compile <span class="hljs-string">&#x27;org.springframework:spring-beans:5.2.2.RELEASE&#x27;</span><br>compile <span class="hljs-string">&#x27;org.springframework:spring-aop:5.2.2.RELEASE&#x27;</span><br>compile <span class="hljs-string">&#x27;org.springframework:spring-context:5.2.2.RELEASE&#x27;</span><br></code></pre></td></tr></table></figure><p>Maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><p>Spring 框架中</p><p><code>BeanDefinitionReader</code>：读取XML或注解配置的Bean并生成BeanDefinition</p><p><code>BeanFactoryPostProcesser</code>：BeanFactory加载BeanDefinition后增强的扩展接口，可以<code>新增/修改BeanDefinition</code>。</p><p><code>BeanPostProcesser</code>：BeanFactory实例化Bean后增强的扩展接口，可以包装Bean，例如AOP。</p><p><code>BeanFactory</code>：Spring Ioc的顶级接口，主要负责创建，实例化，管理Bean实例。</p><p><code>FactoryBean</code>：Spring提供给开发人员自定义实例化Bean的接口。</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>BeanFactory是访问Spring Bean容器的根接口。该接口由包含多个Bean定义的对象实现，每个定义均由String名称唯一标识。</p><p>它负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br><br>  <span class="hljs-comment">// 用于区分FactoryBean实例，下面讲解FactoryBean接口时会讲到</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">FACTORY_BEAN_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>  <span class="hljs-comment">// 根据Bean名称查找并获取Bean</span><br>  Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">// 根据Bean名称和指定类型查找并获取Bean</span><br>  &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">// 返回名称查找并返回实例</span><br><span class="hljs-comment">// 允许在bean定义指定明确的构造器参数/工厂方法的参数，重写指定的默认参数（如果有的话）</span><br>  Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">// 根据类型返回指定实例</span><br>  &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">// 同上</span><br>  &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">// 返回一个提供者指定的Bean，允许懒按需检索的实例，包括可用性和唯一选择。</span><br>  &lt;T&gt; ObjectProvider&lt;T&gt; <span class="hljs-title function_">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span>;<br><br>  <span class="hljs-comment">// 同上</span><br>  &lt;T&gt; ObjectProvider&lt;T&gt; <span class="hljs-title function_">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span>;<br><br>  <span class="hljs-comment">// 是否存在Bean</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBean</span><span class="hljs-params">(String name)</span>;<br><br>  <span class="hljs-comment">// 是否单例Bean</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br> <span class="hljs-comment">// 是否多例Bean</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>  <span class="hljs-comment">// 检查具有给定名称的Bean是否与指定的类型匹配。</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br><span class="hljs-comment">// 同上</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br>  <br><span class="hljs-comment">// 确定与给定名称的bean的类型。 更具体地讲，确定对象的该类型getBean将返回给定名称</span><br>  Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br><span class="hljs-comment">// 同上</span><br>  Class&lt;?&gt; getType(String name, <span class="hljs-type">boolean</span> allowFactoryBeanInit) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br> <br>  <span class="hljs-comment">// 返回指定bean名字实例的所有别名，如果有的话.</span><br>  String[] getAliases(String name);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们常用的方法就是重载的<code>getBean()</code>。</p><h4 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h4><h5 id="初始生命周期"><a href="#初始生命周期" class="headerlink" title="初始生命周期"></a>初始生命周期</h5><ol><li><p><strong>BeanNameAware</strong>：将Bean在容器中的名称</p></li><li><p><strong>BeanClassLoaderAware</strong>：将加载Bean的类加载器提供给Bean的回调接口</p></li><li><p><strong>BeanFactoryAware</strong>：将管理当前Bean的BeanFactory返回给Bean的回调接口</p></li><li><p><strong>EnvironmentAware</strong>：返回当前Spring的环境变量的回调接口</p></li><li><p><strong>EmbeddedValueResolverAware</strong>：</p></li><li><p><strong>ResourceLoaderAware</strong>： 资源加载器的回调接口</p></li><li><p><strong>ApplicationEventPublisherAware</strong>：应用事件发送器获取的回调接口</p></li><li><p><strong>MessageSourceAware</strong>：MessageSource获取的回调接口</p></li><li><p><strong>ApplicationContextAware</strong>：Application Context获取的回调接口</p></li><li><p><strong>ServletContextAware</strong>：Servlet Context获取的</p></li><li><p><strong>BeanPostProcessor.postProcessBeforeInitialization</strong> ：在Bean初始化前执行</p></li><li><p><strong>InitializingBean</strong>：由BeanFactory设置完所有属性后执行</p></li><li><p><strong>自定义的初始化方法定义</strong>：<code>@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</code></p></li><li><p><strong>BeanPostProcessor.postProcessAfterInitialization</strong>：在Bean初始化后执行</p></li></ol><h5 id="销毁生命周期"><a href="#销毁生命周期" class="headerlink" title="销毁生命周期"></a>销毁生命周期</h5><ol><li><strong>DestructionAwareBeanPostProcessor.postProcessBeforeDestruction</strong></li><li><strong>DisposableBean.destroy</strong></li><li><strong>自定义的销毁方法</strong>：<code>@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</code></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>初始化流程：</p><ul><li>调用目标对象构造器创建对象</li><li>通过一系列Aware接口注入一些常用的属性</li><li>执行BeanPostProcessor.postProcessBeforeInitialization方法</li><li>执行InitializingBean.afterPropertiesSet方法</li><li>执行Bean自定义的初始化方法</li><li>执行BeanPostProcessor.postProcessAfterInitialization方法</li></ul><p>销毁流程：</p><ul><li>执行DestructionAwareBeanPostProcessors.postProcessBeforeDestruction方法</li><li>执行DisposableBean.destroy方法</li><li>执行Bean自定义的销毁方法</li></ul><h3 id="BeanFactoryPostBeanPostProcessor"><a href="#BeanFactoryPostBeanPostProcessor" class="headerlink" title="BeanFactoryPostBeanPostProcessor"></a>BeanFactoryPostBeanPostProcessor</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><code>BeanFactoryPostBeanPostProcessor</code>是一个回调接口，可以在BeanDefinition被加载到BeanFactory后如果想再次对BeanDefinition进行修改就可以实现此接口。Spring会在加载完BeanDefinition后回调此接口。</p><p>注意：再此接口实现中不能与Bean实例进行交互。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 在标准初始化后修改ApplicationContext内的BeanFactory，所有的BeanDefinition都被加载，但没有被创建。</span><br><span class="hljs-comment">  * 可以覆盖或添加属性，甚至可以用于初始化bean</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>BeanFactoryPostProcessor主要用于当BeanDefinition被加载到BeanFactory中后，对BeanDefinition进行修改。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;io.better.spring.ioc&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IocConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> IocBean <span class="hljs-title function_">iocBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IocBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IocBean</span> &#123;<br><br>  <span class="hljs-keyword">private</span> String name;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">IocBean</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;IocBean init&quot;</span>);<br>  &#125;<br><span class="hljs-comment">// 忽略get/set方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;IocBean custom init&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;IocBean custom destroy&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在IocConfiguration配置中我们并没有指定IocBean的初始化和销毁方法，以及懒加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IocBeanFactoryProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;BeanFactoryPostProcessor .....&quot;</span>);<br><br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">iocBeanDefinition</span> <span class="hljs-operator">=</span> beanFactory.getBeanDefinition(<span class="hljs-string">&quot;iocBean&quot;</span>);<br><br>        iocBeanDefinition.setInitMethodName(<span class="hljs-string">&quot;init&quot;</span>);<br>        iocBeanDefinition.setDestroyMethodName(<span class="hljs-string">&quot;destroy&quot;</span>);<br>        iocBeanDefinition.setLazyInit(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在BeanFactoryPostProcessor实现中我们为IocBean指定了初始化和销毁的方法，以及懒加载。</p><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIocBeanFactoryPostProcessor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(IocConfiguration.class);<br><br>    <span class="hljs-type">IocBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> (IocBean) applicationContext.getBean(<span class="hljs-string">&quot;iocBean&quot;</span>);<br><br>    System.out.println(bean);<br>    applicationContext.close();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">BeanFactoryPostProcessor .....<br>IocBean Constructor<br>IocBean custom init<br>io.better.spring.ioc.IocBean@9225652<br>IocBean custom destroy<br></code></pre></td></tr></table></figure><p>从测试结果可以看出，我们在BeanFactoryPostProcessor中成功的操作了已经被BeanFactory加载的BeanDefinition并对其进行了修改。</p><p><strong>到这里你可能会想既然能修改BeanDefinition，那能不能注册一个BeanDefinition呢？</strong></p><p>要想往BeanFactory中注册一个BeanDefinition需要实现接口<code>BeanDefinitionRegistryPostProcessor</code>。</p><p>该接口是BeanFactoryPostProcessor的子接口。</p><h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a><code>BeanDefinitionRegistryPostProcessor</code></h4><h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IocBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    System.out.println(<span class="hljs-string">&quot;BeanDefinitionRegistryPostProcessor&quot;</span>);<br>    <br>    <span class="hljs-comment">// 创建IocRegistryTestBean的BeanDefinition</span><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(IocRegistryTestBean.class)<br>      .addPropertyValue(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;registry post processor inject&quot;</span>)<br>      .getBeanDefinition();<br><span class="hljs-comment">// 注册进BeanFactory</span><br>    registry.registerBeanDefinition(<span class="hljs-string">&quot;iocRegistryTestBean&quot;</span>, beanDefinition);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">iocRegistryTestBean</span> <span class="hljs-operator">=</span> beanFactory.getBeanDefinition(<span class="hljs-string">&quot;iocRegistryTestBean&quot;</span>);<br><br>    iocRegistryTestBean.setInitMethodName(<span class="hljs-string">&quot;init&quot;</span>);<br>    iocRegistryTestBean.setDestroyMethodName(<span class="hljs-string">&quot;destroy&quot;</span>);<br>    iocRegistryTestBean.setLazyInit(<span class="hljs-literal">true</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;io.better.spring.ioc&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IocConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIocBeanFactoryPostProcessor</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(IocConfiguration.class);<br><br>  <span class="hljs-type">IocRegistryTestBean</span> <span class="hljs-variable">iocRegistryTestBean</span> <span class="hljs-operator">=</span> <br>    (IocRegistryTestBean) applicationContext.getBean(<span class="hljs-string">&quot;iocRegistryTestBean&quot;</span>);<br><br>  System.out.println(iocRegistryTestBean);<br>  applicationContext.close();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">BeanDefinitionRegistryPostProcessor<br>BeanFactoryPostProcessor .....<br>IocRegistryTestBean custom init<br>IocRegistryTestBean&#123;name=&#x27;registry post processor inject&#x27;&#125;<br>IocRegistryTestBean custom destroy<br></code></pre></td></tr></table></figure><p>从执行结果看出在<code>BeanDefinitionRegistryPostProcessor</code>想BeanFactory中注册了一个IocRegistryTestBean实例，并指定了其初始化和销毁的方法以及懒加载。</p><p><code>BeanDefinitionRegistryPostProcessor</code>比<code>BeanFactoryPostProcessor</code>先执行。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>ConfigurationClassPostProcessor作用</p><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>BeanDefinitionReader是一个接口，主要是读取XML或注解标识的类并将其转成BeanDefinition，提供了使用<code>Resource</code>和<code>String location</code>参数指定加载方法。</p><p>此接口是个规范接口，具体的BeanDefinitionReader无需实现此接口。BeanDefinition读取的简单接口。</p><h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionReader</span> &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 返回通过BeanDefinitionRegistry接口暴露的BeanFactory去注册BeanDefinition</span><br><span class="hljs-comment">    */</span><br>  BeanDefinitionRegistry <span class="hljs-title function_">getRegistry</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-meta">@Nullable</span><br>  ResourceLoader <span class="hljs-title function_">getResourceLoader</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 返回用于Bean类的类加载器。</span><br>  <span class="hljs-comment">// null建议不要急于加载Bean类，而只是用类名注册Bean定义，并在以后解析（或永不解析）相应的类。</span><br>  <span class="hljs-meta">@Nullable</span><br>  ClassLoader <span class="hljs-title function_">getBeanClassLoader</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 返回BeanNameGenerator用于匿名Bean（未指定显式Bean名称）</span><br>  BeanNameGenerator <span class="hljs-title function_">getBeanNameGenerator</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">// 从指定的Resource中加载BeanDefinition</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>  <span class="hljs-comment">// 从指定的Resource数组中加载BeanDefinition</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>  <span class="hljs-comment">// 同上</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>  <span class="hljs-comment">// 同上</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><p>我们以<code>XmlBeanDefinitionReader</code>为例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;iocBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.better.spring.ioc.IocBean&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test-xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">GenericXmlApplicationContext</span><span class="hljs-params">(String... resourceLocations)</span> &#123;<br>   load(resourceLocations);<br>   refresh();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">(String... resourceLocations)</span> &#123;<br>   <span class="hljs-built_in">this</span>.reader.loadBeanDefinitions(resourceLocations);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(<span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure><p>可以看出<code>GenericXmlApplicationContext</code>中持有了<code>XmlBeanDefinitionReader</code>的引用，并在初始化时调用了XmlBeanDefinitionReader的loadBeanDefinitions方法加载了BeanDefinition。</p><h4 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIocBeanDefinitionReader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">GenericXmlApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericXmlApplicationContext</span>(<span class="hljs-string">&quot;Ioc.xml&quot;</span>);<br><br>    System.out.println(applicationContext.getBean(<span class="hljs-string">&quot;iocBean&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>BeanPostProcessor为一个接口，用于在BeanFactory实例化Bean后对Bean进行扩展需要实现的接口，Spring会在初始化每个Bean后会回调这个接口。</p><p>如果有多个<code>BeanPostProcessor</code>实例，我们可以通过设置<code>order</code>属性或实现<code>Ordered</code>接口来控制执行顺序。</p><p>BeanPostProcessor接口由两个回调方法组成，即<code>postprocessbeforeinitialize()</code>和<code>postprocessafterinitialize()</code>。</p><p>我们可以对实例化的Bean进行包装或修改，例如<code>Aop</code>（使用的是<code>AbstractAdvisingBeanPostProcessor</code>类）就是一个很好的例子。</p><h4 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>  <span class="hljs-comment">// 在InitializingBean.afterPropertiesSet或自定义初始化方法之前应用这个BeanPostProcessor</span><br>  <span class="hljs-comment">// 此时该Bean已经填充了属性值。</span><br>  <span class="hljs-comment">// 这个方法可以对原始实例进行包装，默认实现按原样返回给定的bean。</span><br>  <span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">return</span> bean;<br>  &#125;<br><br>  <span class="hljs-comment">// 在InitializingBean.afterPropertiesSet或自定义初始化方法之后应用这个BeanPostProcessor</span><br>  <span class="hljs-comment">// 此时该Bean已经填充了属性值。</span><br>  <span class="hljs-comment">// 对于FactoryBean，将为FactoryBean实例和由FactoryBean创建的对象（从Spring 2.0开始）调用此回调。 </span><br>  <span class="hljs-comment">// post-processor可以通过FactoryBean检查的相应bean实例来决定是应用到FactoryBean还是创建的对象，还是两者都应用。</span><br>  <span class="hljs-comment">// 与所有其他BeanPostProcessor回调相反，此回调还将在</span><br>  <span class="hljs-comment">// InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation方法触发短路后被调用。</span><br>  <span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">return</span> bean;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们利用BeanPostProcessor来实现一个简单的Aop代理功能，示例代码如下：</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IocBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> IocBean) &#123;<br>      <span class="hljs-type">IocBean</span> <span class="hljs-variable">iocBean</span> <span class="hljs-operator">=</span> (IocBean) bean;<br>      <span class="hljs-comment">// 设置Name属性</span><br>      iocBean.setName(<span class="hljs-string">&quot;test-BeanPostProcessor&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;IocBeanPostProcessor Before &quot;</span> + beanName);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> IocBean) &#123;<br>      System.out.println(<span class="hljs-string">&quot;IocBeanPostProcessor After &quot;</span> + beanName);<br>      <br>      <span class="hljs-comment">// 为IocBean创建代理对象</span><br>      <span class="hljs-type">IocBean</span> <span class="hljs-variable">iocBean</span> <span class="hljs-operator">=</span> (IocBean) bean;<br><br>      <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>      enhancer.setSuperclass(IocBean.class);<br>      enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibProxy</span>(iocBean));<br>      <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Cglib执行程序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>  <span class="hljs-keyword">private</span> Object proxyTarget;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CglibProxy</span><span class="hljs-params">(Object proxyTarget)</span> &#123;<br>    <span class="hljs-built_in">this</span>.proxyTarget = proxyTarget;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>    System.out.println(<span class="hljs-string">&quot;BeanPostProcessor Cglib 代理执行前&quot;</span>);<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(proxyTarget, objects);<br><br>    System.out.println(<span class="hljs-string">&quot;BeanPostProcessor Cglib 代理执行后&quot;</span>);<br>    <span class="hljs-keyword">return</span> invoke;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中在Before中为IocBean的Name属性进行了赋值，在After中为IocBean创建了代理对象。</p><h4 id="测试代码-3"><a href="#测试代码-3" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIocBeanPostProcessor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(IocConfiguration.class);<br>    <span class="hljs-type">IocBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> applicationContext.getBean(IocBean.class);<br>    bean.say();<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们从Application Context获取的Bean实例是在BeanPostProcessor中创建的代理对象。</p><h4 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">IocBean Constructor   // 初始化bean<br>IocBeanPostProcessor Before iocBean  // 设置name属性<br>IocBeanPostProcessor After iocBean // 创建Cglib代理<br>IocBean Constructor // cglib代理类调用<br>// 执行Say方法<br>BeanPostProcessor Cglib 代理执行前<br>IocBean  Say :test-BeanPostProcessor<br>BeanPostProcessor Cglib 代理执行后<br></code></pre></td></tr></table></figure><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>FactoryBean是一个接口，如果Bean实现此接口，则它将用作对象公开的工厂，而不是直接用作将自身公开的bean实例。</p><p>FactoryBeans可以支持单例和原型，并且可以按需延迟创建对象，也可以在启动时急于创建对象。 </p><p>注意：实现此接口的Bean不能用作普通Bean。 FactoryBean以Bean样式定义（名称，别名和普通Bean一致），但是为Bean引用公开的对象始终是由<code>Factory.getObject()</code>方法创建的对象。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>在Spring中我们注册实例化Bean的方式一般都是使用<code>@Component，@Bean</code>等注解将Bean注册到容器中，整个过程对于开发人员来说是不可见的（除非阅读源码）。Spring为了更好的扩展提供了<code>FactoryBean</code>这个接口让开发人员可以自定义Bean的实例化和注册过程。</p><p>实现了<code>FactoryBean&lt;T&gt;</code>接口的Bean，Spring会向容器中注册两个Bean，一个是FactoryBean实例本身，一个是<code>FactoryBean.getObject()</code>方法返回值所代表的Bean。</p><p>根据该Bean的ID从BeanFactory中获取的实际上是<code>FactoryBean.getObject()</code>返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个<code>&amp;</code>符号来获取（和BeanFactory中的静态变量<code>FACTORY_BEAN_PREFIX</code>对应）。</p><h4 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FactoryBean</span>&lt;T&gt; &#123;<br><br>  <span class="hljs-type">String</span> <span class="hljs-variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;factoryBeanObjectType&quot;</span>;<br><br>  <span class="hljs-comment">// 调用获取对象，可以是任意类型的对象</span><br>  T <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br><br>  <span class="hljs-comment">// 获取对象类型</span><br>  Class&lt;?&gt; getObjectType();<br><br>  <span class="hljs-comment">// 是否是单例</span><br>  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IocBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;Object&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> String name;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">IocBean</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;IocBean init&quot;</span>);<br>    System.out.println(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;IocBean custom init&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;IocBean custom destroy&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    System.out.println(<span class="hljs-string">&quot;FactoryBean Create IocBean Instance&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IocBean</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>    <span class="hljs-keyword">return</span> IocBean.class;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="测试代码-4"><a href="#测试代码-4" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIoc</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(IocConfiguration.class);<br><br>  <span class="hljs-type">IocBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> (IocBean) applicationContext.getBean(<span class="hljs-string">&quot;iocBean&quot;</span>);<br>  <span class="hljs-type">IocBean</span> <span class="hljs-variable">factoryBean</span> <span class="hljs-operator">=</span> (IocBean) applicationContext.getBean(<span class="hljs-string">&quot;&amp;iocBean&quot;</span>);<br><br>  System.out.println(bean);<br>  System.out.println(factoryBean);<br>  applicationContext.close();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">// 第一次初始化<br>IocBean init<br>io.better.spring.ioc.IocBean@159f197<br>// BeanFactory.getObject()执行<br>FactoryBean Create IocBean Instance<br>// 第二次初始化<br>IocBean init<br>io.better.spring.ioc.IocBean@6fe7aac8<br>// sout输出内容<br>io.better.spring.ioc.IocBean@6fe7aac8<br>io.better.spring.ioc.IocBean@159f197<br></code></pre></td></tr></table></figure><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>从执行结果可以看出IocBean的实例对象是由<code>FactoryBean.getObject()</code>方法创建的。</p><p>通过打印从<code>容器获取FactoryBean实例</code>和<code>构造器中打印语句</code>得出：IocBean类被实例化了两次</p><ul><li>第一次实例化的是FactoryBean实例</li><li>第二次实例化的是IocBean实例（是通过FactoryBean.getObject方法创建的）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybaits 启动加载</title>
    <link href="/2019/10/09/mybatis/01-mybatis-init-load/"/>
    <url>/2019/10/09/mybatis/01-mybatis-init-load/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-启动加载"><a href="#Mybatis-启动加载" class="headerlink" title="Mybatis-启动加载"></a>Mybatis-启动加载</h1><h2 id="本章节讲述的内容"><a href="#本章节讲述的内容" class="headerlink" title="本章节讲述的内容"></a>本章节讲述的内容</h2><blockquote><p>本章节主要分析Mybatis在启动时做了那些操作。带着以下疑问去阅读本章内容。本章内容涉及了大量的mybatis源码。</p><p>1、Mybaits是如何解析配置文件（mybatis-config.xml）？</p><p>2、Mybaits是如何解析Mapper文件（mapper.xml）？</p><p>3、Mybatis是如何设计</p></blockquote><p>想知道如何使用Mybatis请参考<a href="https://mybatis.org/mybatis-3/zh/">Mybatis官方文档</a>。</p><h2 id="相关配置依赖"><a href="#相关配置依赖" class="headerlink" title="相关配置依赖"></a>相关配置依赖</h2><p>本文使用的Mybatis版本：<code>3.5.4</code>，不依赖任何Spring的环境。</p><h3 id="坐标依赖"><a href="#坐标依赖" class="headerlink" title="坐标依赖"></a>坐标依赖</h3><p>Maven坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Gradle坐标：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">compile <span class="hljs-string">&#x27;org.mybatis:mybatis:3.5.4&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SLF4J&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logPrefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;source-code-analysis&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.better.mybatis.model&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/source-code-analysis&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mybatis/mappers/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Mybatis的启动时主要分为两个阶段：<code>配置文件加载解析阶段，Mapper文件加载解析阶段</code>。</strong></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisTest</span> &#123;<br><br>    SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis/mybatis-config.xml&quot;</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>        sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSqlSessionFactoryInit</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(sqlSessionFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置文件加载解析阶段"><a href="#配置文件加载解析阶段" class="headerlink" title="配置文件加载解析阶段"></a>配置文件加载解析阶段</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在这个阶段我们会去了解Mybatis是如何解析配置文件的？</p><h3 id="构建开始"><a href="#构建开始" class="headerlink" title="构建开始"></a>构建开始</h3><p>从官网文档我们知道使用Mybatis第一步就是使用<code>SqlSessionFactoryBuilder</code>来构建<code>SqlSessionFactory</code>。</p><p>而<code>SqlSessionFactoryBuilder</code>类提供了多个重载的<code>build</code>方法：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164710.png" alt="image-20200430102857721" style="zoom:50%;" /><p>这里我们使用的是<code>build(InputStream)</code>方法。进入该方法的源代码：</p><h3 id="执行-SqlSessionFactoryBuilder-build"><a href="#执行-SqlSessionFactoryBuilder-build" class="headerlink" title="执行-SqlSessionFactoryBuilder.build()"></a>执行-<code>SqlSessionFactoryBuilder.build()</code></h3><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">build</span><span class="hljs-params">(InputStream inputStream, String environment, Properties properties)</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 创建XMLConfigBuilder，该对象用于解析Mybatis配置文件</span><br>    <span class="hljs-type">XMLConfigBuilder</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLConfigBuilder</span>(inputStream, environment, properties);<br>    <span class="hljs-comment">// build会用解析配置文件的结果来创建SqlSessionFactory</span><br>    <span class="hljs-keyword">return</span> build(parser.parse());<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>build</code>方法比较简单，就是使用<code>XMLConfigBuilder.parse</code>生成的<code>Configuration</code>对象创建<code>SqlSessionFactory</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">build</span><span class="hljs-params">(Configuration config)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSessionFactory</span>(config);<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>XMLConfigBuilder.parse</code>方法主要描述了Mybatis解析配置文件并生成Configuration对象的过程。</p><p>成员变量：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164704.png" alt="image-20200430103839043"></p><ul><li><code>parsed：</code>标识了配置是否已经解析。</li><li><code>parser：</code>用于解析XML配置文件</li><li><code>environment：</code>Mybatis的环境配置</li><li><code>localReflectorFactory：</code>反射工厂</li></ul><p>构造器：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164659.png" alt="image-20200430104004899"></p><p><code>org.apache.ibatis.builder.xml.XMLConfigBuilder#parse</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Configuration <span class="hljs-title function_">parse</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (parsed) &#123;<span class="hljs-comment">// 已经解析过直接抛出异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuilderException</span>(<span class="hljs-string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);<br>  &#125;<br>  parsed = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 将parsed置为true，避免重复解析。</span><br><span class="hljs-comment">// 调用parser获取配置文件中的configuration节点</span><br>  <span class="hljs-comment">// 调用parseConfiguration方法继续解析</span><br>  parseConfiguration(parser.evalNode(<span class="hljs-string">&quot;/configuration&quot;</span>));<br>  <span class="hljs-keyword">return</span> configuration;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行-XMLConfigBuilder-parseConfiguration"><a href="#执行-XMLConfigBuilder-parseConfiguration" class="headerlink" title="执行-XMLConfigBuilder.parseConfiguration()"></a>执行-<code>XMLConfigBuilder.parseConfiguration()</code></h3><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseConfiguration</span><span class="hljs-params">(XNode root)</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 解析properties标签配置</span><br>    propertiesElement(root.evalNode(<span class="hljs-string">&quot;properties&quot;</span>));<br>    <span class="hljs-comment">// 解析settings标签配置</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">settings</span> <span class="hljs-operator">=</span> settingsAsProperties(root.evalNode(<span class="hljs-string">&quot;settings&quot;</span>));<br><span class="hljs-comment">// 使用setting配置日志实现类</span><br>    loadCustomLogImpl(settings);<br>    <span class="hljs-comment">// 解析typeAliases标签配置</span><br>    typeAliasesElement(root.evalNode(<span class="hljs-string">&quot;typeAliases&quot;</span>));<br>    <span class="hljs-comment">// 解析plugins标签配置</span><br>    pluginElement(root.evalNode(<span class="hljs-string">&quot;plugins&quot;</span>));<br>    <span class="hljs-comment">// 使用settings配置对configuration对象中的属性进行赋值</span><br>    settingsElement(settings);<br>    <span class="hljs-comment">// 解析environments标签配置</span><br>    environmentsElement(root.evalNode(<span class="hljs-string">&quot;environments&quot;</span>));<br>    <span class="hljs-comment">// 解析mappers标签配置, 开启Mapper文件解析阶段</span><br>    mapperElement(root.evalNode(<span class="hljs-string">&quot;mappers&quot;</span>));<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuilderException</span>(<span class="hljs-string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>parseConfiguration</code>方法中，Mybatis对配置中的不同标签分别进行了处理，这里只列举常用的标签配置，例如：<code>properties，settings，typeAliases，plugins，environments，mappers</code>等标签进行了处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseConfiguration</span><span class="hljs-params">(XNode root)</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 解析properties标签配置</span><br>    propertiesElement(root.evalNode(<span class="hljs-string">&quot;properties&quot;</span>));<br>    <span class="hljs-comment">// 解析settings标签配置</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">settings</span> <span class="hljs-operator">=</span> settingsAsProperties(root.evalNode(<span class="hljs-string">&quot;settings&quot;</span>));<br><span class="hljs-comment">// 使用setting配置日志实现类</span><br>    loadCustomLogImpl(settings);<br>    <span class="hljs-comment">// 解析typeAliases标签配置</span><br>    typeAliasesElement(root.evalNode(<span class="hljs-string">&quot;typeAliases&quot;</span>));<br>    <span class="hljs-comment">// 解析plugins标签配置</span><br>    pluginElement(root.evalNode(<span class="hljs-string">&quot;plugins&quot;</span>));<br>    <span class="hljs-comment">// 使用settings配置对configuration对象中的属性进行赋值</span><br>    settingsElement(settings);<br>    <span class="hljs-comment">// 解析environments标签配置</span><br>    environmentsElement(root.evalNode(<span class="hljs-string">&quot;environments&quot;</span>));<br>    <span class="hljs-comment">// 解析mappers标签配置, 开启Mapper文件解析阶段</span><br>    mapperElement(root.evalNode(<span class="hljs-string">&quot;mappers&quot;</span>));<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuilderException</span>(<span class="hljs-string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解析Properties标签"><a href="#解析Properties标签" class="headerlink" title="解析Properties标签"></a>解析<code>Properties</code>标签</h4><p>从上面代码可以看出<code>propertiesElement</code>方法是解析Properties标签的核心方法，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">propertiesElement</span><span class="hljs-params">(XNode context)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 获取properties标签中resource和url配置</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;resource&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;url&quot;</span>);<br>    <span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 使用resource路径加载properties</span><br>      defaults.putAll(Resources.getResourceAsProperties(resource));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 使用url加载properties</span><br>      defaults.putAll(Resources.getUrlAsProperties(url));<br>    &#125;<br>    <span class="hljs-comment">// 获取到configuration中已有的属性</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">vars</span> <span class="hljs-operator">=</span> configuration.getVariables();<br>    <span class="hljs-keyword">if</span> (vars != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 合并</span><br>      defaults.putAll(vars);<br>    &#125; <br>    parser.setVariables(defaults);<br>    <span class="hljs-comment">// 重新赋值</span><br>    configuration.setVariables(defaults);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出解析出来的<code>Properties</code>属性，最终被赋值到了<code>Configuration</code>中的<code>variables</code>对象中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Configuration的成员变量</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">Properties</span> <span class="hljs-variable">variables</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br></code></pre></td></tr></table></figure><h4 id="解析Settings标签"><a href="#解析Settings标签" class="headerlink" title="解析Settings标签"></a>解析<code>Settings</code>标签</h4><p>使用类似的方式查看<code>settingsAsProperties</code>方法中处理<code>Setting</code>标签的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Properties <span class="hljs-title function_">settingsAsProperties</span><span class="hljs-params">(XNode context)</span> &#123;<br>  <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>  &#125;<br>  <span class="hljs-comment">// 获取所有setting子节点，并将其转成properties</span><br>  <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> context.getChildrenAsProperties();<br><span class="hljs-comment">// 通过反射获取Configuration类的元数据信息</span><br>  <span class="hljs-type">MetaClass</span> <span class="hljs-variable">metaConfig</span> <span class="hljs-operator">=</span> MetaClass.forClass(Configuration.class, localReflectorFactory);<br>  <span class="hljs-comment">// 判断配置的属性在Configuration是否存在</span><br>  <span class="hljs-keyword">for</span> (Object key : props.keySet()) &#123;<br>    <span class="hljs-comment">// 判断Configuration对象是否存在此配置的Setter方法。</span><br>    <span class="hljs-keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuilderException</span>(<span class="hljs-string">&quot;此配置无效：&quot;</span> + key);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> props;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MetaClass.forClass</code>方法作用是使用<code>localReflectorFactory</code>创建一个<code>Reflector</code>实例，该实例中包含了Configuration类所有的<code>构造器，方法，属性</code>等。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164650.png"></p><h4 id="使用Settings标签"><a href="#使用Settings标签" class="headerlink" title="使用Settings标签"></a>使用<code>Settings</code>标签</h4><p>上面我们知道了<code>Settings</code>配置时如何解析的，但却没有使用到<code>Settings</code>配置。</p><p><code>loadCustomVfs(settings)：</code>忽略</p><p> <code>loadCustomLogImpl(settings)：</code>设置Mybatis的日志实现。</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164645.png" alt="image-20200430111703591"  /><p><code>settingsElement(settings)：</code>设置Mybatis所有全局配置，Settings没有则使用默认配置。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164633.png" alt="image-20200430111538374"></p><h4 id="解析typeAliasesElement标签"><a href="#解析typeAliasesElement标签" class="headerlink" title="解析typeAliasesElement标签"></a>解析<code>typeAliasesElement</code>标签</h4><p>源代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">typeAliasesElement</span><span class="hljs-params">(XNode parent)</span> &#123;<br>  <span class="hljs-comment">// 获取到typeAliases标签下所有的子标签</span><br>  <span class="hljs-keyword">for</span> (XNode child : parent.getChildren()) &#123;<br>    <span class="hljs-comment">// 如果标签以package开头，说明配置的是整个包的别名</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;package&quot;</span>.equals(child.getName())) &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">typeAliasPackage</span> <span class="hljs-operator">=</span> child.getStringAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br>      <span class="hljs-comment">// registerAliases方法会扫描整个包下的类，并生成其对应的Class对象</span><br>      <span class="hljs-comment">// 最后添加到configuration.typeAliasRegistry属性对象中</span><br>      configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);<br>    &#125; <br>    <span class="hljs-comment">// 否则就是以typeAlias开头的标签，配置的是单个别名</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 获取到别名</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">alias</span> <span class="hljs-operator">=</span> child.getStringAttribute(<span class="hljs-string">&quot;alias&quot;</span>);<br>      <span class="hljs-comment">// 获取别名对应的class</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> child.getStringAttribute(<span class="hljs-string">&quot;type&quot;</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 根据type解析出其真实的class对象</span><br>        Class&lt;?&gt; clazz = Resources.classForName(type);<br>        <span class="hljs-keyword">if</span> (alias == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 别名为空，默认使用类名做为别名</span><br>          typeAliasRegistry.registerAlias(clazz);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          typeAliasRegistry.registerAlias(alias, clazz);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看出配置<code>typeAliases</code>有两种方式：</p><p>1、使用package标签配置整个包下的别名。</p><p>2、使用typeAlias标签配置单个别名。</p><p>获取到<code>别名对应的Class对象</code>后，最终调用了<code>typeAliasRegistry.registerAlias</code>方法注册了别名。而<code>typeAliasRegistry</code>对象引用之Configuration对象。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164624.png" alt="image-20200430112247768"></p><p>让我们进入<code>typeAliasRegistry.registerAlias</code>方法查看具体注册逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerAlias</span><span class="hljs-params">(String alias, Class&lt;?&gt; value)</span> &#123;<br>  <span class="hljs-keyword">if</span> (alias == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeException</span>(<span class="hljs-string">&quot;The parameter alias cannot be null&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// issue #748</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> alias.toLowerCase(Locale.ENGLISH);<br>  <span class="hljs-comment">// 判断alias是否已经存在，且对应的class不一致，抛出异常。</span><br>  <span class="hljs-keyword">if</span> (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != <span class="hljs-literal">null</span> &amp;&amp; !typeAliases.get(key).equals(value)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeException</span>(<span class="hljs-string">&quot;&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 放入typeAliases中</span><br>  typeAliases.put(key, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们看一下该类的结构图：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164616.png" alt="image-20200430112955479"></p><p>从类结构图能看出<code>TypeAliasRegistry</code>类中重载了很多<code>registerAliases</code>方法，同时<code>typeAliases</code>保存了所有注册的别名信息。并且在初始化时默认添加了很多基础类型对应的别名。</p><p>结论：Mybatis将解析的别名配置，最终放入了<code>Configuration</code>中的<code>TypeAliasRegistry</code>对象中。</p><h4 id="解析plugins标签"><a href="#解析plugins标签" class="headerlink" title="解析plugins标签"></a>解析<code>plugins</code>标签</h4><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pluginElement</span><span class="hljs-params">(XNode parent)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (XNode child : parent.getChildren()) &#123;<br>      <span class="hljs-comment">// 获取配置的interceptor对应的class信息</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> child.getStringAttribute(<span class="hljs-string">&quot;interceptor&quot;</span>);<br>      <span class="hljs-comment">// 获取plugin标签下的属性</span><br>      <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> child.getChildrenAsProperties();<br>      <span class="hljs-comment">// resolveClass方法解析具体interceptor的class</span><br>      <span class="hljs-type">Interceptor</span> <span class="hljs-variable">interceptorInstance</span> <span class="hljs-operator">=</span> (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();<br>      <span class="hljs-comment">// 将属性赋值给Interceptor</span><br>      interceptorInstance.setProperties(properties);<br>      <span class="hljs-comment">// 添加到Configuration中</span><br>      configuration.addInterceptor(interceptorInstance);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出解析Interceptor最终通过反射初始化被添加到了Configuration中 。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164611.png" alt="image-20200430141031684"></p><h4 id="解析environmentsElement标签"><a href="#解析environmentsElement标签" class="headerlink" title="解析environmentsElement标签"></a>解析<code>environmentsElement</code>标签</h4><p>参考Xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/source-code-analysis&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">environmentsElement</span><span class="hljs-params">(XNode context)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (environment == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 获取默认的environment，即上面的development</span><br>      environment = context.getStringAttribute(<span class="hljs-string">&quot;default&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 获取到所有的environment子标签</span><br>    <span class="hljs-keyword">for</span> (XNode child : context.getChildren()) &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> child.getStringAttribute(<span class="hljs-string">&quot;id&quot;</span>);<br>      <span class="hljs-comment">// environment是否和默认配置的一致</span><br>      <span class="hljs-keyword">if</span> (isSpecifiedEnvironment(id)) &#123;<br>        <span class="hljs-comment">// 创建事务管理器，即上面的JDBC事务管理器</span><br>        <span class="hljs-type">TransactionFactory</span> <span class="hljs-variable">txFactory</span> <span class="hljs-operator">=</span> transactionManagerElement(child.evalNode(<span class="hljs-string">&quot;transactionManager&quot;</span>));<br>        <span class="hljs-comment">// 创建数据源工厂</span><br>        <span class="hljs-type">DataSourceFactory</span> <span class="hljs-variable">dsFactory</span> <span class="hljs-operator">=</span> dataSourceElement(child.evalNode(<span class="hljs-string">&quot;dataSource&quot;</span>));<br>        <span class="hljs-comment">// 并获取到数据源</span><br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> dsFactory.getDataSource();<br>        <span class="hljs-comment">// 构建Environment</span><br>        Environment.<span class="hljs-type">Builder</span> <span class="hljs-variable">environmentBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Environment</span>.Builder(id)<br>          .transactionFactory(txFactory)<br>          .dataSource(dataSource);<br>        <span class="hljs-comment">// 赋值给configuration对象</span><br>        configuration.setEnvironment(environmentBuilder.build());<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看出，Mybatis获取环境变量后创建了两个核心对象：1、TransactionFactory。2、DataSource，其对应的方法是</p><p><code>transactionManagerElement()</code>， <code>dataSourceElement()</code>两个方法。底层实现都是通过反射进行实例化。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164602.png" alt="image-20200430142709538"></p><p>我们以<code>PooledDataSourceFactory</code>子类为例。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164552.png" alt="image-20200430142750298"></p><p>至此Mybatis的第一阶段配置文件的解析到此结束，这里还有Mapper文件的解析（下面讲解）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>解析出来的<code>Properties</code>配置，最终被赋值到了<code>Configuration</code>中的<code>variables</code>对象中。</li><li>解析出来的<code>typeAliases</code>配置，最终放入了<code>Configuration</code>中的<code>typeAliasRegistry</code>对象中。</li><li>解析出来的<code>Plugins</code>配置，最终放入了Configuration中的<code>interceptorChain</code>对象中。</li><li>解析出来的<code>environments</code>配置，用于<code>创建了数据源和事务工厂</code>。最终构建<code>Environment</code>对象赋值给Configuration中。</li></ul><p>从上面处理流程可以看出Configuration非常的重要，几乎所有的配置最终都会汇聚到Configuration对象中。</p><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream) -&gt; Mybatis构建入口 <br>  &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration -&gt; 解析configuration标签配置<br>   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#propertiesElement -&gt; 解析properties标签配置<br>   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#settingsAsProperties -&gt; 解析settings标签配置<br>   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#typeAliasesElement -&gt; 解析typeAliases标签配置<br>   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#pluginElement -&gt; 解析plugins标签配置<br>   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#environmentsElement -&gt; 解析environments标签配置<br>   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement -&gt; 解析mappers标签配置<br></code></pre></td></tr></table></figure><h2 id="Mapper文件加载解析阶段"><a href="#Mapper文件加载解析阶段" class="headerlink" title="Mapper文件加载解析阶段"></a>Mapper文件加载解析阶段</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在这个阶段我们将深入了解Mybatis是如何解析Mapper文件。如何绑定Mapper接口和文件的关系。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>在进入分析之前我们先思考几个问题：</p><p>1、Mybatis是如何<code>Select，Insert，Delete，Update</code>标签的？</p><p>2、Mybatis是如何处理<code>Include</code>标签的？</p><p>3、Mybatis是如何处理动态SQL标签（<code>set，foreach，if</code>）？</p><p>4、Mybatis是如何处理<code>resultMap</code>标签的？</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>在上个阶段的最后一行方法：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164546.png" alt="image-20200430144550431"></p><p>红圈内的方法就是解析Mapper文件流程的入口方法。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164537.png" alt="image-20200430151542891"></p><p>从图中可以看出解析Mapper文件有两种方式：</p><ol><li><p>使用Package标签扫描整个包下的Mapper接完成注册。</p></li><li><p>使用Mapper标签配置单个Mapper。</p><ol><li>Mapper标签支持三种方式 ：<code>resource（路径），url（网络），class（class类）</code>来加载Mapper。</li></ol></li></ol><h3 id="使用Package解析"><a href="#使用Package解析" class="headerlink" title="使用Package解析"></a>使用<code>Package</code>解析</h3><p>进入 <code>configuration.addMappers(mapperPackage)</code>方法，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMappers</span><span class="hljs-params">(String packageName)</span> &#123;<br>  mapperRegistry.addMappers(packageName);<br>&#125;<br></code></pre></td></tr></table></figure><p>从<code>mapperRegistry</code>对象的命名可以看出，该对象主要是负责注册Mapper的。</p><p>进入<code>addMappers</code>方法：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164530.png" alt="image-20200430163542757"  /><p>代码会获取到包下所有Mapper对应的Class信息，并进行遍历调用 <code>addMapper</code>方法。</p><p>我们可以看出Mapper解析是在MapperRegistry类中完成的，那么MapperRegistry是如何存储注册的Mapper的，来看看其类结构图：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164524.png" alt="image-20200430163959992"></p><p><code>knownMappers</code>充当了一个重要的角色，它存储了注册过的Mapper。而<code>MapperProxyFactory</code>对象则用于创建MapperProxy对象，此对象会对Mapper进行代理。</p><p>接着进入<code>addMapper</code>方法查看添加细节。</p><h4 id="执行MapperRegistry-addMapper添加Mapper"><a href="#执行MapperRegistry-addMapper添加Mapper" class="headerlink" title="执行MapperRegistry.addMapper添加Mapper"></a>执行<code>MapperRegistry.addMapper</code>添加<code>Mapper</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>  <span class="hljs-keyword">if</span> (type.isInterface()) &#123;<span class="hljs-comment">// 接口才处理</span><br>    <span class="hljs-keyword">if</span> (hasMapper(type)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;此Mapper已经存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">loadCompleted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      knownMappers.put(type, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;&gt;(type));<br>      <span class="hljs-comment">// 创建MapperAnnotationBuilder构建起</span><br>      <span class="hljs-type">MapperAnnotationBuilder</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperAnnotationBuilder</span>(config, type);<br>      <span class="hljs-comment">// 构建Mapper</span><br>      parser.parse();<br>      loadCompleted = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法主要做了以下几个操作：</p><ul><li>将Mapper对应的Class对象放入knownMappers对象中。</li><li>创建MapperAnnotationBuilder构建器构建Mapper。</li></ul><h4 id="执行MapperAnnotationBuilder-parse解析Mapper"><a href="#执行MapperAnnotationBuilder-parse解析Mapper" class="headerlink" title="执行MapperAnnotationBuilder.parse解析Mapper"></a>执行<code>MapperAnnotationBuilder.parse</code>解析<code>Mapper</code></h4><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> type.toString();<br>  <span class="hljs-keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;<span class="hljs-comment">// 判断当前资源是否加载过</span><br>    <span class="hljs-comment">// 步骤①</span><br>    loadXmlResource();<br>    configuration.addLoadedResource(resource);<span class="hljs-comment">// 添加到Configuration对象中，标识已经加载过</span><br>    assistant.setCurrentNamespace(type.getName());<br>    parseCache();<br>    parseCacheRef();<br>    <span class="hljs-keyword">for</span> (Method method : type.getMethods()) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!method.isBridge()) &#123;<br>          <span class="hljs-comment">// 步骤②</span><br>          parseStatement(method);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IncompleteElementException e) &#123;&#125;<br>    &#125;<br>  &#125;<br>  parsePendingMethods();<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中我们看到了最为重要的两个方法：<code>loadXmlResource()：</code>用于加载Mapper对应的Xml文件，<code>parseStatement()</code>：解析Mapper方法中的注解信息。</p><p>解析过的<code>resource</code>最终会添加到Configuration中的<code>loadedResources</code>（Set类型）对象中。</p><h5 id="loadXmlResource"><a href="#loadXmlResource" class="headerlink" title="loadXmlResource"></a><code>loadXmlResource</code></h5><p>从上面可以得知该方法主要用于解析Mapper对应的xml文件。源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadXmlResource</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (!configuration.isResourceLoaded(<span class="hljs-string">&quot;namespace:&quot;</span> + type.getName())) &#123;<br>    <span class="hljs-comment">// 将全类名中的.替换成/,以方便下面Resources获取输入流</span><br>    <span class="hljs-comment">// io.better.mybatis.mapper.UserMapper -&gt; io/better/mybatis/mapper/UserMapper.xml</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">xmlResource</span> <span class="hljs-operator">=</span> type.getName().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-string">&quot;.xml&quot;</span>;<br>    <span class="hljs-comment">// 获取到Mapper对应的Xml文件输入流</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> type.getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span> + xmlResource);<br>    <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-literal">null</span>) &#123;<br>        inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 步骤①</span><br>      <span class="hljs-type">XMLMapperBuilder</span> <span class="hljs-variable">xmlParser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLMapperBuilder</span>(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());<br>      <span class="hljs-comment">// 步骤②</span><br>      xmlParser.parse();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看出，Mybatis通过替换<code>Mapper全路径</code>获取到<code>xml对应resource中的目录层级</code>，并获取到InputStream流。</p><p>举例：<code>io.better.mybatis.mapper.UserMapper -&gt; resource/io/better/mybatis/mapper/UserMapper.xml</code>。</p><p><strong>所以使用原生Mybatis需要注意xml放置的位置</strong>。</p><p>紧接着Mybatis创建了<code>XMLMapperBuilder</code>对象，调用其parse方法进一步的解析xml文件。</p><p>关于上面步骤①和步骤②的流程下面<code>Resource解析方式</code>会复用到，如果需要了解请直接跳转至Resource解析方法。</p><h5 id="parseStatement"><a href="#parseStatement" class="headerlink" title="parseStatement"></a><code>parseStatement</code></h5><p>新版Mybatis支持注解执行SQL语句，通过<code>@SELECT，@INSERT，@UPDATE，@DELETE</code>注解来执行SQL语句。此方法就是解析这些注解并生成<code>MappedStatement</code>对象。</p><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">parseStatement</span><span class="hljs-params">(Method method)</span> &#123;<br>  <span class="hljs-comment">// 获取参数来类型</span><br>  Class&lt;?&gt; parameterTypeClass = getParameterType(method);<br>  <span class="hljs-type">LanguageDriver</span> <span class="hljs-variable">languageDriver</span> <span class="hljs-operator">=</span> getLanguageDriver(method);<br>  <span class="hljs-comment">// 获取到注解中编写的SQL语句</span><br>  <span class="hljs-type">SqlSource</span> <span class="hljs-variable">sqlSource</span> <span class="hljs-operator">=</span> getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);<br>  <span class="hljs-keyword">if</span> (sqlSource != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">Options</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> method.getAnnotation(Options.class);<br>    <span class="hljs-comment">// 生成statementId</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">mappedStatementId</span> <span class="hljs-operator">=</span> type.getName() + <span class="hljs-string">&quot;.&quot;</span> + method.getName();<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">fetchSize</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 默认为PreparedStatement类型</span><br>    <span class="hljs-type">StatementType</span> <span class="hljs-variable">statementType</span> <span class="hljs-operator">=</span> StatementType.PREPARED;<br>    <span class="hljs-type">ResultSetType</span> <span class="hljs-variable">resultSetType</span> <span class="hljs-operator">=</span> configuration.getDefaultResultSetType();<br>    <span class="hljs-comment">//  获取到SQL指令类型，新增? 更新? 查询? 删除?</span><br>    <span class="hljs-type">SqlCommandType</span> <span class="hljs-variable">sqlCommandType</span> <span class="hljs-operator">=</span> getSqlCommandType(method);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSelect</span> <span class="hljs-operator">=</span> sqlCommandType == SqlCommandType.SELECT;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flushCache</span> <span class="hljs-operator">=</span> !isSelect;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">useCache</span> <span class="hljs-operator">=</span> isSelect;<br><span class="hljs-comment">// 获取主键生成器</span><br>    KeyGenerator keyGenerator;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">keyProperty</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">keyColumn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) &#123;<br>      <span class="hljs-comment">// first check for SelectKey annotation - that overrides everything else</span><br>      <span class="hljs-type">SelectKey</span> <span class="hljs-variable">selectKey</span> <span class="hljs-operator">=</span> method.getAnnotation(SelectKey.class);<br>      <span class="hljs-keyword">if</span> (selectKey != <span class="hljs-literal">null</span>) &#123;<br>        keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);<br>        keyProperty = selectKey.keyProperty();<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options == <span class="hljs-literal">null</span>) &#123;<br>        keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;<br>        keyProperty = options.keyProperty();<br>        keyColumn = options.keyColumn();<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      keyGenerator = NoKeyGenerator.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (options != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (FlushCachePolicy.TRUE.equals(options.flushCache())) &#123;<br>        flushCache = <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (FlushCachePolicy.FALSE.equals(options.flushCache())) &#123;<br>        flushCache = <span class="hljs-literal">false</span>;<br>      &#125;<br>      useCache = options.useCache();<br>      fetchSize = options.fetchSize() &gt; -<span class="hljs-number">1</span> || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : <span class="hljs-literal">null</span>; <span class="hljs-comment">//issue #348</span><br>      timeout = options.timeout() &gt; -<span class="hljs-number">1</span> ? options.timeout() : <span class="hljs-literal">null</span>;<br>      statementType = options.statementType();<br>      <span class="hljs-keyword">if</span> (options.resultSetType() != ResultSetType.DEFAULT) &#123;<br>        resultSetType = options.resultSetType();<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resultMapId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 获取ResultMap对象</span><br>    <span class="hljs-type">ResultMap</span> <span class="hljs-variable">resultMapAnnotation</span> <span class="hljs-operator">=</span> method.getAnnotation(ResultMap.class);<br>    <span class="hljs-keyword">if</span> (resultMapAnnotation != <span class="hljs-literal">null</span>) &#123;<br>      resultMapId = String.join(<span class="hljs-string">&quot;,&quot;</span>, resultMapAnnotation.value());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isSelect) &#123;<br>      resultMapId = parseResultMap(method);<br>    &#125;<br><br>    <span class="hljs-comment">// 忽略参数</span><br>    <span class="hljs-comment">// 构建MappedStatement</span><br>    assistant.addMappedStatement();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法内部创建的对象和Mapper标签几乎一致，并且这种方式代码阅读行较差，简单的SQL语句还行，但是复杂的不行。此处不做细致讲解。（后期可能补上）。</p><h3 id="使用Mapper标签解析"><a href="#使用Mapper标签解析" class="headerlink" title="使用Mapper标签解析"></a>使用<code>Mapper</code>标签解析</h3><p>入口：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164159.png" alt="image-20200430183533866"></p><p>可以看出一共有三种方式，分别是<code>resource，url，class</code> 。前两种最终都创建了XMLMapperBuilder对象，而最后一种和Package解析方式类似。</p><p>我们重点关注<code>XMLMapperBuilder</code>这个对象。到这里与Package解析中的<code>loadXmlResource</code>方法处理一致。</p><h4 id="执行XMLMapperBuilder-parse"><a href="#执行XMLMapperBuilder-parse" class="headerlink" title="执行XMLMapperBuilder.parse"></a>执行<code>XMLMapperBuilder.parse</code></h4><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501112922.png" alt="image-20200501112922353" style="zoom:50%;" /><p>重点关注两个方法，分别是：<code>configurationElement：</code>用于解析XML中各个标签，<code>bindMapperForNamespace：</code>将Mapper接口绑定到Configuration上。</p><h4 id="执行XMLMapperBuilder-configurationElement"><a href="#执行XMLMapperBuilder-configurationElement" class="headerlink" title="执行XMLMapperBuilder.configurationElement"></a>执行<code>XMLMapperBuilder.configurationElement</code></h4><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501113148.png" alt="image-20200501113147828"></p><p>红圈中我们能够看到Mybatis对XML中的各个标签都进行了处理。</p><ul><li><pre><code class="hljs">parameterMapElement -&gt; 处理parameterMap标签。<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```<br>  resultMapElements -&gt; 处理resultMap标签<br></code></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;<br>sqlElement -&gt; 处理sql标签</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><br><span class="hljs-operator">-</span> <span class="hljs-operator">```</span><br>  <span class="hljs-variable">buildStatementFromContext</span> <span class="hljs-operator">-&gt;</span> 处理<span class="hljs-built_in">Select</span>，<span class="hljs-built_in">Insert</span>，<span class="hljs-built_in">Delete</span>，<span class="hljs-built_in">Update</span>标签<br></code></pre></td></tr></table></figure></li></ul><p>接下来让我们逐个分析这些方法是如何处理标签的。</p><h4 id="执行bindMapperForNamespace方法"><a href="#执行bindMapperForNamespace方法" class="headerlink" title="执行bindMapperForNamespace方法"></a>执行<code>bindMapperForNamespace</code>方法</h4><p>该方法主要作用是将解析后的XML和Mapper接口绑定到Configuration对象中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindMapperForNamespace</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">namespace</span> <span class="hljs-operator">=</span> builderAssistant.getCurrentNamespace();<br>  <span class="hljs-keyword">if</span> (namespace != <span class="hljs-literal">null</span>) &#123;<br>    Class&lt;?&gt; boundType = Resources.classForName(namespace);<br>    <span class="hljs-keyword">if</span> (boundType != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!configuration.hasMapper(boundType)) &#123;<br>        <span class="hljs-comment">// 标识当前XML已经解析过</span><br>        configuration.addLoadedResource(<span class="hljs-string">&quot;namespace:&quot;</span> + namespace);<br>        <span class="hljs-comment">// 添加到Configuration中</span><br>        configuration.addMapper(boundType);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解析ResultMap标签"><a href="#解析ResultMap标签" class="headerlink" title="解析ResultMap标签"></a>解析<code>ResultMap</code>标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ResultMap <span class="hljs-title function_">resultMapElement</span><span class="hljs-params">(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings, Class&lt;?&gt; enclosingType)</span> &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> resultMapNode.getStringAttribute(<span class="hljs-string">&quot;type&quot;</span>); <span class="hljs-comment">// 这里删除了一些代码</span><br>  Class&lt;?&gt; typeClass = resolveClass(type);<span class="hljs-comment">// 解析type获取对应的Class对象</span><br>  <span class="hljs-keyword">if</span> (typeClass == <span class="hljs-literal">null</span>) &#123;<br>    typeClass = inheritEnclosingType(resultMapNode, enclosingType);<br>  &#125;<br>  <span class="hljs-type">Discriminator</span> <span class="hljs-variable">discriminator</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  List&lt;ResultMapping&gt; resultMappings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(additionalResultMappings);<br>  List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();<br>  <span class="hljs-keyword">for</span> (XNode resultChild : resultChildren) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;constructor&quot;</span>.equals(resultChild.getName())) &#123;<br>      processConstructorElement(resultChild, typeClass, resultMappings);  <span class="hljs-comment">// 步骤④：处理constructor标签</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;discriminator&quot;</span>.equals(resultChild.getName())) &#123;<br>      <span class="hljs-comment">// 步骤③: 处理discriminator标签</span><br>      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 处理其他标签，例如：id，result标签</span><br>      List&lt;ResultFlag&gt; flags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;id&quot;</span>.equals(resultChild.getName())) &#123;<br>        flags.add(ResultFlag.ID);<br>      &#125;<br>      <span class="hljs-comment">// 步骤①：调用buildResultMappingFromContext构建ResultMapping</span><br>      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 获取到标签中的id，extends，autoMapping属性</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultMapNode.getStringAttribute(<span class="hljs-string">&quot;id&quot;</span>,<br>          resultMapNode.getValueBasedIdentifier());<br>  <span class="hljs-type">String</span> <span class="hljs-variable">extend</span> <span class="hljs-operator">=</span> resultMapNode.getStringAttribute(<span class="hljs-string">&quot;extends&quot;</span>);<br>  <span class="hljs-type">Boolean</span> <span class="hljs-variable">autoMapping</span> <span class="hljs-operator">=</span> resultMapNode.getBooleanAttribute(<span class="hljs-string">&quot;autoMapping&quot;</span>);<br>  <span class="hljs-comment">// 初始化ResultMapResolver对象，用于解析生成ResultMap对象</span><br>  <span class="hljs-type">ResultMapResolver</span> <span class="hljs-variable">resultMapResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResultMapResolver</span>(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 步骤②： 执行解析</span><br>    <span class="hljs-keyword">return</span> resultMapResolver.resolve();<br>  &#125; <span class="hljs-keyword">catch</span> (IncompleteElementException  e) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>图中步骤③和步骤④最终都会 调用步骤①的方法，所以我们重点关注步骤①和步骤② 这两个方法。</p><h5 id="生成ResultMapping"><a href="#生成ResultMapping" class="headerlink" title="生成ResultMapping"></a>生成<code>ResultMapping</code></h5><p>进入<code>buildResultMappingFromContext</code>方法，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ResultMapping <span class="hljs-title function_">buildResultMappingFromContext</span><span class="hljs-params">(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags)</span> &#123;<br>  String property;<br>  <span class="hljs-keyword">if</span> (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;<br>    property = context.getStringAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    property = context.getStringAttribute(<span class="hljs-string">&quot;property&quot;</span>);<br>  &#125;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">column</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;column&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">javaType</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;javaType&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">jdbcType</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;jdbcType&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">nestedSelect</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;select&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">nestedResultMap</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;resultMap&quot;</span>, () -&gt;<br>    processNestedResultMappings(context, Collections.emptyList(), resultType));<br>  <span class="hljs-type">String</span> <span class="hljs-variable">notNullColumn</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;notNullColumn&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">columnPrefix</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;columnPrefix&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">typeHandler</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;typeHandler&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;resultSet&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">foreignColumn</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;foreignColumn&quot;</span>);<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">lazy</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lazy&quot;</span>.equals(context.getStringAttribute(<span class="hljs-string">&quot;fetchType&quot;</span>, configuration.isLazyLoadingEnabled() ? <span class="hljs-string">&quot;lazy&quot;</span> : <span class="hljs-string">&quot;eager&quot;</span>));<br>  Class&lt;?&gt; javaTypeClass = resolveClass(javaType);<br>  Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TypeHandler</span>&lt;?&gt;&gt; typeHandlerClass = resolveClass(typeHandler);<br>  <span class="hljs-type">JdbcType</span> <span class="hljs-variable">jdbcTypeEnum</span> <span class="hljs-operator">=</span> resolveJdbcType(jdbcType);<br>  <span class="hljs-comment">// 最终调用buildResultMapping生成了ResultMapping对象</span><br>  <span class="hljs-keyword">return</span> builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出这个方法逻辑比较简单，将子节点中配置的属性获取出来，最终组装了ResultMapping对象。</p><h5 id="生成ResultMap"><a href="#生成ResultMap" class="headerlink" title="生成ResultMap"></a>生成<code>ResultMap</code></h5><p><code>org.apache.ibatis.builder.ResultMapResolver#resolve</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ResultMap <span class="hljs-title function_">resolve</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 调用工具类的</span><br>  <span class="hljs-keyword">return</span> assistant.addResultMap(<span class="hljs-built_in">this</span>.id, <span class="hljs-built_in">this</span>.type, <span class="hljs-built_in">this</span>.extend, <span class="hljs-built_in">this</span>.discriminator, <span class="hljs-built_in">this</span>.resultMappings, <span class="hljs-built_in">this</span>.autoMapping);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>addResultMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ResultMap <span class="hljs-title function_">addResultMap</span><span class="hljs-params">(String id,Class&lt;?&gt; type,String extend,Discriminator discriminator,</span><br><span class="hljs-params">    List&lt;ResultMapping&gt; resultMappings,Boolean autoMapping)</span> &#123;<br>  <br>  id = applyCurrentNamespace(id, <span class="hljs-literal">false</span>);<br>  extend = applyCurrentNamespace(extend, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 如果当前resultMap存在父resultMap</span><br>  <span class="hljs-keyword">if</span> (extend != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// configuration是否已经加载过父resultMap</span><br>    <span class="hljs-keyword">if</span> (!configuration.hasResultMap(extend)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IncompleteElementException</span>(<span class="hljs-string">&quot;Could not find a parent resultmap with id &#x27;&quot;</span> + extend + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br>   <span class="hljs-comment">// 根据父resultMap的Id获取出父resultMap对象</span><br>    <span class="hljs-type">ResultMap</span> <span class="hljs-variable">resultMap</span> <span class="hljs-operator">=</span> configuration.getResultMap(extend);<br>    <span class="hljs-comment">// 去除父resultMap的resultMapping集合</span><br>    List&lt;ResultMapping&gt; extendedResultMappings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(resultMap.getResultMappings());<br>    <span class="hljs-comment">// 去重</span><br>    extendedResultMappings.removeAll(resultMappings);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">declaresConstructor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 遍历当前resultMap的resultMapping，判断其是否包含Constructor</span><br>    <span class="hljs-keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;<br>      <span class="hljs-keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;<br>        declaresConstructor = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果当前resultMap声明了Constructor标签，则删除父resultMap中声明的Constructor标签</span><br>    <span class="hljs-keyword">if</span> (declaresConstructor) &#123;<br>      extendedResultMappings.removeIf(<br>        resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR));<br>    &#125;<br>    <span class="hljs-comment">// 将父resultMap的resultMapping添加到当前resultMap的resultMapping集合中</span><br>    resultMappings.addAll(extendedResultMappings);<br>  &#125;<br>  <span class="hljs-comment">// 构建ResultMap对象</span><br>  <span class="hljs-type">ResultMap</span> <span class="hljs-variable">resultMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResultMap</span>.Builder(configuration, id, type, resultMappings, autoMapping)<br>      .discriminator(discriminator).build();<br>  <span class="hljs-comment">// 将构建好的ResultMap对象添加到Configuration中</span><br>  configuration.addResultMap(resultMap);<br>  <span class="hljs-keyword">return</span> resultMap;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为resultMap标签可以继承其他的resultMap标签，而这个方法主要就是为了处理resultMap继承的问题。可以得出结论：<strong>XML中的<code>resultMap标签</code>最终会被解析成<code>ResultMap对象</code>并复制给了Configuration</strong>。</p><h4 id="解析SQL标签"><a href="#解析SQL标签" class="headerlink" title="解析SQL标签"></a>解析<code>SQL</code>标签</h4><p>resultMap标签解析完，继续看<code>sql标签</code>的解析过程：</p><p>方法入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlElement(context.evalNodes(<span class="hljs-string">&quot;/mapper/sql&quot;</span>));<br></code></pre></td></tr></table></figure><p>获取到XML中所有的sql标签节点对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sqlElement</span><span class="hljs-params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> &#123;<br>  <span class="hljs-keyword">for</span> (XNode context : list) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">databaseId</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;databaseId&quot;</span>);<br>    <span class="hljs-comment">// 获取到sql标签的ID</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;id&quot;</span>);<br>    <span class="hljs-comment">// 和namespace进行拼接</span><br>    id = builderAssistant.applyCurrentNamespace(id, <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 判断是否已经存在次sql标签</span><br>    <span class="hljs-keyword">if</span> (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;<br>      <span class="hljs-comment">// 不存在，添加到sqlFragments中</span><br>      <span class="hljs-comment">// sqlFragments存在于configuration中</span><br>      sqlFragments.put(id, context);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法功能很简单，就是将<code>sql标签的id和对应的XNode节点对象</code>放入到<code>sqlFragments</code>中。</p><p><code>sqlFragments</code>对象在后面解析<code>select|insert|update|delete</code>标签中的include标签时会使用到。</p><h4 id="解析Crud标签"><a href="#解析Crud标签" class="headerlink" title="解析Crud标签"></a>解析<code>Crud</code>标签</h4><p>方法入口 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">buildStatementFromContext(context.evalNodes(<span class="hljs-string">&quot;select|insert|update|delete&quot;</span>));<br></code></pre></td></tr></table></figure><p>获取的所有的CRUD标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildStatementFromContext</span><span class="hljs-params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> &#123;<br>  <span class="hljs-comment">// 获取到所有的select，insert，delete，update标签节点</span><br>  <span class="hljs-keyword">for</span> (XNode context : list) &#123;<br>    <span class="hljs-comment">// 为每一个crud标签创建XMLStatementBuilder对象，用于构建每个标签所对应的MapperStatement对象</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">XMLStatementBuilder</span> <span class="hljs-variable">statementParser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLStatementBuilder</span>(configuration, builderAssistant, context, requiredDatabaseId);<br>    <span class="hljs-comment">// 解析并生成MapperStatement对象</span><br>    statementParser.parseStatementNode();<br>  &#125; <span class="hljs-comment">// 忽略了异常处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该方法对获取到的<code>insert，select，update，delete</code>节点进行了遍历，并实例化了<code>XMLStatementBuilder</code>构建器来构建<code>MapperdStatement</code>。</p><p><code>XMLStatementBuilder</code>会将每个<code>crud标签</code>构建成一个<code>MapperdStatement对象</code>。它两是一对一的关系，后面调用方法执行SQL时就会获取到方法对应的MapperdStatement对象。</p><p>进入<code>parseStatementNode</code>方法：</p><p>重点关注标记的步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseStatementNode</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;id&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">databaseId</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;databaseId&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="hljs-built_in">this</span>.requiredDatabaseId)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">nodeName</span> <span class="hljs-operator">=</span> context.getNode().getNodeName();<br>  <span class="hljs-type">SqlCommandType</span> <span class="hljs-variable">sqlCommandType</span> <span class="hljs-operator">=</span> SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isSelect</span> <span class="hljs-operator">=</span> sqlCommandType == SqlCommandType.SELECT;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">flushCache</span> <span class="hljs-operator">=</span> context.getBooleanAttribute(<span class="hljs-string">&quot;flushCache&quot;</span>, !isSelect);<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">useCache</span> <span class="hljs-operator">=</span> context.getBooleanAttribute(<span class="hljs-string">&quot;useCache&quot;</span>, isSelect);<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">resultOrdered</span> <span class="hljs-operator">=</span> context.getBooleanAttribute(<span class="hljs-string">&quot;resultOrdered&quot;</span>, <span class="hljs-literal">false</span>);<br><br>  <span class="hljs-comment">// 步骤①</span><br>  <span class="hljs-type">XMLIncludeTransformer</span> <span class="hljs-variable">includeParser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLIncludeTransformer</span>(configuration, builderAssistant);<br>  includeParser.applyIncludes(context.getNode());<br><br>  <span class="hljs-type">String</span> <span class="hljs-variable">parameterType</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;parameterType&quot;</span>);<br>  Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);<br><br>  <span class="hljs-type">String</span> <span class="hljs-variable">lang</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;lang&quot;</span>);<br>  <span class="hljs-type">LanguageDriver</span> <span class="hljs-variable">langDriver</span> <span class="hljs-operator">=</span> getLanguageDriver(lang);<br><br>  <span class="hljs-comment">// 步骤②</span><br>  processSelectKeyNodes(id, parameterTypeClass, langDriver);<br><br>  <span class="hljs-comment">// </span><br>  KeyGenerator keyGenerator;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">keyStatementId</span> <span class="hljs-operator">=</span> id + SelectKeyGenerator.SELECT_KEY_SUFFIX;<br>  keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;<br>    keyGenerator = configuration.getKeyGenerator(keyStatementId);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    keyGenerator = context.getBooleanAttribute(<span class="hljs-string">&quot;useGeneratedKeys&quot;</span>,<br>        configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))<br>        ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;<br>  &#125;<br><span class="hljs-comment">// 步骤③</span><br>  <span class="hljs-type">SqlSource</span> <span class="hljs-variable">sqlSource</span> <span class="hljs-operator">=</span> langDriver.createSqlSource(configuration, context, parameterTypeClass);<br>  <span class="hljs-type">StatementType</span> <span class="hljs-variable">statementType</span> <span class="hljs-operator">=</span> StatementType.valueOf(context.getStringAttribute(<span class="hljs-string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));<br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">fetchSize</span> <span class="hljs-operator">=</span> context.getIntAttribute(<span class="hljs-string">&quot;fetchSize&quot;</span>);<br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> context.getIntAttribute(<span class="hljs-string">&quot;timeout&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">parameterMap</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;parameterMap&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">resultType</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;resultType&quot;</span>);<br>  Class&lt;?&gt; resultTypeClass = resolveClass(resultType);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">resultMap</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;resultMap&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">resultSetType</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;resultSetType&quot;</span>);<br>  <span class="hljs-type">ResultSetType</span> <span class="hljs-variable">resultSetTypeEnum</span> <span class="hljs-operator">=</span> resolveResultSetType(resultSetType);<br>  <span class="hljs-keyword">if</span> (resultSetTypeEnum == <span class="hljs-literal">null</span>) &#123;<br>    resultSetTypeEnum = configuration.getDefaultResultSetType();<br>  &#125;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">keyProperty</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;keyProperty&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">keyColumn</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;keyColumn&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">resultSets</span> <span class="hljs-operator">=</span> context.getStringAttribute(<span class="hljs-string">&quot;resultSets&quot;</span>);<br>  <span class="hljs-comment">// 步骤④</span><br>  builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,<br>      fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,<br>      resultSetTypeEnum, flushCache, useCache, resultOrdered,<br>      keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码很长，无需全部阅读，只需查看标记的核心步骤即可。</p><ul><li>步骤①：处理curd标签中的的Include标签。</li><li>步骤②：处理insert标签中的selectKey标签。</li><li>步骤③：处理curd标签中的动态标签 。</li><li>步骤④：将使用最终的crud标签生成MappedStatement对象。</li></ul><h5 id="处理Include标签"><a href="#处理Include标签" class="headerlink" title="处理Include标签"></a>处理<code>Include</code>标签</h5><p>在分析<code>XMLIncludeTransformer.applyIncludes</code>方法前，我们先来看几个问题，以便我们更好的理解Mybatis对 <code>&lt;include/&gt;</code>的处理逻辑：</p><ul><li>Mybatis是如何拆分含有<code>&lt;include/&gt;</code>标签的SQL？拆分各部分SQL关系如何维护？</li><li>Mybatis是如何处理嵌套<code>&lt;include/&gt;</code>标签？</li></ul><p>带着这两个问题，我们进入<code>applyIncludes</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyIncludes</span><span class="hljs-params">(Node source, <span class="hljs-keyword">final</span> Properties variablesContext, <span class="hljs-type">boolean</span> included)</span> &#123;<br><span class="hljs-comment">//  步骤②</span><br>  <span class="hljs-keyword">if</span> (source.getNodeName().equals(<span class="hljs-string">&quot;include&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 步骤⑤ 从sqlFragments中获取include所引用的id，即sql标签中编写的SQL语句。</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">toInclude</span> <span class="hljs-operator">=</span> findSqlFragment(getStringAttribute(source, <span class="hljs-string">&quot;refid&quot;</span>), variablesContext);<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">toIncludeContext</span> <span class="hljs-operator">=</span> getVariablesContext(source, variablesContext);<br>    <span class="hljs-comment">// 步骤⑥ 递归，处理toInclude中嵌套的include标签</span><br>    applyIncludes(toInclude, toIncludeContext, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 如果（toInclude节点）和 source（引入toInclude节点）不在同一个document下</span><br>    <span class="hljs-keyword">if</span> (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;<br>      <span class="hljs-comment">// 将（toInclude节点）导入到 source 节点中去</span><br>      toInclude = source.getOwnerDocument().importNode(toInclude, <span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-comment">// 步骤⑦ 将 source 节点替换成（toInclude节点）</span><br>    source.getParentNode().replaceChild(toInclude, source);<br>    <span class="hljs-comment">// 为了方便阅读对源代码进行了修改</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">toIncludeParentNode</span> <span class="hljs-operator">=</span> toInclude.getParentNode()；<br>    <span class="hljs-comment">// （toInclude节点）含有子节点，可能是嵌套的include标签</span><br>    <span class="hljs-keyword">while</span> (toInclude.hasChildNodes()) &#123;<br>      <span class="hljs-comment">// 将（toInclude节点）下的子节点添加到父节点的集合中，并在（toInclude节点）前面</span><br>      toIncludeParentNode.insertBefore(toInclude.getFirstChild(), toInclude);<br>    &#125;<br>    <span class="hljs-comment">// 步骤⑧ 从父节点中删除（toInclude节点）</span><br>    toIncludeParentNode.removeChild(toInclude);<br>  &#125; <br>  <span class="hljs-comment">// 步骤①</span><br>  <span class="hljs-comment">// source对象为DeferredElementImpl类型，即include，select，insert，update，delete等标签</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (source.getNodeType() == Node.ELEMENT_NODE) &#123;<br><br>    <span class="hljs-comment">// 步骤③</span><br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">children</span> <span class="hljs-operator">=</span> source.getChildNodes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; children.getLength(); i++) &#123;<br>      <span class="hljs-comment">// 步骤④</span><br>      applyIncludes(children.item(i), variablesContext, included);<br>    &#125;<br>  &#125; <br>  <span class="hljs-comment">// source对象为DeferredTextImpl类型，</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (included &amp;&amp; (source.getNodeType() == Node.TEXT_NODE || source.getNodeType() == Node.CDATA_SECTION_NODE) &amp;&amp; !variablesContext.isEmpty()) &#123;<br>    <span class="hljs-comment">// 步骤⑨ 最终替换对象里的data属性</span><br>    source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>这段代码大量使用了递归调用，来处理嵌套标签。</p><p>执行流程：</p><ul><li>判断节点类型是否为元素节点<ul><li>是 <code>--&gt; 步骤①</code><ul><li>获取到子节点，根据<code>include</code>标签进行拆分。<code>--&gt; 步骤③</code></li><li>遍历子节点，递归处理子节点。 <code>--&gt; 步骤④</code></li></ul></li><li>否 <code>--&gt; 步骤②</code>  <ul><li>从<code>sqlFragments</code>中获取到引入SQL节点。 <code>--&gt;步骤⑤</code></li><li>递归处理引入的SQL节点，防止引入的SQL中存在嵌套的Include节点。 <code>--&gt; 步骤⑥</code></li><li>逐层将<code>include标签</code>替换成<code>include中实际的SQL</code>。 <code>--&gt;步骤⑦</code> </li><li>最终删除<code>include标签</code>。 <code>--&gt; 步骤⑧</code></li></ul></li></ul></li><li>直接设置节点值 <code>--&gt;步骤⑨</code></li></ul><p>讲述了大致流程，这里会有一个小疑问，Mybatis到底是如何获取子节点的？是如何拆分的？为了更好的理解这个问题， 引入一张<code>select标签</code>引入<code>&lt;include/&gt;</code>标签的XML解析Debug图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164132.png" alt="include解析" style="zoom:50%;" /><p>从上图画红圈的地方可以，整个<code>select</code>语句被拆分成了三个部分，每个对象中都有：</p><ul><li><code>select</code> 一行产生了一个<code>DeferredTextImpl</code>类型的 对象，简称对象A。</li><li><code>include</code>一行产生了一个<code>DeferredElementImpl</code>类型的对象，简称对象B。</li><li><code>form</code> 和<code> where</code>两行产生了一个<code>DeferredTextImpl</code>类型的对象，简称对象C。</li></ul><p>每个对象中都含有以下三个属性：</p><ul><li><p><code>data</code>标识了当前对象所对应的<code>sql</code>语句内容。</p></li><li><p><code>previousSibling</code>标识了当前对象的前一个对象。</p></li><li><p><code>nextSibling</code>标识来当前对象的下一个对象 。</p></li></ul><p>三个对象前后之前的关系：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">对象A.previousSibling -&gt; 对象C<br>对象B.previousSibling -&gt; 对象A<br>对象C.previousSibling -&gt; 对象B<br></code></pre></td></tr></table></figure><p><strong>这里我们可以看出Mybatis使用了类似  <code>双向链表</code> 的结构来管理标签被拆分后形成的对象。</strong></p><p><strong>这里有一个疑问，为什么<code>select</code>被拆分成了一行，而<code>from</code>和<code>where</code>为什么没被拆分成两行，而是拆分成了一行 ？</strong></p><p>为了验证这个问题，将<code>&lt;include/&gt;</code>替换掉，生成的对象属性如下图。未引入Include的XML解析Debug图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164004.png" style="zoom:50%;" /><p><strong>这里可以得出的结论就是：Mybatis会以<code>&lt;include/&gt;</code>标签为分割线进行SQL语句的切分。</strong></p><p>步骤②处理SelectKey标签代码不做分析，感兴趣的可以自行查看源代码。</p><h5 id="处理dynamic标签"><a href="#处理dynamic标签" class="headerlink" title="处理dynamic标签"></a>处理<code>dynamic</code>标签</h5><p>在进入<code>langDriver.createSqlSource</code>方法前我们先来思考两个问题？</p><ul><li>Mybatis是如何区分动态SQL和静态SQL？</li><li>Mybatis是如何处理包含动态标签的SQL？</li></ul><p>带着这两个问题我们继续分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSource <span class="hljs-title function_">createSqlSource</span><span class="hljs-params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> &#123;<br>  <span class="hljs-comment">// 创建XMLScriptBuilder构建起</span><br>  <span class="hljs-type">XMLScriptBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLScriptBuilder</span>(configuration, script, parameterType);<br>  <span class="hljs-comment">// 构建script节点</span><br>  <span class="hljs-keyword">return</span> builder.parseScriptNode();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看出Mybatis创建了<code>XMLScriptBuilder</code>构建器来构建<code>动态标签</code>。我们先来看看XMLScriptBuilder类结构：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501154915.png" alt="image-20200501154915783" style="zoom:50%;" /><p>从类结构图可以看出有8个处理动态标签的处理类，使用<code>isDynamic()</code>判断是否为动态标签 ，使用<code>nodeHandlerMap</code>来存储动态标签处理器。</p><p>让我进入<code>parseScriptNode</code>方法一探究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSource <span class="hljs-title function_">parseScriptNode</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 解析动态标签</span><br>  <span class="hljs-type">MixedSqlNode</span> <span class="hljs-variable">rootSqlNode</span> <span class="hljs-operator">=</span> parseDynamicTags(context);<br>  SqlSource sqlSource;<br>  <span class="hljs-keyword">if</span> (isDynamic) &#123;<br>    <span class="hljs-comment">// 动态SQL源</span><br>    sqlSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicSqlSource</span>(configuration, rootSqlNode);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 静态SQL源</span><br>    sqlSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RawSqlSource</span>(configuration, rootSqlNode, parameterType);<br>  &#125;<br>  <span class="hljs-keyword">return</span> sqlSource;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看出Mybatis为动态SQL创建了<code>DynamicSqlSource</code>子类，为静态SQL创建了<code>RawSqlSource</code>子类。到这里我们的第一个问题就比较清晰了，<strong>Mybatis使用了不同的SqlSource子类来区分动态SQL和静态SQL</strong>。</p><p>进入<code>parseDynamicTags</code>方法，查看解析动态标签的具体方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> MixedSqlNode <span class="hljs-title function_">parseDynamicTags</span><span class="hljs-params">(XNode node)</span> &#123;<br>  List&lt;SqlNode&gt; contents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <span class="hljs-comment">// 步骤①</span><br>  <span class="hljs-type">NodeList</span> <span class="hljs-variable">children</span> <span class="hljs-operator">=</span> node.getNode().getChildNodes();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; children.getLength(); i++) &#123;<br>    <span class="hljs-type">XNode</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> node.newXNode(children.item(i));<br>    <span class="hljs-comment">// 步骤②</span><br>    <span class="hljs-keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;<br>      <span class="hljs-comment">// 步骤③</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> child.getStringBody(<span class="hljs-string">&quot;&quot;</span>);<br>      <span class="hljs-type">TextSqlNode</span> <span class="hljs-variable">textSqlNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextSqlNode</span>(data);<br>      <span class="hljs-keyword">if</span> (textSqlNode.isDynamic()) &#123;<br>        contents.add(textSqlNode);<br>        isDynamic = <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 步骤③</span><br>        contents.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticTextSqlNode</span>(data));<br>      &#125;<br>    &#125; <br>    <span class="hljs-comment">// 步骤④</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="hljs-number">8</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">nodeName</span> <span class="hljs-operator">=</span> child.getNode().getNodeName();<br>      <span class="hljs-comment">// 步骤⑤</span><br>      <span class="hljs-type">NodeHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> nodeHandlerMap.get(nodeName);<br>      <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuilderException</span>(<span class="hljs-string">&quot;Unknown element &lt;&quot;</span> + nodeName + <span class="hljs-string">&quot;&gt; in SQL statement.&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 步骤⑤</span><br>      handler.handleNode(child, contents);<br>      isDynamic = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MixedSqlNode</span>(contents);<br>&#125;<br></code></pre></td></tr></table></figure><p>配合着源代码梳理一下执行流程，以便更好的理解Mybatis处理逻辑：</p><ul><li>获取到<code>crud标签</code>下所有的<code>子节点</code>，并进行遍历 –&gt; 步骤①</li><li>判断子节点的类型是否是元素节点（即动态标签节点）<ul><li>是 –&gt; <code>动态标签</code> <code>--&gt; 步骤④</code><ul><li>根据动态标签名称从nodeHandlerMap获取出对应的处理器  <code>--&gt; 步骤⑤</code></li><li>调用处理器的handleNode方法处理  <code>--&gt; 步骤⑤</code></li></ul></li><li>否 –&gt; <code>txt文本类型的普通SQL语句</code><ul><li>获取到节点中的<code>Body</code>即SQL语句，创建<code>StaticTextSqlNode</code>对象包装 <code>--&gt; 步骤③</code></li></ul></li></ul></li></ul><p>从上面的类图我们已经知道<code>各自动态标签都对应各自的Handle</code>，那Handle是如何添加到<code>nodeHandlerMap</code>中的呢？</p><p>答案就在<code>XMLScriptBuilder</code>的构造方法中 。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501161032.png" alt="image-20200501161032311"></p><p>接着我们来看看各个Handle对各自标签的处理过程，我们以<code>TrimHandler</code>为准，进入<code>handleNode</code>方法一探究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleNode</span><span class="hljs-params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> &#123;<br>  <span class="hljs-comment">// 递归处理当前动态标签里包含的其他动态标签，即嵌套动态标签。</span><br>  <span class="hljs-type">MixedSqlNode</span> <span class="hljs-variable">mixedSqlNode</span> <span class="hljs-operator">=</span> parseDynamicTags(nodeToHandle);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> nodeToHandle.getStringAttribute(<span class="hljs-string">&quot;prefix&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">prefixOverrides</span> <span class="hljs-operator">=</span> nodeToHandle.getStringAttribute(<span class="hljs-string">&quot;prefixOverrides&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> nodeToHandle.getStringAttribute(<span class="hljs-string">&quot;suffix&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">suffixOverrides</span> <span class="hljs-operator">=</span> nodeToHandle.getStringAttribute(<span class="hljs-string">&quot;suffixOverrides&quot;</span>);<br>  <span class="hljs-comment">// 构建TrimSqlNode对象</span><br>  <span class="hljs-type">TrimSqlNode</span> <span class="hljs-variable">trim</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrimSqlNode</span>(configuration, mixedSqlNode, prefix, prefixOverrides, suffix, suffixOverrides);<br> <span class="hljs-comment">// 添加到集合中</span><br>  targetContents.add(trim);<br>&#125;<br></code></pre></td></tr></table></figure><p>上诉代码将<code>&lt;trim/&gt;</code>签配置的属性都读取出来，并最终生成了一个<code>TrimSqlNode</code>对象。<strong>这里我们可以猜测：是不是每一个标签都会对应拥有一个<code>SqlNode</code>呢？</strong></p><p>是的你没猜错，Mybatis为每种动态标签都生成了对应的SqlNode。下面为SqlNode的继承图 ：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501163950.png" alt="image-20200424174851998" style="zoom:50%;" /><p><strong>到这里，我们上述的第二个问题就非常清晰了：</strong></p><p><strong>Mybatis使用不同的<code>NodeHandler</code>来处理不同的动态标签，使用不同的<code>SqlNode</code>来接收不同动态标签的配置。</strong></p><p>到此SQL解析完成了吗？其实并没有，Mybatis对静态SQL做了进一步的操作，替换<code>#&#123;&#125;</code>为<code>?</code>。我们知道Mybatis会为静态SQL创建<code>RawSqlSource</code>对象。而这个替换操作就是在这里面发生的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">RawSqlSource</span><span class="hljs-params">(Configuration configuration, String sql, Class&lt;?&gt; parameterType)</span> &#123;<br>  <span class="hljs-type">SqlSourceBuilder</span> <span class="hljs-variable">sqlSourceParser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSourceBuilder</span>(configuration);<br>  Class&lt;?&gt; clazz = parameterType == <span class="hljs-literal">null</span> ? Object.class : parameterType;<br>  <span class="hljs-comment">// 解析SqlSource</span><br>  sqlSource = sqlSourceParser.parse(sql, clazz, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSource <span class="hljs-title function_">parse</span><span class="hljs-params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> &#123;<br>  <span class="hljs-type">ParameterMappingTokenHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterMappingTokenHandler</span>(configuration, parameterType, additionalParameters);<br>  <span class="hljs-comment">// 将 #&#123;&#125; 替换成 ?</span><br>  <span class="hljs-type">GenericTokenParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericTokenParser</span>(<span class="hljs-string">&quot;#&#123;&quot;</span>, <span class="hljs-string">&quot;&#125;&quot;</span>, handler);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> parser.parse(originalSql);<br>  <span class="hljs-comment">// 最后创建StaticSqlSource的sqlSource</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticSqlSource</span>(configuration, sql, handler.getParameterMappings());<br>&#125;<br></code></pre></td></tr></table></figure><p>至此步骤 ③执行完成，动态SQL和静态SQL解析完成。</p><h4 id="构建MappedStatement"><a href="#构建MappedStatement" class="headerlink" title="构建MappedStatement"></a>构建<code>MappedStatement</code></h4><p>一切准备工作都已完成，到了最后步骤④，在这个步骤中会将前面几个步骤产生的结果组装到一个叫MappedStatement对象中。</p><p>最终将这个对象添加到Configuration中，可自行查看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,<br>    fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,<br>    resultSetTypeEnum, flushCache, useCache, resultOrdered,<br>    keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);<br></code></pre></td></tr></table></figure><p>此致Mybatis整个启动加载的过程分析完毕。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在这个阶段我们清楚的认知了Mybatis对Mapper解析的过程，使用了<code>XMLStatementBuilder</code>来解析Mapper中的标签，<code>XMLScriptBuilder</code>来解析Mapper中的动态标签。</p><p>使用<code>ResultMapResolver</code>来解析<code>ResultMap</code>标签，并将其每一个子节点映射成了<code>ResultMapping</code>对象。</p><p>使用不同的<code>NodeHandler</code>来处理不同的动态标签，为不同动态标签创建不同的<code>SqlNode</code>对象。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Orm</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-简介</title>
    <link href="/2019/09/09/spring/01-spring-introduction/"/>
    <url>/2019/09/09/spring/01-spring-introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc容器"><a href="#Ioc容器" class="headerlink" title="Ioc容器"></a>Ioc容器</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><p>本文主要讲述Ioc容器和DI相关的概念以及区别</p><p>Ioc是什么?</p><p>DI是什么？</p><p>Ioc为什么叫控制反转？控制了什么？反转了什么？</p><p>Di为什么叫依赖注入？依赖了什么？注入了什么？</p></blockquote><h2 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IoC</strong>），是<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a>中的一种<strong>设计原则</strong>，可以用来减低计算机代码之间的<a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E5%BA%A6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合度</a>。其中最常见的方式叫做<strong>依赖注入</strong>（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。</p><p><strong>IOC不是什么技术，而是一种设计思想</strong>。</p><p>既然IOC是控制反转，那<strong>控制了什么</strong>？<strong>反转了什么</strong>？ </p><p><strong>控制</strong>：传统Java开发中，我们都是主动在类中创建依赖的对象，是程序主动去创建依赖对象；而在IoC中有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建。<strong>即创建和查找依赖对象的控制权交给了IoC容器</strong>。</p><p><strong>反转</strong>：类获取依赖对象的方式不在是主动<code>new</code>，而是想IoC容器获取，即<strong>获得依赖对象的过程被反转</strong>。</p><p>实现方法</p><p>实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><code>DI—Dependency Injection</code>，即<strong>依赖注入</strong>：<strong>组件之间依赖关系</strong>由容器在运行期决定，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>参考 <a href="https://www.martinfowler.com/articles/injection.html">Martin Fowler文章</a></p><p>理解DI的关键是：<strong>谁依赖谁，为什么需要依赖，谁注入谁，注入了什么</strong>。</p><ul><li><p>谁依赖谁：当然是<strong>应用程序依赖于IoC容器</strong>；</p></li><li><p>为什么需要依赖：<strong>应用程序需要IoC容器来提供对象需要的外部资源</strong>；</p></li><li><p>谁注入谁：很明显是<strong>IoC容器注入应用程序某个对象</strong>，应用程序依赖的对象；</p></li><li><p>注入了什么：就是注入<strong>某个对象所需要的外部资源（包括对象、资源、常量数据）</strong>；</p></li></ul><p>IoC和DI之间有什么关系呢？Ioc着重强调的是对象创建和获取的控制，而DI着重强调的是</p><p>依赖注入实现方式：</p><ul><li>基于接口。实现特定接口以供外部容器注入所依赖类型的对象。</li><li>基于<code>set</code>方法。实现特定属性的public set方法，来让外部容器调用传入所依赖类型的对象。</li><li>基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。</li><li>基于注解。基于<a href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3">Java的注解功能</a>，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了public的set方法，但是因为没有真正的set方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为set方法只想让容器访问来注入而并不希望其他依赖此类的对象访问）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
